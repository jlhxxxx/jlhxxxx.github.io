<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>AMAN's BLOG - Test Tools</title><link href="https://jlhxxxx.github.io/" rel="alternate"></link><link href="https://jlhxxxx.github.io/feeds/test-tools.atom.xml" rel="self"></link><id>https://jlhxxxx.github.io/</id><updated>2019-07-13T00:00:00+08:00</updated><entry><title>JMeter文档翻译之18-组件参考（目录跳转未完成）</title><link href="https://jlhxxxx.github.io/jmeter-doc-cn-18.html" rel="alternate"></link><published>2019-07-13T00:00:00+08:00</published><updated>2019-07-13T00:00:00+08:00</updated><author><name>Aman</name></author><id>tag:jlhxxxx.github.io,2019-07-13:/jmeter-doc-cn-18.html</id><summary type="html">&lt;p&gt;英文文档地址：&lt;a href="http://jmeter.apache.org/usermanual/component_reference.html"&gt;http://jmeter.apache.org/usermanual/component_reference.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;b id="toc"&gt;目录：&lt;/b&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#introduction"&gt;18 导言&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#samplers"&gt;18.1 取样器&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#FTP_Request"&gt;FTP请求&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#HTTP_Request"&gt;HTTP请求&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#JDBC_Request"&gt;JDBC请求&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#Java_Request"&gt;Java请求&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#LDAP请求"&gt;LDAP请求&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#LDAP%E6%89%A9%E5%B1%95%E8%AF%B7%E6%B1%82"&gt;LDAP扩展请求&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#Access-Log-Sampler"&gt;Access Log Sampler&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#BeanShell%E5%8F%96%E6%A0%B7%E5%99%A8"&gt;BeanShell取样器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#JRS223%E5%8F%96%E6%A0%B7%E5%99%A8"&gt;JRS223取样器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#TCP%E5%8F%96%E6%A0%B7%E5%99%A8"&gt;TCP取样器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#JMS%E5%8F%91%E5%B8%83"&gt;JMS发布&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#JMS%E8%AE%A2%E9%98%85"&gt;JMS订阅&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#JMS%E7%82%B9%E5%88%B0%E7%82%B9"&gt;JMS点到点&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#JUnit%E8%AF%B7%E6%B1%82"&gt;JUnit请求&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#%E9%82%AE%E4%BB%B6%E9%98%85%E8%AF%BB%E8%80%85%E5%8F%96%E6%A0%B7%E5%99%A8"&gt;邮件阅读者取样器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#%E6%B5%8B%E8%AF%95%E6%B4%BB%E5%8A%A8Flow-Control-Action"&gt;测试活动（Flow Control Action）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#SMTP%E5%8F%96%E6%A0%B7%E5%99%A8"&gt;SMTP取样器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#OS%E8%BF%9B%E7%A8%8B%E5%8F%96%E6%A0%B7%E5%99%A8"&gt;OS进程取样器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#MongoDB%E8%84%9A%E6%9C%AC%E5%B7%B2%E5%BC%83%E7%94%A8"&gt;MongoDB脚本（已弃用）&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#182-%E9%80%BB%E8%BE%91%E6%8E%A7%E5%88%B6%E5%99%A8"&gt;18.2 逻辑控制器&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#%E7%AE%80%E5%8D%95%E6%8E%A7%E5%88%B6%E5%99%A8"&gt;简单控制器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#%E5%BE%AA%E7%8E%AF%E6%8E%A7%E5%88%B6%E5%99%A8"&gt;循环控制器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#%E4%BB%85%E4%B8%80%E6%AC%A1%E6%8E%A7%E5%88%B6%E5%99%A8"&gt;仅一次控制器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#%E4%BA%A4%E6%9B%BF%E6%8E%A7%E5%88%B6%E5%99%A8"&gt;交替控制器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#%E9%9A%8F%E6%9C%BA%E6%8E%A7%E5%88%B6%E5%99%A8"&gt;随机控制器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#%E9%9A%8F%E6%9C%BA%E9%A1%BA%E5%BA%8F%E6%8E%A7%E5%88%B6%E5%99%A8"&gt;随机顺序控制器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#%E5%90%9E%E5%90%90%E9%87%8F%E6%8E%A7%E5%88%B6%E5%99%A8"&gt;吞吐量控制器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#Runtime%E6%8E%A7%E5%88%B6%E5%99%A8"&gt;Runtime控制器 …&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;p&gt;英文文档地址：&lt;a href="http://jmeter.apache.org/usermanual/component_reference.html"&gt;http://jmeter.apache.org/usermanual/component_reference.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;b id="toc"&gt;目录：&lt;/b&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#introduction"&gt;18 导言&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#samplers"&gt;18.1 取样器&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#FTP_Request"&gt;FTP请求&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#HTTP_Request"&gt;HTTP请求&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#JDBC_Request"&gt;JDBC请求&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#Java_Request"&gt;Java请求&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#LDAP请求"&gt;LDAP请求&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#LDAP%E6%89%A9%E5%B1%95%E8%AF%B7%E6%B1%82"&gt;LDAP扩展请求&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#Access-Log-Sampler"&gt;Access Log Sampler&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#BeanShell%E5%8F%96%E6%A0%B7%E5%99%A8"&gt;BeanShell取样器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#JRS223%E5%8F%96%E6%A0%B7%E5%99%A8"&gt;JRS223取样器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#TCP%E5%8F%96%E6%A0%B7%E5%99%A8"&gt;TCP取样器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#JMS%E5%8F%91%E5%B8%83"&gt;JMS发布&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#JMS%E8%AE%A2%E9%98%85"&gt;JMS订阅&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#JMS%E7%82%B9%E5%88%B0%E7%82%B9"&gt;JMS点到点&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#JUnit%E8%AF%B7%E6%B1%82"&gt;JUnit请求&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#%E9%82%AE%E4%BB%B6%E9%98%85%E8%AF%BB%E8%80%85%E5%8F%96%E6%A0%B7%E5%99%A8"&gt;邮件阅读者取样器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#%E6%B5%8B%E8%AF%95%E6%B4%BB%E5%8A%A8Flow-Control-Action"&gt;测试活动（Flow Control Action）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#SMTP%E5%8F%96%E6%A0%B7%E5%99%A8"&gt;SMTP取样器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#OS%E8%BF%9B%E7%A8%8B%E5%8F%96%E6%A0%B7%E5%99%A8"&gt;OS进程取样器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#MongoDB%E8%84%9A%E6%9C%AC%E5%B7%B2%E5%BC%83%E7%94%A8"&gt;MongoDB脚本（已弃用）&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#182-%E9%80%BB%E8%BE%91%E6%8E%A7%E5%88%B6%E5%99%A8"&gt;18.2 逻辑控制器&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#%E7%AE%80%E5%8D%95%E6%8E%A7%E5%88%B6%E5%99%A8"&gt;简单控制器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#%E5%BE%AA%E7%8E%AF%E6%8E%A7%E5%88%B6%E5%99%A8"&gt;循环控制器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#%E4%BB%85%E4%B8%80%E6%AC%A1%E6%8E%A7%E5%88%B6%E5%99%A8"&gt;仅一次控制器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#%E4%BA%A4%E6%9B%BF%E6%8E%A7%E5%88%B6%E5%99%A8"&gt;交替控制器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#%E9%9A%8F%E6%9C%BA%E6%8E%A7%E5%88%B6%E5%99%A8"&gt;随机控制器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#%E9%9A%8F%E6%9C%BA%E9%A1%BA%E5%BA%8F%E6%8E%A7%E5%88%B6%E5%99%A8"&gt;随机顺序控制器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#%E5%90%9E%E5%90%90%E9%87%8F%E6%8E%A7%E5%88%B6%E5%99%A8"&gt;吞吐量控制器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#Runtime%E6%8E%A7%E5%88%B6%E5%99%A8"&gt;Runtime控制器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#%E5%A6%82%E6%9E%9CIf%E6%8E%A7%E5%88%B6%E5%99%A8"&gt;如果（If）控制器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#While%E6%8E%A7%E5%88%B6%E5%99%A8"&gt;While控制器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#Switch%E6%8E%A7%E5%88%B6%E5%99%A8"&gt;Switch控制器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#ForEach%E6%8E%A7%E5%88%B6%E5%99%A8"&gt;ForEach控制器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#%E6%A8%A1%E5%9D%97%E6%8E%A7%E5%88%B6%E5%99%A8"&gt;模块控制器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#Include%E6%8E%A7%E5%88%B6%E5%99%A8"&gt;Include控制器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#%E4%BA%8B%E5%8A%A1%E6%8E%A7%E5%88%B6%E5%99%A8"&gt;事务控制器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#%E5%BD%95%E5%88%B6%E6%8E%A7%E5%88%B6%E5%99%A8"&gt;录制控制器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#%E4%B8%B4%E7%95%8C%E9%83%A8%E5%88%86%E6%8E%A7%E5%88%B6%E5%99%A8"&gt;临界部分控制器&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#183-%E7%9B%91%E5%90%AC%E5%99%A8"&gt;18.3 监听器&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#%E6%A0%B7%E6%9C%AC%E7%BB%93%E6%9E%9C%E4%BF%9D%E5%AD%98%E9%85%8D%E7%BD%AE"&gt;样本结果保存配置&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#%E5%9B%BE%E5%BD%A2%E7%BB%93%E6%9E%9C"&gt;图形结果&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#%E6%96%AD%E8%A8%80%E7%BB%93%E6%9E%9C"&gt;断言结果&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#%E6%9F%A5%E7%9C%8B%E7%BB%93%E6%9E%9C%E6%A0%91"&gt;查看结果树&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#%E8%81%9A%E5%90%88%E6%8A%A5%E5%91%8A"&gt;聚合报告&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#%E7%94%A8%E8%A1%A8%E6%A0%BC%E6%9F%A5%E7%9C%8B%E7%BB%93%E6%9E%9C"&gt;用表格查看结果&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#%E7%AE%80%E5%8D%95%E6%95%B0%E6%8D%AE%E5%86%99%E5%85%A5%E5%99%A8"&gt;简单数据写入器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#%E6%B1%87%E6%80%BB%E5%9B%BE"&gt;汇总图&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#%E5%93%8D%E5%BA%94%E6%97%B6%E9%97%B4%E5%9B%BE"&gt;响应时间图&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#%E9%82%AE%E4%BB%B6%E8%A7%82%E5%AF%9F%E4%BB%AA"&gt;邮件观察仪&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#BeanShell%E7%9B%91%E5%90%AC%E5%99%A8"&gt;BeanShell监听器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#%E6%B1%87%E6%80%BB%E6%8A%A5%E5%91%8A"&gt;汇总报告&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#%E4%BF%9D%E5%AD%98%E5%93%8D%E5%BA%94%E5%88%B0%E6%96%87%E4%BB%B6"&gt;保存响应到文件&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#JSR223%E7%9B%91%E5%90%AC%E5%99%A8"&gt;JSR223监听器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#%E7%94%9F%E6%88%90%E6%A6%82%E8%A6%81%E7%BB%93%E6%9E%9C"&gt;生成概要结果&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#%E6%AF%94%E8%BE%83%E6%96%AD%E8%A8%80%E5%8F%AF%E8%A7%86%E5%8C%96%E5%99%A8"&gt;比较断言可视化器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#%E5%90%8E%E7%AB%AF%E7%9B%91%E5%90%AC%E5%99%A8"&gt;后端监听器&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#184-%E9%85%8D%E7%BD%AE%E5%85%83%E4%BB%B6"&gt;18.4 配置元件&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#CSV-%E6%95%B0%E6%8D%AE%E6%96%87%E4%BB%B6%E8%AE%BE%E7%BD%AE"&gt;CSV 数据文件设置&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#FTP%E8%AF%B7%E6%B1%82%E9%BB%98%E8%AE%A4%E5%80%BC"&gt;FTP请求默认值&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#DNS%E7%BC%93%E5%AD%98%E7%AE%A1%E7%90%86%E5%99%A8"&gt;DNS缓存管理器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#HTTP%E6%8E%88%E6%9D%83%E7%AE%A1%E7%90%86%E5%99%A8"&gt;HTTP授权管理器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#HTTP%E7%BC%93%E5%AD%98%E7%AE%A1%E7%90%86%E5%99%A8"&gt;HTTP缓存管理器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#HTTP-Cookie%E7%AE%A1%E7%90%86%E5%99%A8"&gt;HTTP Cookie管理器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#HTTP%E8%AF%B7%E6%B1%82%E9%BB%98%E8%AE%A4%E5%80%BC"&gt;HTTP请求默认值&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#HTTP%E4%BF%A1%E6%81%AF%E5%A4%B4%E7%AE%A1%E7%90%86%E5%99%A8"&gt;HTTP信息头管理器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#Java%E9%BB%98%E8%AE%A4%E8%AF%B7%E6%B1%82"&gt;Java默认请求&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#JDBC%E8%BF%9E%E6%8E%A5%E9%85%8D%E7%BD%AE"&gt;JDBC连接配置&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#%E5%AF%86%E9%92%A5%E5%BA%93%E9%85%8D%E7%BD%AE"&gt;密钥库配置&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#%E7%99%BB%E5%BD%95%E9%85%8D%E7%BD%AE%E5%85%83%E4%BB%B6"&gt;登录配置元件&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#LDAP%E9%BB%98%E8%AE%A4%E8%AF%B7%E6%B1%82"&gt;LDAP默认请求&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#LDAP%E6%89%A9%E5%B1%95%E8%AF%B7%E6%B1%82%E9%BB%98%E8%AE%A4%E5%80%BC"&gt;LDAP扩展请求默认值&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#TCP%E5%8F%96%E6%A0%B7%E5%99%A8%E9%85%8D%E7%BD%AE"&gt;TCP取样器配置&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#%E7%94%A8%E6%88%B7%E5%AE%9A%E4%B9%89%E7%9A%84%E5%8F%98%E9%87%8F"&gt;用户定义的变量&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F"&gt;随机变量&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#%E8%AE%A1%E6%95%B0%E5%99%A8"&gt;计数器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#%E7%AE%80%E5%8D%95%E9%85%8D%E7%BD%AE%E5%85%83%E4%BB%B6"&gt;简单配置元件&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#MongoDB%E6%BA%90%E9%85%8D%E7%BD%AE%E5%B7%B2%E5%BC%83%E7%94%A8"&gt;MongoDB源配置（已弃用）&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#185-%E6%96%AD%E8%A8%80"&gt;18.5 断言&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#%E5%93%8D%E5%BA%94%E6%96%AD%E8%A8%80"&gt;响应断言&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#%E6%96%AD%E8%A8%80%E6%8C%81%E7%BB%AD%E6%97%B6%E9%97%B4"&gt;断言持续时间&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#%E5%A4%A7%E5%B0%8F%E6%96%AD%E8%A8%80"&gt;大小断言&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#XML%E6%96%AD%E8%A8%80"&gt;XML断言&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#BeanShell%E6%96%AD%E8%A8%80"&gt;BeanShell断言&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#MD5Hex%E6%96%AD%E8%A8%80"&gt;MD5Hex断言&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#HTML%E6%96%AD%E8%A8%80"&gt;HTML断言&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#XPath%E6%96%AD%E8%A8%80"&gt;XPath断言&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#XML-Schema%E6%96%AD%E8%A8%80"&gt;XML Schema断言&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#JSR223%E6%96%AD%E8%A8%80"&gt;JSR223断言&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#%E6%AF%94%E8%BE%83%E6%96%AD%E8%A8%80"&gt;比较断言&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#SMIME%E6%96%AD%E8%A8%80"&gt;SMIME断言&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#JSON%E6%96%AD%E8%A8%80"&gt;JSON断言&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#186-%E5%AE%9A%E6%97%B6%E5%99%A8"&gt;18.6 定时器&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#%E5%9B%BA%E5%AE%9A%E5%AE%9A%E6%97%B6%E5%99%A8"&gt;固定定时器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#%E9%AB%98%E6%96%AF%E9%9A%8F%E6%9C%BA%E5%AE%9A%E6%97%B6%E5%99%A8"&gt;高斯随机定时器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#%E7%BB%9F%E4%B8%80%E9%9A%8F%E6%9C%BA%E5%AE%9A%E6%97%B6%E5%99%A8"&gt;统一随机定时器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#%E5%B8%B8%E6%95%B0%E5%90%9E%E5%90%90%E9%87%8F%E5%AE%9A%E6%97%B6%E5%99%A8"&gt;常数吞吐量定时器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#%E5%87%86%E7%A1%AE%E7%9A%84%E5%90%9E%E5%90%90%E9%87%8F%E5%AE%9A%E6%97%B6%E5%99%A8"&gt;准确的吞吐量定时器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#%E5%90%8C%E6%AD%A5%E5%AE%9A%E6%97%B6%E5%99%A8"&gt;同步定时器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#BeanShell%E5%AE%9A%E6%97%B6%E5%99%A8"&gt;BeanShell定时器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#JSR223%E5%AE%9A%E6%97%B6%E5%99%A8"&gt;JSR223定时器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#%E6%B3%8A%E6%9D%BE%E9%9A%8F%E6%9C%BA%E5%AE%9A%E6%97%B6%E5%99%A8"&gt;泊松随机定时器&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#187-%E5%89%8D%E7%BD%AE%E5%A4%84%E7%90%86%E5%99%A8"&gt;18.7 前置处理器&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#HTML%E9%93%BE%E6%8E%A5%E8%A7%A3%E6%9E%90%E5%99%A8"&gt;HTML链接解析器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#HTTP-URL-%E9%87%8D%E5%86%99%E4%BF%AE%E9%A5%B0%E7%AC%A6"&gt;HTTP URL 重写修饰符&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#%E7%94%A8%E6%88%B7%E5%8F%82%E6%95%B0"&gt;用户参数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#BeanShell%E9%A2%84%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F"&gt;BeanShell预处理程序&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#JSR223%E9%A2%84%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F"&gt;JSR223预处理程序&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#JDBC%E9%A2%84%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F"&gt;JDBC预处理程序&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%94%A8%E6%88%B7%E5%8F%82%E6%95%B0"&gt;正则表达式用户参数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#%E5%8F%96%E6%A0%B7%E5%99%A8%E8%B6%85%E6%97%B6"&gt;取样器超时&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#188-%E5%90%8E%E7%BD%AE%E5%A4%84%E7%90%86%E5%99%A8"&gt;18.8 后置处理器&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%8F%90%E5%8F%96%E5%99%A8"&gt;正则表达式提取器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#CSS%E9%80%89%E6%8B%A9%E5%99%A8%E6%8F%90%E5%8F%96%E5%99%A8%E5%8D%B3CSSJQuery%E6%8F%90%E5%8F%96%E5%99%A8"&gt;CSS选择器提取器（即：CSS/JQuery提取器）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#XPath2-Extractor"&gt;XPath2 Extractor&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#XPath%E6%8F%90%E5%8F%96%E5%99%A8"&gt;XPath提取器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#%E7%BB%93%E6%9E%9C%E7%8A%B6%E6%80%81%E5%A4%84%E7%90%86%E5%99%A8"&gt;结果状态处理器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#BeanShell%E5%90%8E%E7%BD%AE%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F"&gt;BeanShell后置处理程序&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#JSR223%E5%90%8E%E7%BD%AE%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F"&gt;JSR223后置处理程序&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#JDBC%E5%90%8E%E7%BD%AE%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F"&gt;JDBC后置处理程序&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#JSON%E6%8F%90%E5%8F%96%E5%99%A8"&gt;JSON提取器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#%E8%BE%B9%E7%95%8C%E6%8F%90%E5%8F%96%E5%99%A8"&gt;边界提取器&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#189-%E5%85%B6%E4%BB%96%E5%8A%9F%E8%83%BD"&gt;18.9 其他功能&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#%E6%B5%8B%E8%AF%95%E8%AE%A1%E5%88%92"&gt;测试计划&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#%E7%BA%BF%E7%A8%8B%E7%BB%84"&gt;线程组&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#%E5%B7%A5%E4%BD%9C%E5%8F%B0"&gt;工作台&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#SSL%E7%AE%A1%E7%90%86%E5%99%A8"&gt;SSL管理器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#HTTPS%E6%B5%8B%E8%AF%95%E8%84%9A%E6%9C%AC%E5%BD%95%E5%88%B6%E5%99%A8-%E5%8D%B3HTTP%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8"&gt;HTTP(S)测试脚本录制器 （即：HTTP代理服务器）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#HTTP%E9%95%9C%E5%83%8F%E6%9C%8D%E5%8A%A1%E5%99%A8"&gt;HTTP镜像服务器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#%E5%B1%9E%E6%80%A7%E6%98%BE%E7%A4%BA"&gt;属性显示&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#%E8%B0%83%E8%AF%95%E5%8F%96%E6%A0%B7%E5%99%A8"&gt;调试取样器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#%E8%B0%83%E8%AF%95%E5%90%8E%E7%BD%AE%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F"&gt;调试后置处理程序&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#%E6%B5%8B%E8%AF%95%E7%89%87%E6%AE%B5"&gt;测试片段&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#setUp%E7%BA%BF%E7%A8%8B%E7%BB%84"&gt;setUp线程组&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#tearDown%E7%BA%BF%E7%A8%8B%E7%BB%84"&gt;tearDown线程组&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="introduction"&gt;18 导言&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;少数测试元件使用JMeter属性来控制它们的行为。这些属性通常在类被加载时解析。这通常发生在测试计划执行前，所以不能通过&lt;a href="http://jmeter.apache.org/usermanual/functions.html#__setProperty"&gt;__setProperty()&lt;/a&gt;函数来改变设置。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id="samplers"&gt;18.1 取样器&lt;/h1&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;test
&lt;/pre&gt;&lt;/div&gt;



取样器执行JMeter实际的工作。每个取样器（[测试活动](http://jmeter.apache.org/usermanual/component_reference.html#Flow_Control_Action)除外）生成一个或多个样本结果。样本结果具有各种属性（成功/失败，经过时间，数据大小等），并且可以在各种监听器中查看。

&lt;h3 id="FTP_Request"&gt;FTP请求&lt;/h2&gt;

&lt;p&gt;此控制器允许您将FTP“检索文件”或“上传文件”的请求发送到FTP服务器。如果要将多个请求发送到同一FTP服务器，请考虑使用&lt;a href="http://jmeter.apache.org/usermanual/component_reference.html#FTP_Request_Defaults"&gt;FTP默认请求&lt;/a&gt;配置元件，这样您就不必为每个FTP请求生成控制器输入同样的信息。下载文件时，它可以存储在磁盘（本地文件）或响应数据中，或两者都存储。&lt;/p&gt;
&lt;p&gt;延迟设置为登录所需的时间。&lt;/p&gt;
&lt;p&gt;&lt;img alt="Screenshot for Control-Panel of FTP Request" src="http://jmeter.apache.org/images/screenshots/ftptest/ftp-request.png"&gt;&lt;br&gt;
&lt;em&gt;FTP请求控制面板的截图&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参数&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th align="left"&gt;是否必须&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;名称&lt;/td&gt;
&lt;td&gt;树中显示的此取样器的描述性名称。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;服务器名称或IP&lt;/td&gt;
&lt;td&gt;FTP服务器的域名或IP地址。&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;端口&lt;/td&gt;
&lt;td&gt;使用的端口。如果此值&lt;code&gt;&amp;gt;0&lt;/code&gt;，则使用此特定端口，否则JMeter使用默认FTP端口。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;远程文件&lt;/td&gt;
&lt;td&gt;要检索的文件或要上传的目标文件的名称。&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;本地文件&lt;/td&gt;
&lt;td&gt;要上传的或下载的目标文件（默认为远程文件名）。&lt;/td&gt;
&lt;td align="left"&gt;是，如果上传&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;本地文件内容&lt;/td&gt;
&lt;td&gt;提供上传内容，覆盖本地文件属性。&lt;/td&gt;
&lt;td align="left"&gt;是，如果上传&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;get(RETR) / put(STOR)&lt;/td&gt;
&lt;td&gt;是否检索或上传文件。&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;使用二进制模式？&lt;/td&gt;
&lt;td&gt;选中此项以使用二进制模式（默认ASCII）&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;保存文件响应？&lt;/td&gt;
&lt;td&gt;是否将检索到的文件的内容存储在响应数据中。如果模式为ASCII，则内容将在&lt;a href="http://jmeter.apache.org/usermanual/component_reference.html#View_Results_Tree"&gt;查看结果树&lt;/a&gt;中可见。&lt;/td&gt;
&lt;td align="left"&gt;是，如果下载&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;用户名&lt;/td&gt;
&lt;td&gt;FTP帐户用户名。&lt;/td&gt;
&lt;td align="left"&gt;通常是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;密码&lt;/td&gt;
&lt;td&gt;FTP帐户密码。注意这在测试计划中是可见的。&lt;/td&gt;
&lt;td align="left"&gt;通常是&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;另请参阅：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://jmeter.apache.org/usermanual/test_plan.html#assertions"&gt;断言&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://jmeter.apache.org/usermanual/component_reference.html#FTP_Request_Defaults"&gt;FTP默认请求&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://jmeter.apache.org/usermanual/build-ftp-test-plan.html"&gt;创建FTP测试计划&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href="#toc"&gt;【返回目录】&lt;/a&gt;&lt;/p&gt;
&lt;h2 id="HTTP_Request"&gt;HTTP请求&lt;/h2&gt;

&lt;p&gt;此取样器允许您将HTTP/HTTPS请求发送到Web服务器。它还允许您控制JMeter解析HTML文件是否包含图像和其他内含的资源，并发送HTTP请求以检索它们。以下类型的内含的资源将被检索：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;图片&lt;/li&gt;
&lt;li&gt;小程序&lt;/li&gt;
&lt;li&gt;样式表（CSS）和从这些文件引用的资源&lt;/li&gt;
&lt;li&gt;外部脚本&lt;/li&gt;
&lt;li&gt;frames，iframes&lt;/li&gt;
&lt;li&gt;背景图像（body，table，TD，TR）&lt;/li&gt;
&lt;li&gt;背景声音&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;默认解析器是&lt;code&gt;org.apache.jmeter.protocol.http.parser.LagartoBasedHtmlParser&lt;/code&gt;。可以通过“ &lt;code&gt;htmlparser.className&lt;/code&gt;” 属性来变更 - 详细信息请参阅&lt;code&gt;jmeter.properties&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;如果要将多个请求发送到同一Web服务器，请考虑使用&lt;a href="http://jmeter.apache.org/usermanual/component_reference.html#HTTP_Request_Defaults"&gt;HTTP请求默认值&lt;/a&gt;配置元件，这样您就不必为每个HTTP请求输入相同的信息。&lt;/p&gt;
&lt;p&gt;或者，您可能希望使用JMeter的&lt;a href="http://jmeter.apache.org/usermanual/component_reference.html#HTTP(S)_Test_Script_Recorder"&gt;HTTP代理服务器&lt;/a&gt;来创建它们，而不是手动添加HTTP请求。如果您有大量或者包含许多参数的HTTP请求，这可以节省您的时间。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;有两种不同的测试元件用于定义取样器：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;AJP/1.3 取样器&lt;/p&gt;
&lt;p&gt;使用Tomcat mod_jk协议（在AJP模式下不需要Apache httpd就可以测试Tomcat）。AJP取样器不支持多文件上传；只有第一个文件会被上传。&lt;/p&gt;
&lt;p&gt;HTTP请求&lt;/p&gt;
&lt;p&gt;这有一个实现下拉框，它选择要使用的HTTP协议实现：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Java&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;使用JVM提供的HTTP实现。与HttpClient实现相比，它有一些限制 - 见下文。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;HTTPClient4&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;使用Apache HttpComponents HttpClient 4.x。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;空值&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;不设置HTTP取样器的实现方式，所以依赖于HTTP请求默认值（如果存在）或根据&lt;code&gt;jmeter.properties&lt;/code&gt;中定义的&lt;code&gt;jmeter.httpsampler&lt;/code&gt;属性。&lt;/p&gt;
&lt;p&gt;Java HTTP实现有一些限制：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;无法控制连接的重用方式。当JMeter释放连接时，它可能会也可能不会被同一个线程重用。&lt;/li&gt;
&lt;li&gt;此API最适合单线程使用 - 各种设置通过系统属性来定义，因此适用于所有连接。&lt;/li&gt;
&lt;li&gt;不支持Kerberos身份验证。&lt;/li&gt;
&lt;li&gt;不支持使用Keystore Config进行基于客户端的证书测试。&lt;/li&gt;
&lt;li&gt;重试机制更方便控制。&lt;/li&gt;
&lt;li&gt;不支持虚拟主机。&lt;/li&gt;
&lt;li&gt;仅支持以下方法：&lt;code&gt;GET&lt;/code&gt;，&lt;code&gt;POST&lt;/code&gt;，&lt;code&gt;HEAD&lt;/code&gt;，&lt;code&gt;OPTIONS&lt;/code&gt;，&lt;code&gt;PUT&lt;/code&gt;，&lt;code&gt;DELETE&lt;/code&gt;和&lt;code&gt;TRACE&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;通过&lt;a href="http://jmeter.apache.org/usermanual/component_reference.html#DNS_Cache_Manager"&gt;DNS缓存管理器&lt;/a&gt;能够更好地控制DNS缓存&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;注意：&lt;code&gt;FILE&lt;/code&gt;协议仅用于测试目的。无论使用哪个HTTP取样器，它都由相同的代码处理。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果请求需要服务器或代理登录授权（即浏览器将创建弹出对话框），则还必须添加&lt;a href="http://jmeter.apache.org/usermanual/component_reference.html#HTTP_Authorization_Manager"&gt;HTTP授权管理器&lt;/a&gt;配置元件。对于正常登录（即用户在表单中输入登录信息），您需要确定表单提交按钮的作用，并使用适当的方法（通常是&lt;code&gt;POST&lt;/code&gt;）和表单定义中的相应的参数创建HTTP请求。如果页面使用HTTP，则可以使用JMeter代理捕获登录序列。&lt;/p&gt;
&lt;p&gt;每个线程使用单独的SSL上下文。如果要共用一个SSL上下文（不是浏览器的标准行为），请设置JMeter属性：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;https.sessioncontext.shared=true
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;默认情况下，从5.0版开始，SSL线程在线程组迭代期间保留，并在每次测试迭代时重置。如果在您的测试计划中同一个用户迭代多次，那么您应该将其设置为false。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;httpclient.reset_state_on_thread_group_iteration=true
&lt;/pre&gt;&lt;/div&gt;


&lt;blockquote&gt;
&lt;p&gt;注意：这不适用于Java HTTP实现。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;JMeter默认SSL协议级别为TLS。如果服务器需要不同的级别，例如&lt;code&gt;SSLv3&lt;/code&gt;，可以修改JMeter属性，例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;https.default.protocol=SSLv3
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;JMeter还允许修改&lt;code&gt;https.socket.protocols&lt;/code&gt;属性来启用其他协议。&lt;/p&gt;
&lt;p&gt;如果请求使用cookies，那么您还需要一个&lt;a href="http://jmeter.apache.org/usermanual/component_reference.html#HTTP_Cookie_Manager"&gt;HTTP Cookie管理器&lt;/a&gt;。您可以将这些元件添加到线程组或HTTP请求下。如果您有多个需要授权或使用cookies的HTTP请求，请将元件添加到线程组下。这样，所有HTTP请求控制器将共享相同的授权管理器和Cookie管理器。&lt;/p&gt;
&lt;p&gt;如果请求使用“URL重写”技术来保持会话，请参阅 &lt;a href="http://jmeter.apache.org/usermanual/build-adv-web-test-plan.html#session_url_rewriting"&gt;6.1使用URL重写处理用户会话&lt;/a&gt;获取其他配置步骤。&lt;/p&gt;
&lt;p&gt;&lt;img alt="Screenshot for Control-Panel of HTTP Request" src="http://jmeter.apache.org/images/screenshots/http-request.png"&gt;&lt;br&gt;
&lt;em&gt;HTTP请求控制面板的截图&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="HTTP Request Advanced config fields" src="http://jmeter.apache.org/images/screenshots/http-request-advanced-tab.png"&gt;&lt;br&gt;
&lt;em&gt;HTTP请求高级配置字段&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参数&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th align="left"&gt;是否必须&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;名称&lt;/td&gt;
&lt;td&gt;树中显示的此取样器的描述性名称。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;服务器名称或IP&lt;/td&gt;
&lt;td&gt;web服务器的域名或IP地址，例如&lt;code&gt;www.example.com&lt;/code&gt;。【不要包含&lt;code&gt;http://&lt;/code&gt;前缀。】注意：如果在信息头管理器中定义了“&lt;code&gt;Host&lt;/code&gt;”信息头，则将其用作虚拟主机名。&lt;blockquote&gt;服务器是必需的，除非：&lt;ul&gt;&lt;li&gt;它由&lt;a href="http://jmeter.apache.org/usermanual/component_reference.html#HTTP_Request_Defaults"&gt;HTTP请求默认值&lt;/a&gt;提供&lt;/li&gt;&lt;li&gt;或&lt;strong&gt;路径&lt;/strong&gt;字段中设置了包含scheme，主机和端口（&lt;code&gt;scheme://host:port&lt;/code&gt;）的完整URL&lt;/li&gt;&lt;/ul&gt;&lt;/blockquote&gt;&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;端口&lt;/td&gt;
&lt;td&gt;Web服务器监听的端口号。默认为：&lt;code&gt;80&lt;/code&gt;&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;连接超时&lt;/td&gt;
&lt;td&gt;连接超时。等待连接开启的毫秒数。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;响应超时&lt;/td&gt;
&lt;td&gt;响应超时。等待响应的毫秒数。请注意，这适用于每次等待响应。如果服务器响应以多个块发送，则总体经过的时间可能比超时时间长。&lt;br /&gt;&lt;a href="http://jmeter.apache.org/usermanual/component_reference.html#Duration_Assertion"&gt;断言持续时间&lt;/a&gt;可以用于检测需要很长时间才能完成的响应。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;服务器（代理）&lt;/td&gt;
&lt;td&gt;要执行请求的代理服务器的主机名或IP地址。【不要包含&lt;code&gt;http://&lt;/code&gt;前缀。】&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;端口&lt;/td&gt;
&lt;td&gt;代理服务器监听的端口。&lt;/td&gt;
&lt;td align="left"&gt;否，除非指定了代理主机名&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;用户名&lt;/td&gt;
&lt;td&gt;（可选）代理服务器的用户名。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;密码&lt;/td&gt;
&lt;td&gt;（可选）代理服务器的密码。（注意，它在测试计划中是没有加密存储的）&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;实现&lt;/td&gt;
&lt;td&gt;&lt;code&gt;Java&lt;/code&gt;，&lt;code&gt;HttpClient4&lt;/code&gt;。如果没有指定（也没有通过HTTP请求默认值来定义），则默认值取决于JMeter&lt;code&gt;jmeter.httpsampler&lt;/code&gt;属性。如果还取不到值，则使用HttpClient4实现。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;协议&lt;/td&gt;
&lt;td&gt;&lt;code&gt;HTTP&lt;/code&gt;，&lt;code&gt;HTTPS&lt;/code&gt; 或&lt;code&gt;FILE&lt;/code&gt;。默认值：&lt;code&gt;HTTP&lt;/code&gt;。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;方法&lt;/td&gt;
&lt;td&gt;&lt;code&gt;GET&lt;/code&gt;，&lt;code&gt;POST&lt;/code&gt;，&lt;code&gt;HEAD&lt;/code&gt;，&lt;code&gt;TRACE&lt;/code&gt;，&lt;code&gt;OPTIONS&lt;/code&gt;，&lt;code&gt;PUT&lt;/code&gt;，&lt;code&gt;DELETE&lt;/code&gt;，&lt;code&gt;PATCH&lt;/code&gt;（不支持 &lt;code&gt;JAVA&lt;/code&gt;实现）。使用&lt;code&gt;HttpClient4&lt;/code&gt;时，还允许以下与WebDav相关的方法：&lt;code&gt;COPY&lt;/code&gt;，&lt;code&gt;LOCK&lt;/code&gt;，&lt;code&gt;MKCOL&lt;/code&gt;，&lt;code&gt;MOVE&lt;/code&gt;， &lt;code&gt;PROPFIND&lt;/code&gt;，&lt;code&gt;PROPPATCH&lt;/code&gt;，&lt;code&gt;UNLOCK&lt;/code&gt;，&lt;code&gt;REPORT&lt;/code&gt;，&lt;code&gt;MKCALENDAR&lt;/code&gt;， &lt;code&gt;SEARCH&lt;/code&gt;。&lt;br /&gt;可以使用JMeter&lt;code&gt;httpsampler.user_defined_methods&lt;/code&gt;属性为HttpClient4预定义更多方法 。&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;内容编码&lt;/td&gt;
&lt;td&gt;要使用的内容编码（用于&lt;code&gt;POST&lt;/code&gt;，&lt;code&gt;PUT&lt;/code&gt;，&lt;code&gt;PATCH&lt;/code&gt;和&lt;code&gt;FILE&lt;/code&gt;）。这是要使用的字符编码，与HTTP的Content-Encoding信息头无关。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;自动重定向&lt;/td&gt;
&lt;td&gt;将基础http协议处理程序设置为自动遵循重定向，因此JMeter看不到它们，也不会显示为样本。应该只用于&lt;code&gt;GET&lt;/code&gt;和&lt;code&gt;HEAD&lt;/code&gt;请求。HttpClient取样器将拒绝将其用于&lt;code&gt;POST&lt;/code&gt;或&lt;code&gt;PUT&lt;/code&gt;的尝试。&lt;blockquote&gt;警告：有关cookie和信息头的处理，请参阅下文。&lt;/blockquote&gt;&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;跟随重定向&lt;/td&gt;
&lt;td&gt;这仅在未启用“ &lt;code&gt;自动重定向&lt;/code&gt; ”时有效。如果设置，JMeter取样器将检查响应是否为重定向，如果是，则遵循它。初始重定向和进一步响应将显示为额外的样本。父样本的URL和数据字段将从最终（非重定向）样本中获取，但是父样本的字节统计和已用时间包含所有样本。延迟时间从初始响应获取。请注意，HttpClient取样器可能会记录以下消息：&lt;pre&gt;&lt;code&gt;"Redirect requested but followRedirects is disabled"&lt;/code&gt;&lt;/pre&gt;这可以被忽略。 &lt;br/&gt;JMeter将在绝对和相对重定向URL中折叠“ &lt;code&gt;/../segment&lt;/code&gt; ”形式的路径。例如，&lt;code&gt;http://host/one/../two&lt;/code&gt;将折叠为&lt;code&gt;http://host/two&lt;/code&gt;。如有必要，可以通过设置JMeter属性&lt;code&gt;httpsampler.redirect.removeslashdotdot=false&lt;/code&gt;来抑制该行为。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;使用KeepAlive&lt;/td&gt;
&lt;td&gt;JMeter设置连接：&lt;code&gt;keep-alive&lt;/code&gt;信息头。这在默认的HTTP实现下无法正常工作，因为连接重用不在用户控制之下。它在Apache HttpComponents HttpClient实现下有效。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;对POST使用multipart/form-data&lt;/td&gt;
&lt;td&gt;使用&lt;code&gt;multipart/form-data&lt;/code&gt;或&lt;code&gt;application/x-www-form-urlencoded&lt;/code&gt; 的post请求&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;与浏览器兼容的信息头&lt;/td&gt;
&lt;td&gt;使用&lt;code&gt;multipart/form-data&lt;/code&gt;时，会抑制&lt;code&gt;Content-Type&lt;/code&gt;和 &lt;code&gt;Content-Transfer-Encoding&lt;/code&gt;信息头； 仅发送&lt;code&gt;Content-Disposition&lt;/code&gt;信息头。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;路径&lt;/td&gt;
&lt;td&gt;资源的路径（例如，&lt;code&gt;/servlets/myServlet&lt;/code&gt;）。如果资源需要查询字符串参数，请将参数添加到“同请求一起发送参数”部分中。&lt;blockquote&gt;作为特殊情况，如果路径以“ &lt;code&gt;http://&lt;/code&gt; ”或“ &lt;code&gt;https://&lt;/code&gt; ” 开头，则将其用作完整URL。&lt;/blockquote&gt;在这种情况下，服务器，端口和协议字段将被忽略； &lt;code&gt;GET&lt;/code&gt;和&lt;code&gt;DELETE&lt;/code&gt;方法下也会忽略参数。另外要注意的是，路径没有编码 - 除了用&lt;code&gt;％20&lt;/code&gt;替换空格 - 因此可能需要对不安全的字符进行编码以避免诸如&lt;code&gt;URISyntaxException&lt;/code&gt;之类的错误。&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;同请求一起发送参数&lt;/td&gt;
&lt;td&gt;查询字符串将从您提供的参数列表中生成。每个参数都有一个&lt;code&gt;名称&lt;/code&gt;和 &lt;code&gt;值&lt;/code&gt;，还有对参数进行编码的选项，以及包含或排除等号的选项（某些应用程序在值为空字符串时不希望出现等号）。查询字符串将以正确的方式生成，具体取决于您所选择的“方法”（即，如果您选择&lt;code&gt;GET&lt;/code&gt;或&lt;code&gt;DELETE&lt;/code&gt;，查询字符串将附加到URL上，如果是&lt;code&gt;POST&lt;/code&gt;或&lt;code&gt;PUT&lt;/code&gt;，则将单独发送）。同样的，如果使用multipart形式发送文件，则将使用multipart形式规范创建查询字符串。&lt;strong&gt;有关参数处理的更多信息，请参见下文。&lt;/strong&gt;&lt;br /&gt;此外，您可以指定是否对每个参数进行URL编码。如果您不确定这意味着什么，最好选择它。如果您的值包含如下字符，则通常需要编码：&lt;ul&gt;&lt;li&gt;ASCII控制字符&lt;/li&gt;&lt;li&gt;非ASCII字符&lt;/li&gt;&lt;li&gt;保留字符：URL在定义其语法时将某些字符用于特殊用途。如果这些字符没有在URL中的特殊用途中使用，则需要对它们进行编码，例如：'&lt;code&gt;$&lt;/code&gt;'，'&lt;code&gt;&amp;amp;&lt;/code&gt;'，'&lt;code&gt;+&lt;/code&gt;'，'&lt;code&gt;,&lt;/code&gt;'，'&lt;code&gt;/&lt;/code&gt;'，'&lt;code&gt;:&lt;/code&gt;'，'&lt;code&gt;;&lt;/code&gt;'，'&lt;code&gt;=&lt;/code&gt;'，'&lt;code&gt;?&lt;/code&gt;'，'&lt;code&gt;@&lt;/code&gt;'&lt;/li&gt;&lt;li&gt;不安全的字符：由于各种原因，某些字符可能会在URL中被误解。这些字符也应始终编码，例如：'&lt;code&gt;&lt;/code&gt;'，'&lt;code&gt;&amp;lt;&lt;/code&gt;'，'&lt;code&gt;&amp;gt;&lt;/code&gt;'，'&lt;code&gt;#&lt;/code&gt;'，'&lt;code&gt;%&lt;/code&gt;'，...&lt;/li&gt;&lt;/ul&gt;&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;文件名称&lt;/td&gt;
&lt;td&gt;要发送的文件的名称。如果留空，JMeter将不发送文件，如果填写，JMeter会自动将请求作为multipart形式的请求发送。&lt;br /&gt;如果是&lt;code&gt;POST&lt;/code&gt;或&lt;code&gt;PUT&lt;/code&gt;或&lt;code&gt;PATCH&lt;/code&gt;请求，并且只有一个文件其“参数名称”属性（见下文）被省略，则该文件将作为请求的整个消息体发送，即不添加任何封装器。这允许发送任意消息体。此功能适用于&lt;code&gt;POST&lt;/code&gt;请求，也适用于&lt;code&gt;PUT&lt;/code&gt;请求。 &lt;strong&gt;有关参数处理的更多信息，请参见下文。&lt;/strong&gt;&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;参数名称&lt;/td&gt;
&lt;td&gt;Web请求参数“ &lt;code&gt;name&lt;/code&gt; ”的值。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;MIME类型&lt;/td&gt;
&lt;td&gt;MIME类型（例如，&lt;code&gt;text/plain&lt;/code&gt;）。如果它是&lt;code&gt;POST&lt;/code&gt;或&lt;code&gt;PUT&lt;/code&gt;或&lt;code&gt;PATCH&lt;/code&gt;请求，并且省略了' &lt;code&gt;name&lt;/code&gt; '属性（见下文）或者仅从参数值构造了消息体，那么该字段的值将作为&lt;code&gt;content-type&lt;/code&gt;信息头的值。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;从HTML文件获取所有内含的资源&lt;/td&gt;
&lt;td&gt;告诉JMeter解析HTML文件并发送文件中引用的所有图像，Java小程序，JavaScript文件，CSS等的HTTP/HTTPS请求。请参阅下面获得更多细节。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;保存响应为MD5哈希&lt;/td&gt;
&lt;td&gt;如果选中此选项，则响应不会存储在样本结果中。相反，计算并存储响应数据的32位MD5哈希值。这用于测试大量数据。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;网址必须匹配：&lt;/td&gt;
&lt;td&gt;如果选中，则必须填入正则表达式，用于与找到的所有内含的URL匹配。因此，如果您只想从&lt;code&gt;http://example.com/&lt;/code&gt;下载内含的资源，请使用以下表达式： &lt;code&gt;http://example\.com/.*&lt;/code&gt;&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;并行下载&lt;/td&gt;
&lt;td&gt;使用并发连接来获取内含的资源。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;数量&lt;/td&gt;
&lt;td&gt;用于获取内含的资源的并发连接池大小。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;源地址类型&lt;/td&gt;
&lt;td&gt;&lt;em&gt;【仅适用于HTTPClient实现的HTTP请求】&lt;/em&gt; &lt;br/&gt;要区分源地址值，请选择以下类型：&lt;ul&gt;&lt;li&gt;选择&lt;em&gt;IP/主机名&lt;/em&gt;以使用特定IP地址或（本地）主机名&lt;/li&gt;&lt;li&gt;选择&lt;em&gt;设备&lt;/em&gt;以选择该接口的第一个可用地址，该地址可以是IPv4或IPv6&lt;/li&gt;&lt;li&gt;选择&lt;em&gt;设备 IPv4&lt;/em&gt;以选择设备名称的IPv4地址（如&lt;code&gt;eth0&lt;/code&gt;，&lt;code&gt;lo&lt;/code&gt;，&lt;code&gt;em0&lt;/code&gt;等）&lt;/li&gt;&lt;li&gt;选择&lt;em&gt;设备 IPv6&lt;/em&gt;以选择设备名称的IPv6地址（如&lt;code&gt;eth0&lt;/code&gt;，&lt;code&gt;lo&lt;/code&gt;，&lt;code&gt;em0&lt;/code&gt;等）&lt;/li&gt;&lt;/ul&gt;&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;源地址字段&lt;/td&gt;
&lt;td&gt;&lt;em&gt;【仅适用于HTTPClient实现的HTTP请求】&lt;/em&gt; &lt;br/&gt;此属性用于启用IP欺骗。它会覆盖此样本的默认本地IP地址。JMeter主机必须具有多个IP地址（即IP别名，网络接口，设备）。该值可以是主机名，IP地址或网络接口设备，例如“&lt;code&gt;eth0&lt;/code&gt;”或“&lt;code&gt;lo&lt;/code&gt;”或“&lt;code&gt;wlan0&lt;/code&gt;”。&lt;br /&gt;如果定义了属性&lt;code&gt;httpclient.localaddress&lt;/code&gt;，则用于所有HttpClient请求。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;blockquote&gt;
&lt;p&gt;使用自动重定向时，仅对初始URL发送cookies。这可能会导致重定向到本地服务器的网站出现意外行为。例如，如果&lt;code&gt;www.example.com&lt;/code&gt;重定向到&lt;code&gt;www.example.co.uk&lt;/code&gt;。在这种情况下，服务器可能会返回两个URL的cookies，但JMeter只会接收最后一个主机的cookies，即&lt;code&gt;www.example.co.uk&lt;/code&gt;。如果测试计划中的下一个请求使用&lt;code&gt;www.example.com&lt;/code&gt;，而不是&lt;code&gt;www.example.co.uk&lt;/code&gt;，它将无法获得正确的cookies。同样的，只对初始请求发送信息头，对于重定向则不发送。通常只是手动创建的测试计划会出现这个问题，因为使用记录器创建的测试计划将从重定向的URL继续下去。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;参数处理：&lt;/strong&gt; 
对于&lt;code&gt;POST&lt;/code&gt;和&lt;code&gt;PUT&lt;/code&gt;方法，如果没有要发送的文件，并且省略了参数的名称，则通过连接参数的所有值来创建消息体。注意这些值的连接不会添加任何行尾字符。在值字段中可以使用&lt;code&gt;__char()&lt;/code&gt;函数来添加它们。这允许发送任意消息体。如果设置了编码标志，则对值进行编码。另请参阅上面的MIME类型，了解如何控制请求的&lt;code&gt;content-type&lt;/code&gt;信息头。&lt;br&gt;
对于其他方法，如果缺少参数的名称，则忽略该参数。这允许使用由变量定义的可选参数。&lt;/p&gt;
&lt;p&gt;当请求只有未命名的参数（或根本没有参数）时，您可以选择切换到&lt;code&gt;消息体数据&lt;/code&gt;选项卡。此选项在以下情况（以及其他情况）中很有用：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;GWT RPC HTTP请求&lt;/li&gt;
&lt;li&gt;JSON REST HTTP请求&lt;/li&gt;
&lt;li&gt;XML REST HTTP请求&lt;/li&gt;
&lt;li&gt;SOAP HTTP请求&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;注意一旦离开树节点，除非清除&lt;code&gt;消息体数据&lt;/code&gt;标签下的数据，否则无法切换回参数标签。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在&lt;code&gt;消息体数据&lt;/code&gt;模式下，除了最后一行之外，每行发送时都将附加&lt;code&gt;CRLF&lt;/code&gt;。要在最后一行数据之后发送&lt;code&gt;CRLF&lt;/code&gt;，只需确保其后面有空行。（空行虽然看不到，但是可以通过观察光标是否可以放在后续行上看出。）&lt;/p&gt;
&lt;p&gt;&lt;img alt="Figure 1 - HTTP Request with one unnamed parameter" src="http://jmeter.apache.org/images/screenshots/http-request-raw-single-parameter.png"&gt;&lt;br&gt;
&lt;em&gt;图1 - 带有一个未命名参数的HTTP请求&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="Figure 2 - Confirm dialog to switch" src="http://jmeter.apache.org/images/screenshots/http-request-confirm-raw-body.png"&gt;&lt;br&gt;
&lt;em&gt;图2 - 确认要切换的对话框&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="Figure 3 - HTTP Request using Body Data" src="http://jmeter.apache.org/images/screenshots/http-request-raw-body.png"&gt;&lt;br&gt;
&lt;em&gt;图3 - 使用消息体数据的HTTP请求&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;方法的处理：&lt;/strong&gt; 
&lt;code&gt;GET&lt;/code&gt;，&lt;code&gt;DELETE&lt;/code&gt;，&lt;code&gt;POST&lt;/code&gt;，&lt;code&gt;PUT&lt;/code&gt;和&lt;code&gt;PATCH&lt;/code&gt;请求方法的工作方式类似，除了3.1版本外，只有&lt;code&gt;POST&lt;/code&gt;方法支持multipart请求或文件上传。&lt;code&gt;PUT&lt;/code&gt;和&lt;code&gt;PATCH&lt;/code&gt;方法的消息体必须提供以下之一：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将消息体定义为具有空参数名称字段的文件；在这种情况下，MIME类型用作Content-Type&lt;/li&gt;
&lt;li&gt;将消息体定义为没有名称的参数值&lt;/li&gt;
&lt;li&gt;使用“ &lt;code&gt;消息体数据&lt;/code&gt;”标签&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;GET&lt;/code&gt;，&lt;code&gt;DELETE&lt;/code&gt;和&lt;code&gt;POST&lt;/code&gt;方法有一种额外的参数传递方式，就是通过使用&lt;code&gt;参数&lt;/code&gt;标签。 &lt;code&gt;GET&lt;/code&gt;，&lt;code&gt;DELETE&lt;/code&gt;，&lt;code&gt;PUT&lt;/code&gt;和&lt;code&gt;PATCH&lt;/code&gt;需要Content-Type。如果不使用文件，添加一个信息头管理器到取样器并在那里定义Content-Type。&lt;/p&gt;
&lt;p&gt;JMeter扫描内含资源的响应。它使用&lt;code&gt;HTTPResponse.parsers&lt;/code&gt;属性，它是一个解析器的ID列表，例如&lt;code&gt;htmlParser&lt;/code&gt;，&lt;code&gt;cssParser&lt;/code&gt;和&lt;code&gt;wmlParser&lt;/code&gt;。对于找到的每个id，JMeter会检查另外两个属性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;id.types&lt;/code&gt; - 内容类型列表&lt;/li&gt;
&lt;li&gt;&lt;code&gt;id.className&lt;/code&gt; - 用于提取内含资源的解析器&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;有关设置的详细信息，请参阅&lt;code&gt;jmeter.properties&lt;/code&gt;文件。如果未设置&lt;code&gt;HTTPResponse.parser&lt;/code&gt;属性，则JMeter将恢复为先前的行为，即仅扫描&lt;code&gt;text/html&lt;/code&gt;响应。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;模拟慢速连接&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;HttpClient4&lt;/code&gt;和&lt;code&gt;Java&lt;/code&gt; 取样器支持慢速连接的模拟；请参阅&lt;code&gt;jmeter.properties&lt;/code&gt;中的以下条目：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;# Define characters per second &amp;gt; 0 to emulate slow connections
#httpclient.socket.http.cps=0
#httpclient.socket.https.cps=0
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;然而&lt;code&gt;Java&lt;/code&gt;取样器仅支持慢速HTTPS连接。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;响应大小计算&lt;/strong&gt; &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;Java&lt;/code&gt;实现不包括传输的开销，例如在响应消息体中的信息头部分。&lt;br&gt;
&lt;code&gt;HttpClient4&lt;/code&gt;实现包含整个响应消息体的开销，所以该值可能比在响应内容中包含的字节数更大。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;重试处理&lt;/strong&gt; 
默认情况下，HttpClient4和Java实现的重试设置为0，这意味着不会尝试重试。&lt;br&gt;
对于HttpClient4，可以通过设置相关的JMeter属性来设置重试次数，例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;httpclient4.retrycount=3
&lt;/pre&gt;&lt;/div&gt;


&lt;blockquote&gt;
&lt;p&gt;使用HC4实现，默认情况下将在幂等的Http方法上进行重试。如果要重试所有方法，请设置属性&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;   httpclient4.request_sent_retry_enabled=true
&lt;/pre&gt;&lt;/div&gt;


&lt;/blockquote&gt;
&lt;p&gt;注意Java实现在默认情况下也不会重试，您可以通过设置更改它&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;http.java.sampler.retries=3
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;注意：证书不符合算法约束&lt;/strong&gt; 
如果您在具有SSL证书（本身或其信任链中的 SSL 证书）的网站上运行HTTPS请求，该证书使用MD2的签名算法（例如&lt;code&gt;md2WithRSAEncryption&lt;/code&gt;）或大小小于1024位，您可能会遇到以下错误：&lt;code&gt;java.security.cert.CertificateException: Certificates does not conform to algorithm constraints&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;此错误与Java 8中增强的安全性有关。&lt;/p&gt;
&lt;p&gt;要允许您执行HTTPS请求，可以通过编辑Java的&lt;code&gt;jdk.certpath.disabledAlgorithms&lt;/code&gt;属性来降低Java安装的安全性等级。根据您的情况，删除MD2值或取消大小约束。&lt;/p&gt;
&lt;p&gt;此属性在此文件中：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;JAVA_HOME/jre/lib/security/java.security
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;有关详细信息，请参阅 &lt;a href="https://bz.apache.org/bugzilla/show_bug.cgi?id=56357"&gt;Bug56357&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;另请参阅：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://jmeter.apache.org/usermanual/test_plan.html#assertions"&gt;断言&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://jmeter.apache.org/usermanual/build-web-test-plan.html"&gt;构建Web测试计划&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://jmeter.apache.org/usermanual/build-adv-web-test-plan.html"&gt;构建高级Web测试计划&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://jmeter.apache.org/usermanual/component_reference.html#HTTP_Authorization_Manager"&gt;HTTP授权管理器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://jmeter.apache.org/usermanual/component_reference.html#HTTP_Cookie_Manager"&gt;HTTP Cookie管理器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://jmeter.apache.org/usermanual/component_reference.html#HTTP_Header_Manager"&gt;HTTP信息头管理器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://jmeter.apache.org/usermanual/component_reference.html#HTML_Link_Parser"&gt;HTML链接解析器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://jmeter.apache.org/usermanual/component_reference.html#HTTP(S)_Test_Script_Recorder"&gt;HTTP代理服务器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://jmeter.apache.org/usermanual/component_reference.html#HTTP_Request_Defaults"&gt;HTTP请求默认值&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://jmeter.apache.org/usermanual/build-adv-web-test-plan.html#session_url_rewriting"&gt;HTTP请求和会话ID：URL重写&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href="#toc"&gt;【返回目录】&lt;/a&gt;&lt;/p&gt;
&lt;h2 id="JDBC_Request"&gt;JDBC请求&lt;/h2&gt;

&lt;p&gt;此取样器允许您将JDBC请求（SQL查询）发送到数据库。&lt;/p&gt;
&lt;p&gt;在使用之前，您需要设置&lt;a href="http://jmeter.apache.org/usermanual/component_reference.html#JDBC_Connection_Configuration"&gt;JDBC Connection Configuration&lt;/a&gt;配置元件。&lt;/p&gt;
&lt;p&gt;如果提供了“变量名称”列表，则对于Select语句返回的每一行，将使用相应列和对应的行数的值设置变量（如果提供变量名称）。例如，如果Select语句返回2行3列，并且变量列表是&lt;code&gt;A,,C&lt;/code&gt;，则将设置以下变量：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;A_#=2（行数）
A_1=第1列，第1行
A_2=第1列，第2行
C_#=2（行数）
C_1=第3列，第1行
C_2=第3列，第2行
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;如果Select语句返回零行，则&lt;code&gt;A_#&lt;/code&gt;和&lt;code&gt;C_#&lt;/code&gt;变量将设置为&lt;code&gt;0&lt;/code&gt;，并且不会设置其他变量。&lt;/p&gt;
&lt;p&gt;必要时清除旧变量 - 例如，如果第一个select检索到6行而第二个select仅返回3行，则额外的第4行，第5行和第6行的变量将被删除。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;延迟时间设置为获取连接所花费的时间。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img alt="Screenshot for Control-Panel of JDBC Request" src="http://jmeter.apache.org/images/screenshots/jdbctest/jdbc-request.png"&gt;&lt;br&gt;
&lt;em&gt;JDBC请求控制面板的截图&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参数&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th align="left"&gt;是否必须&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;name&lt;/td&gt;
&lt;td&gt;树中显示的此取样器的描述性名称。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Variable Name of Pool declared in JDBC Connection Configuration&lt;/td&gt;
&lt;td&gt;连接池绑定的JMeter变量的名称。这必须与&lt;a href="http://jmeter.apache.org/usermanual/component_reference.html#JDBC_Connection_Configuration"&gt;JDBC Connection Configuration&lt;/a&gt;的“ &lt;code&gt;Variable Name&lt;/code&gt; ”字段一致。&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Query Type&lt;/td&gt;
&lt;td&gt;根据语句类型设置：&lt;ul&gt;&lt;li&gt;Select Statement&lt;/li&gt;&lt;li&gt;Update Statement - 也用于插入和删除&lt;/li&gt;&lt;li&gt;Callable Statement&lt;/li&gt;&lt;li&gt;Prepared Select Statement&lt;/li&gt;&lt;li&gt;Prepared Update Statement - 也用于插入和删除&lt;/li&gt;&lt;li&gt;Commit&lt;/li&gt;&lt;li&gt;Rollback&lt;/li&gt;&lt;li&gt;Autocommit(false)&lt;/li&gt;&lt;li&gt;Autocommit(true)&lt;/li&gt;&lt;li&gt;编辑 - 这应该是一个执行上述语句之一的变量引用&lt;/li&gt;&lt;/ul&gt;&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;SQL Query&lt;/td&gt;
&lt;td&gt;SQL查询语句。&lt;blockquote&gt;不要输入语句结束的分号。&lt;/blockquote&gt;通常不需要使用&lt;code&gt;{&lt;/code&gt;和&lt;code&gt;}&lt;/code&gt;来封装Callable语句； 但是，如果数据库使用非标准语法，可以使用它们。&lt;blockquote&gt;如果语句封装在&lt;code&gt;{}&lt;/code&gt;中，JDBC驱动程序会自动转换该语句。&lt;/blockquote&gt;例如：&lt;ul&gt;&lt;li&gt;&lt;code&gt;select * from t_customers where id=23&lt;/code&gt;&lt;/li&gt;&lt;li&gt;&lt;code&gt;CALL SYSCS_UTIL.SYSCS_EXPORT_TABLE (null, ?, ?, null, null, null)&lt;/code&gt;&lt;li&gt;&lt;ul&gt;&lt;li&gt;参数值：&lt;code&gt;tablename&lt;/code&gt;，&lt;code&gt;filename&lt;/code&gt;&lt;/li&gt;&lt;li&gt;参数类型：&lt;code&gt;VARCHAR&lt;/code&gt;，&lt;code&gt;VARCHAR&lt;/code&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;第二个示例假设您正在使用Apache Derby。&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Parameter values&lt;/td&gt;
&lt;td&gt;以逗号分隔的参数值列表。使用&lt;code&gt;]NULL[&lt;/code&gt;表示&lt;code&gt;NULL&lt;/code&gt;参数。（如果需要，可以通过定义属性"&lt;code&gt;jdbcsampler.nullmarker&lt;/code&gt;"来更改空字符串。） &lt;br/&gt;如果任何值包含逗号或双引号，则列表必须用双引号括起来，并且任何内含的的双引号都必须加倍，例如：&lt;pre&gt;&lt;code&gt;"Dbl-Quote: "" and Comma: ,"&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;即使您的参数是&lt;code&gt;OUT&lt;/code&gt;类型，语句中的值也必须与占位符一样多。即使不使用该值，也必须确保设置该值（例如在Callable语句中）。&lt;/blockquote&gt;&lt;/td&gt;
&lt;td align="left"&gt;是，如果prepared或callable语句含有参数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Parameter types&lt;/td&gt;
&lt;td&gt;以逗号分隔的SQL参数类型列表（例如&lt;code&gt;INTEGER&lt;/code&gt;，&lt;code&gt;DATE&lt;/code&gt;，&lt;code&gt;VARCHAR&lt;/code&gt;，&lt;code&gt;DOUBLE&lt;/code&gt;）或常量的整数值。当您使用驱动程序提供的自定义数据库类型时，可以使用这些整数值（例如&lt;code&gt;OracleTypes.CURSOR&lt;/code&gt;可以用其整数值&lt;code&gt;-10&lt;/code&gt;来表示）。&lt;br /&gt; 这些被定义为&lt;code&gt;java.sql.Types&lt;/code&gt;类中的字段，参见示例：&lt;a href="http://docs.oracle.com/javase/8/docs/api/java/sql/Types.html"&gt;java.sql.Types的Javadoc&lt;/a&gt;。&lt;blockquote&gt;注意：JMeter将使用运行时JVM定义的任何类型，因此如果您在不同的JVM上运行，请务必查阅相应的文档&lt;/blockquote&gt;&lt;strong&gt;如果callable语句具有&lt;code&gt;INOUT&lt;/code&gt;或&lt;code&gt;OUT&lt;/code&gt;参数，则必须为相应的参数类型添加前缀来指示这些参数，例如，使用"&lt;code&gt;INOUT INTEGER&lt;/code&gt;"而不是"&lt;code&gt;INTEGER&lt;/code&gt;"。&lt;/strong&gt;&lt;br/&gt;如果未指定，则假定为“&lt;code&gt;IN&lt;/code&gt;”，即“&lt;code&gt;DATE&lt;/code&gt;”与“&lt;code&gt;IN DATE&lt;/code&gt;” 相同。 &lt;br/&gt;如果类型不在&lt;code&gt;java.sql.Types&lt;/code&gt;中，JMeter也接受相应的整数，例如，由于&lt;code&gt;OracleTypes.CURSOR == -10&lt;/code&gt;，所以您可以使用“&lt;code&gt;INOUT -10&lt;/code&gt;”。 &lt;br/&gt;类型必须同语句中的占位符一样多。&lt;/td&gt;
&lt;td align="left"&gt;是，如果prepared或callable语句含有参数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Variable Names&lt;/td&gt;
&lt;td&gt;以逗号分隔的变量名列表，用于保存Select语句，Prepared Select语句或Callable语句的返回值。注意当与Callable语句使用时，变量列表必须与调用返回的&lt;code&gt;OUT&lt;/code&gt;参数的顺序相同。如果变量名称少于&lt;code&gt;OUT&lt;/code&gt;参数，则只有和提供变量名称相同数目的结果会存储在线程上下文变量中。如果提供比&lt;code&gt;OUT&lt;/code&gt;参数更多的变量名称，多余的变量将被忽略。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Result Variable Name&lt;/td&gt;
&lt;td&gt;如果指定，这将创建一个包含行映射列表的对象变量。每个映射都以列名作为键，列数据作为值。用法：&lt;pre&gt;&lt;code&gt;columnValue = vars.getObject("resultObject").get(0).get("Column Name")；&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Query timeout(s)&lt;/td&gt;
&lt;td&gt;设置查询的超时秒数，空值表示0，为无限。&lt;code&gt;-1&lt;/code&gt;表示不设置用例可能需要的任何查询超时，或者某些驱动程序不支持超时。默认值为0。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Handle ResultSet&lt;/td&gt;
&lt;td&gt;定义如何处理从可调用语句返回的ResultSet：&lt;ul&gt;&lt;li&gt;&lt;code&gt;Store As String&lt;/code&gt;（默认） - “变量名称”列表中的所有变量都存储为字符串，当列表中存在时，不会遍历&lt;code&gt;ResultSet&lt;/code&gt;。&lt;code&gt;CLOB&lt;/code&gt;将转换为字符串。&lt;code&gt;BLOB&lt;/code&gt;将作为UTF-8编码的字节数组转换为字符串。&lt;code&gt;CLOB&lt;/code&gt;和&lt;code&gt;BLOB&lt;/code&gt;都将在在&lt;code&gt;jdbcsampler.max_retain_result_size&lt;/code&gt;字节后被切断。&lt;/li&gt;&lt;li&gt;&lt;code&gt;Store As Object&lt;/code&gt; - 变量名称列表上的&lt;code&gt;ResultSet&lt;/code&gt;类型的变量将存储为对象，可以在后续测试/脚本中访问并迭代，不会遍历&lt;code&gt;ResultSet&lt;/code&gt;。&lt;code&gt;CLOB&lt;/code&gt;将像选择了&lt;code&gt;Store As String&lt;/code&gt;一样被处理。&lt;code&gt;BLOB&lt;/code&gt;将存储为字节数组。&lt;code&gt;CLOB&lt;/code&gt;和&lt;code&gt;BLOB&lt;/code&gt;都将在在&lt;code&gt;jdbcsampler.max_retain_result_size&lt;/code&gt;字节后被切断。&lt;/li&gt;&lt;li&gt;&lt;code&gt;Count Records&lt;/code&gt; - &lt;code&gt;ResultSet&lt;/code&gt;类型的变量将通过显示记录计数作为结果来迭代。变量将存储为字符串。对于&lt;code&gt;BLOB&lt;/code&gt;，将存储对象的大小。&lt;/li&gt;&lt;/ul&gt;&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;另请参阅：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://jmeter.apache.org/usermanual/build-db-test-plan.html"&gt;构建数据库测试计划&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://jmeter.apache.org/usermanual/component_reference.html#JDBC_Connection_Configuration"&gt;JDBC Connection Configuration&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;当前版本的JMeter使用UTF-8作为字符编码。以前使用平台默认值。&lt;/p&gt;
&lt;p&gt;确保变量名称在测试计划中是唯一的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href="#toc"&gt;【返回目录】&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="java"&gt;Java请求&lt;/h3&gt;
&lt;p&gt;此取样器允许您控制实现&lt;code&gt;org.apache.jmeter.protocol.java.sampler.JavaSamplerClient&lt;/code&gt;接口的java类  。通过编写您自己的此接口实现，您可以用JMeter来控制多个线程，输入参数控制和数据收集。&lt;/p&gt;
&lt;p&gt;下拉菜单提供了JMeter在其classpath中找到的所有此类实现的列表。可以在下面的表中指定参数 - 由您的实现定义。JMeter提供了两个简单示例（&lt;code&gt;JavaTest&lt;/code&gt;和&lt;code&gt;SleepTest&lt;/code&gt;）。 &lt;/p&gt;
&lt;p&gt;&lt;code&gt;JavaTest&lt;/code&gt;示例取样器对检查测试计划非常有用，因为它允许在几乎所有的字段设置值。这些可以被断言等使用。这些字段允许使用变量，因此可以很容易地看到这些变量的值。 &lt;/p&gt;
&lt;p&gt;&lt;img alt="Screenshot for Control-Panel of Java Request" src="http://jmeter.apache.org/images/screenshots/java_request.png"&gt;&lt;br&gt;
&lt;em&gt;Java 请求的控制面板的截图&lt;/em&gt; &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如果&lt;code&gt;teardownTest&lt;/code&gt;方法未被&lt;a href="http://jmeter.apache.org/api/org/apache/jmeter/protocol/java/sampler/AbstractJavaSamplerClient.html"&gt;AbstractJavaSamplerClient&lt;/a&gt;的子类覆盖，则不会调用其&lt;code&gt;teardownTest&lt;/code&gt;方法。这降低了JMeter内存要求。不会对现有的测试计划产生任何影响。 &lt;/p&gt;
&lt;p&gt;添加/删除按钮目前不起任何作用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;参数&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th align="left"&gt;是否必须&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;名称&lt;/td&gt;
&lt;td&gt;树中显示的此取样器的描述性名称。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;类名称&lt;/td&gt;
&lt;td&gt;要取样的JavaSamplerClient接口的具体实现。&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;发送带参数的请求&lt;/td&gt;
&lt;td&gt;将传递给取样类的参数列表。所有参数都以字符串形式发送。请参阅下面的具体设置。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;以下参数适用于&lt;code&gt;SleepTest&lt;/code&gt;和&lt;code&gt;JavaTest&lt;/code&gt;实现：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参数&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th align="left"&gt;是否必须&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Sleep_time&lt;/td&gt;
&lt;td&gt;睡眠时间（ms）&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Sleep_mask&lt;/td&gt;
&lt;td&gt;添加多少“随机性”：&lt;br/&gt;睡眠时间计算如下：&lt;pre&gt;&lt;code&gt;totalSleepTime = SleepTime + (System.currentTimeMillis() % SleepMask)&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;以下参数适用于&lt;code&gt;JavaTest&lt;/code&gt;实现：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参数&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th align="left"&gt;是否必须&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Label&lt;/td&gt;
&lt;td&gt;要使用的标签。如果提供，则覆盖&lt;code&gt;名称&lt;/code&gt;&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ResponseCode&lt;/td&gt;
&lt;td&gt;如果提供，则设置SampleResult ResponseCode。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ResponseMessage&lt;/td&gt;
&lt;td&gt;如果提供，则设置SampleResult ResponseMessage。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Status&lt;/td&gt;
&lt;td&gt;如果提供，则设置SampleResult Status。如果它等于“&lt;code&gt;OK&lt;/code&gt; ”（忽略大小写），则状态设置为成功，否则样本被标记为失败。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;SamplerData&lt;/td&gt;
&lt;td&gt;如果提供，则设置SampleResult SamplerData。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ResultData&lt;/td&gt;
&lt;td&gt;如果提供，则设置SampleResult ResultData。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;a href="#toc"&gt;【返回目录】&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="ldap"&gt;LDAP请求&lt;/h3&gt;
&lt;p&gt;此取样器允许您向LDAP服务器发送不同的LDAP请求（&lt;code&gt;添加&lt;/code&gt;，&lt;code&gt;修改&lt;/code&gt;，&lt;code&gt;删除&lt;/code&gt;和&lt;code&gt;搜索&lt;/code&gt;）。     &lt;/p&gt;
&lt;p&gt;如果要将多个请求发送到同一LDAP服务器，请考虑使用&lt;a href="http://jmeter.apache.org/usermanual/component_reference.html#LDAP_Request_Defaults"&gt;LDAP默认请求&lt;/a&gt;配置元件，这样您就不必为每个LDAP请求输入相同的信息。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://jmeter.apache.org/usermanual/component_reference.html#Login_Config_Element"&gt;登录配置元件&lt;/a&gt;也使用同样的方法发送用户名和密码。&lt;/p&gt;
&lt;p&gt;&lt;img alt="Screenshot for Control-Panel of LDAP Request" src="http://jmeter.apache.org/images/screenshots/ldap_request.png"&gt;&lt;br&gt;
&lt;em&gt;LDAP请求控制面板的屏截图&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;创建测试LDAP服务器的测试用例有两种方法。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;内置测试用例。&lt;/li&gt;
&lt;li&gt;用户定义的测试用例。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;测试LDAP有四种测试方案。测试方案如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;添加测试       &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;内置测试：           &lt;/p&gt;
&lt;p&gt;这将在LDAP服务器中添加预定义的条目并计算执行时间。执行测试后，将从LDAP服务器中删除创建的条目。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;用户定义的测试：           &lt;/p&gt;
&lt;p&gt;这将在LDAP服务器中添加条目。用户必须输入表中的所有属性。从表中收集条目以进行添加。计算执行时间。测试后不会删除创建的条目。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;修改测试       &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;内置测试：           &lt;/p&gt;
&lt;p&gt;这将首先创建预定义的条目，然后修改LDAP服务器中创建的条目。并计算执行时间。执行测试后，将从LDAP服务器中删除创建的条目。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;用户定义的测试：           &lt;/p&gt;
&lt;p&gt;这将修改LDAP服务器中的条目。用户必须输入表中的所有属性。从表中收集条目以进行修改。计算执行时间。该条目不会从LDAP服务器中删除。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;搜索测试       &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;内置测试：           &lt;/p&gt;
&lt;p&gt;这将首先创建条目，如果属性可用则执行搜索。计算搜索查询的执行时间。在执行结束时，将从LDAP服务器中删除创建的条目。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;用户定义的测试：           &lt;/p&gt;
&lt;p&gt;这将搜索搜索库（同样，由用户定义）中的用户定义条目（搜索过滤）。这些条目应该在LDAP服务器中可用。计算执行时间。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;删除测试       &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;内置测试：           &lt;/p&gt;
&lt;p&gt;这将首先创建预定义的条目，然后将从LDAP服务器中删除。计算执行时间。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;用户定义的测试：           &lt;/p&gt;
&lt;p&gt;这将删除LDAP服务器中的用户定义条目。这些条目应该在LDAP服务器中可用。计算执行时间。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;参数&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th align="left"&gt;是否必须&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;名称&lt;/td&gt;
&lt;td&gt;树中显示的此取样器的描述性名称。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;服务器名称或IP&lt;/td&gt;
&lt;td&gt;LDAP服务器的域名或IP地址。JMeter假定LDAP服务器正在监听默认端口（&lt;code&gt;389&lt;/code&gt;）。&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;端口&lt;/td&gt;
&lt;td&gt;要连接的端口（默认为&lt;code&gt;389&lt;/code&gt;）。&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;根DN&lt;/td&gt;
&lt;td&gt;用于LDAP操作的基本DN&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;用户名&lt;/td&gt;
&lt;td&gt;LDAP服务器用户名。&lt;/td&gt;
&lt;td align="left"&gt;通常是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;密码&lt;/td&gt;
&lt;td&gt;LDAP服务器密码。（注意，这在测试计划中没有加密存储）&lt;/td&gt;
&lt;td align="left"&gt;通常是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;DN入口&lt;/td&gt;
&lt;td&gt;要创建或修改的上下文的名称；可能不为空。&lt;blockquote&gt;您必须自己设置对象的正确属性。因此，如果要添加&lt;code&gt;cn=apache&lt;/code&gt;，&lt;code&gt;ou=test&lt;/code&gt; ，则必须将&lt;code&gt;cn&lt;/code&gt;和&lt;code&gt;apache&lt;/code&gt;添加到表的&lt;code&gt;name&lt;/code&gt;和&lt;code&gt;value&lt;/code&gt;中。&lt;/blockquote&gt;&lt;/td&gt;
&lt;td align="left"&gt;是，如果选择了用户定义的测试和添加测试或修改测试&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;删除&lt;/td&gt;
&lt;td&gt;要删除的上下文的名称；可能不为空&lt;/td&gt;
&lt;td align="left"&gt;是，如果选择了用户定义的测试和删除测试&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Search base&lt;/td&gt;
&lt;td&gt;要搜索的上下文或对象的名称&lt;/td&gt;
&lt;td align="left"&gt;是，如果选择了用户定义的测试和搜索测试&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;搜索过滤器&lt;/td&gt;
&lt;td&gt;用于搜索的过滤器表达式；可能不为空&lt;/td&gt;
&lt;td align="left"&gt;是，如果选择了用户定义的测试和搜索测试&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;添加测试&lt;/td&gt;
&lt;td&gt;使用&lt;code&gt;name&lt;/code&gt;，&lt;code&gt;value&lt;/code&gt;键值对在给定上下文中创建新对象&lt;/td&gt;
&lt;td align="left"&gt;是，如果选择了用户定义的测试和添加测试&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;修改测试&lt;/td&gt;
&lt;td&gt;使用&lt;code&gt;name&lt;/code&gt;，&lt;code&gt;value&lt;/code&gt;键值对来修改给定的上下文对象&lt;/td&gt;
&lt;td align="left"&gt;是，如果选择了用户定义的测试和修改测试&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;另请参阅：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://jmeter.apache.org/usermanual/build-ldap-test-plan.html"&gt;构建LDAP测试计划&lt;/a&gt; &lt;/li&gt;
&lt;li&gt;&lt;a href="http://jmeter.apache.org/usermanual/component_reference.html#LDAP_Request_Defaults"&gt;LDAP默认请求&lt;/a&gt; &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href="#toc"&gt;【返回目录】&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="ldap_1"&gt;LDAP扩展请求&lt;/h3&gt;
&lt;p&gt;此取样器可以将所有8个不同的LDAP请求发送到LDAP服务器。它是LDAP取样器的扩展版本，因此配置起来比较困难，但可以更接近真实的LDAP会话。     &lt;/p&gt;
&lt;p&gt;如果要将多个请求发送到同一LDAP服务器，请考虑使用&lt;a href="http://jmeter.apache.org/usermanual/component_reference.html#LDAP_Extended_Request_Defaults"&gt;LDAP扩展请求默认值&lt;/a&gt;配置元件，这样您就不必为每个LDAP请求输入相同的信息。&lt;/p&gt;
&lt;p&gt;&lt;img alt="Screenshot for Control-Panel of LDAP Extended Request" src="http://jmeter.apache.org/images/screenshots/ldapext_request.png"&gt;&lt;br&gt;
&lt;em&gt;LDAP扩展请求控制面板的截图&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;定义了九个测试操作。这些操作如下：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;线程绑定&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;任何LDAP请求都是LDAP会话的一部分，因此首先要做的是启动与LDAP服务器的会话。使用线程绑定启动此会话，这相当于LDAP的“&lt;code&gt;bind&lt;/code&gt;”操作。要求用户提供&lt;code&gt;username&lt;/code&gt;（专有名称）和&lt;code&gt;password&lt;/code&gt;，用于启动会话。如果未指定密码或密码错误，则会启动匿名会话。注意，省略密码不会使此测试失败，错误密码才会。（注意，它在测试计划中是没有加密存储的）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参数&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th align="left"&gt;是否必须&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;名称&lt;/td&gt;
&lt;td&gt;树中显示的此取样器的描述性名称。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;服务器名称&lt;/td&gt;
&lt;td&gt;LDAP服务器的名称（或IP地址）。&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;端口&lt;/td&gt;
&lt;td&gt;LDAP服务器监听的端口号。如果省略，则JMeter假定LDAP服务器正在监听默认端口（&lt;code&gt;389&lt;/code&gt;）。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;DN&lt;/td&gt;
&lt;td&gt;用于任何后续操作的基本对象的可分辨名称。它可以用作所有操作的起点。您无法在比此DN更高的级别上启动任何操作！&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Username&lt;/td&gt;
&lt;td&gt;要绑定的用户的完整可分辨名称。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Password&lt;/td&gt;
&lt;td&gt;上述用户的密码。如果省略，将导致匿名绑定。如果不正确，则取样器将返回错误并恢复为匿名绑定。（注意，这在测试计划中是没有加密存储的）&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Connection timeout (in milliseconds)&lt;/td&gt;
&lt;td&gt;连接超时时间，如果超时连接将中止&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Use Secure LDAP Protocol&lt;/td&gt;
&lt;td&gt;使用&lt;code&gt;ldaps://&lt;/code&gt;方案而不是&lt;code&gt;ldap://&lt;/code&gt;&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Trust All Certificates&lt;/td&gt;
&lt;td&gt;信任所有证书，仅在选中&lt;code&gt;Use Secure LDAP Protocol&lt;/code&gt;时使用&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;线程解绑&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;这只是结束会话的操作。它等于LDAP“&lt;code&gt;unbind&lt;/code&gt;”操作。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参数&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th align="left"&gt;是否必须&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;名称&lt;/td&gt;
&lt;td&gt;树中显示的此取样器的描述性名称。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;单绑定/解绑&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;这是LDAP“&lt;code&gt;bind&lt;/code&gt;”和“&lt;code&gt;unbind&lt;/code&gt;”操作的组合。它可用于任何用户的身份认证请求/密码检查。它将打开一个新会话，只是为了检查用户/密码组合的有效性，并再次结束会话。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参数&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th align="left"&gt;是否必须&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;名称&lt;/td&gt;
&lt;td&gt;树中显示的此取样器的描述性名称。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Username&lt;/td&gt;
&lt;td&gt;要绑定的用户的完整可分辨名称。&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Password&lt;/td&gt;
&lt;td&gt;上述用户的密码。如果省略，将导致匿名绑定。如果不正确，则取样器将返回错误。（注意，这在测试计划中是没有加密存储的）&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;重命名条目&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;这是LDAP“&lt;code&gt;moddn&lt;/code&gt;”操作。它可用于重命名条目，也可用于将条目或完整子树移动到LDAP树中的其他位置。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参数&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th align="left"&gt;是否必须&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;名称&lt;/td&gt;
&lt;td&gt;树中显示的此取样器的描述性名称。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Old entry name&lt;/td&gt;
&lt;td&gt;相对于线程绑定操作中给定的DN，要重命名或移动的对象的当前可分辨名称。&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;New distinguished name&lt;/td&gt;
&lt;td&gt;相对于线程绑定操作中给定的DN，要重命名或移动的对象的新的可分辨名称。&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;添加测试&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;这是LDAP“&lt;code&gt;add&lt;/code&gt;”操作。它可用于将任何类型的对象添加到LDAP服务器。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参数&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th align="left"&gt;是否必须&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;名称&lt;/td&gt;
&lt;td&gt;树中显示的此取样器的描述性名称。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;DN入口&lt;/td&gt;
&lt;td&gt;相对于线程绑定操作中的给定DN，要添加的对象的可分辨名称。&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;添加测试&lt;/td&gt;
&lt;td&gt;要用于对象的属性及其值的列表。如果需要添加多值属性，则需要将相同的属性及其各自的值多次添加到列表中。&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;删除测试&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;这是LDAP“&lt;code&gt;delete&lt;/code&gt;”操作，它可用于从LDAP树中删除对象。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参数&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th align="left"&gt;是否必须&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;名称&lt;/td&gt;
&lt;td&gt;树中显示的此取样器的描述性名称。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;删除&lt;/td&gt;
&lt;td&gt;相对于线程绑定操作中的给定DN，要删除的对象的可分辨名称。&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;搜索测试&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;这是LDAP“&lt;code&gt;search&lt;/code&gt;”操作，用于定义搜索。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参数&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th align="left"&gt;是否必须&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;名称&lt;/td&gt;
&lt;td&gt;树中显示的此取样器的描述性名称。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Search base&lt;/td&gt;
&lt;td&gt;相对于线程绑定操作中的给定DN，您希望搜索查找的子树的可分辨名称。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Search Filter&lt;/td&gt;
&lt;td&gt;搜索过滤必须在LDAP语法中指定。&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Scope&lt;/td&gt;
&lt;td&gt;使用&lt;code&gt;0&lt;/code&gt;代表baseobject，&lt;code&gt;1&lt;/code&gt;为onelevel和&lt;code&gt;2&lt;/code&gt;为subtree的搜索。（默认=&lt;code&gt;0&lt;/code&gt;）&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;大小限制&lt;/td&gt;
&lt;td&gt;指定要从服务器返回的最大结果数。（默认值=&lt;code&gt;0&lt;/code&gt;，表示没有限制）当取样器达到最大结果数时，它将失败并返回错误代码&lt;code&gt;4&lt;/code&gt;&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Time Limit&lt;/td&gt;
&lt;td&gt;指定服务器在搜索上花费的最大（cpu）时间（以毫秒为单位）。注意这不是响应时间。（默认为&lt;code&gt;0&lt;/code&gt;，表示没有限制）&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;属性&lt;/td&gt;
&lt;td&gt;指定要返回的属性，以分号分隔。空值将返回所有属性&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Return object&lt;/td&gt;
&lt;td&gt;返回（&lt;code&gt;true&lt;/code&gt;）或不返回（&lt;code&gt;false&lt;/code&gt;）对象。默认=&lt;code&gt;false&lt;/code&gt;&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;废弃的别名&lt;/td&gt;
&lt;td&gt;如果为&lt;code&gt;true&lt;/code&gt;，它将废弃别名，如果为&lt;code&gt;false&lt;/code&gt;，则不会废弃（默认值=&lt;code&gt;false&lt;/code&gt;）&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Parse the search results?&lt;/td&gt;
&lt;td&gt;如果为&lt;code&gt;true&lt;/code&gt;，则搜索结果将添加到响应数据中。如果为&lt;code&gt;false&lt;/code&gt;，则将标记 - 无论结果是否找到 - 添加到响应数据中。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;修改测试&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;这是LDAP“&lt;code&gt;modify&lt;/code&gt;”操作。它可以用于修改对象。也可用于添加，删除或替换属性的值。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参数&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th align="left"&gt;是否必须&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;名称&lt;/td&gt;
&lt;td&gt;树中显示的此取样器的描述性名称。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;DN入口&lt;/td&gt;
&lt;td&gt;相对于线程绑定操作中的给定DN，要修改的对象的可分辨名称&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;修改测试&lt;/td&gt;
&lt;td&gt;属性-值-opCode三角。opCode可以是任何有效的LDAP operationCode（&lt;code&gt;add&lt;/code&gt;，&lt;code&gt;delete/remove&lt;/code&gt;或&lt;code&gt;replace&lt;/code&gt;）。如果未指定&lt;code&gt;delete&lt;/code&gt;操作的值，则将删除给定属性的所有值。如果指定了&lt;code&gt;delete&lt;/code&gt;操作的值，则仅删除给定值。如果该值不存在，取样器返回失败。&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;比较&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;这是LDAP“&lt;code&gt;compare&lt;/code&gt;”操作。它可用于将给定属性的值与某个已知值进行比较。实际上，这主要用于检查某个人是否是某个组的成员。在这种情况下，您可以将用户的DN作为给定值与&lt;code&gt;groupOfNames&lt;/code&gt;对象的“&lt;code&gt;member&lt;/code&gt;”属性中的值进行比较。如果比较操作失败，则测试失败并返回错误代码&lt;code&gt;49&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参数&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th align="left"&gt;是否必须&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;名称&lt;/td&gt;
&lt;td&gt;树中显示的此取样器的描述性名称。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;DN入口&lt;/td&gt;
&lt;td&gt;相对于线程绑定操作中的给定DN，要比较属性的对象的当前可分辨名称。&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;比较过滤器&lt;/td&gt;
&lt;td&gt;格式为"&lt;code&gt;attribute=value&lt;/code&gt;"&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;另请参阅：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://jmeter.apache.org/usermanual/build-ldapext-test-plan.html"&gt;构建LDAP测试计划&lt;/a&gt; &lt;/li&gt;
&lt;li&gt;&lt;a href="http://jmeter.apache.org/usermanual/component_reference.html#LDAP_Extended_Request_Defaults"&gt;LDAP扩展请求默认值&lt;/a&gt; &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href="#toc"&gt;【返回目录】&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="access-log-sampler"&gt;Access Log Sampler&lt;/h3&gt;
&lt;p&gt;AccessLogSampler旨在读取访问日志并生成http请求。对于那些不熟悉访问日志的人来说，它是Web服务器记录它接受的每个请求的日志。这意味着所有图像，CSS文件，JavaScript文件，html文件，......&lt;/p&gt;
&lt;p&gt;Tomcat的访问日志使用通用格式。这意味着使用通用日志格式的任何Web服务器都可以使用AccessLogSampler。使用通用日志格式的服务器包括：Tomcat，Resin，Weblogic和SunOne。常见的日志格式如下所示：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;127.0.0.1 - - [21/Oct/2003:05:37:21 -0500] &amp;quot;GET /index.jsp?%2Findex.jsp= HTTP/1.1&amp;quot; 200 8343
&lt;/pre&gt;&lt;/div&gt;


&lt;blockquote&gt;
&lt;p&gt;解析器的当前实现仅查看包含HTTP协议方法的引号内的文本（&lt;code&gt;GET&lt;/code&gt;，&lt;code&gt;PUT&lt;/code&gt;，&lt;code&gt;POST&lt;/code&gt;，&lt;code&gt;DELETE&lt;/code&gt;，...）。其他所有都被剥离并忽略。例如，解析器完全忽略响应代码。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;对于将来，过滤出响应代码不是&lt;code&gt;200&lt;/code&gt;的条目可能会更好。扩展取样器应该相当简单。您必须实现两个接口：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;org.apache.jmeter.protocol.http.util.accesslog.LogParser&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;org.apache.jmeter.protocol.http.util.accesslog.Generator&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;AccessLogSampler的当前实现使用生成器来创建新的HTTP取样器。服务器名称，端口和获取图像由AccessLogSampler设置。然后，使用整数&lt;code&gt;1&lt;/code&gt;调用解析器，告诉它解析1个条目。之后，调用&lt;code&gt;HTTPSampler.sample()&lt;/code&gt;来发出请求。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;samp = (HTTPSampler) GENERATOR.generateRequest();
samp.setDomain(this.getDomain());
samp.setPort(this.getPort());
samp.setImageParser(this.isImageParser());
PARSER.parse(1);
res = samp.sample();
res.setSampleLabel(samp.toString());
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;LogParser&lt;/code&gt;中所需的方法是： &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;setGenerator(Generator)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;parse(int)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;实现&lt;code&gt;Generator&lt;/code&gt;接口的类应该为所有方法提供具体的实现。有关如何实现任一接口的示例，请参阅  &lt;code&gt;StandardGenerator&lt;/code&gt;和&lt;code&gt;TCLogParser&lt;/code&gt;。 &lt;/p&gt;
&lt;p&gt;&lt;img alt="Screenshot for Control-Panel of Access Log Sampler" src="http://jmeter.apache.org/images/screenshots/accesslogsampler.png"&gt;&lt;br&gt;
&lt;em&gt;Access Log Sampler控制面板的截图&lt;/em&gt;&lt;/p&gt;
&lt;p align="center"&gt;（Beta代码）&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;参数&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th align="left"&gt;是否必须&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;名称&lt;/td&gt;
&lt;td&gt;树中显示的此取样器的描述性名称。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Server&lt;/td&gt;
&lt;td&gt;Web服务器的域名或IP地址。&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Protocol&lt;/td&gt;
&lt;td&gt;方案&lt;/td&gt;
&lt;td align="left"&gt;否（默认为http）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Port&lt;/td&gt;
&lt;td&gt;Web服务器监听的端口。&lt;/td&gt;
&lt;td align="left"&gt;否（默认为80）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Log parser class&lt;/td&gt;
&lt;td&gt;负责解析日志的日志解析器类。&lt;/td&gt;
&lt;td align="left"&gt;是（默认提供）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Filter&lt;/td&gt;
&lt;td&gt;用于过滤掉某些行的过滤器类。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Location of log file&lt;/td&gt;
&lt;td&gt;访问日志文件的位置。&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;code&gt;TCLogParser&lt;/code&gt;为每个线程独立处理访问日志。&lt;code&gt;SharedTCLogParser&lt;/code&gt;和&lt;code&gt;OrderPreservingLogParser&lt;/code&gt;共享访问文件，即每个线程获取日志中的下一个条目。 &lt;/p&gt;
&lt;p&gt;&lt;code&gt;SessionFilter&lt;/code&gt;旨在跨线程处理cookies。它不会过滤掉任何条目，但会修改cookie管理器，以便一次一个线程处理给定IP的cookies。如果两个线程尝试处理来自相同客户端IP地址的样本，则将强制一个线程等待直到另一个线程完成。 &lt;/p&gt;
&lt;p&gt;&lt;code&gt;LogFilter&lt;/code&gt;旨在允许通过文件名和正则表达式来过滤访问日志条目，以及允许替换文件扩展名。但是，目前无法通过GUI进行配置，因此无法真正使用它。 &lt;/p&gt;
&lt;p&gt;&lt;a href="#toc"&gt;【返回目录】&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="beanshell"&gt;BeanShell取样器&lt;/h3&gt;
&lt;p&gt;此取样器允许您使用BeanShell脚本语言编写取样器。 &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;有关使用BeanShell的完整详细信息，请参阅&lt;a href="http://www.beanshell.org/"&gt;BeanShell网站&lt;/a&gt;。&lt;/strong&gt;  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;强烈建议迁移到&lt;a href="http://jmeter.apache.org/usermanual/component_reference.html#JSR223_Sampler"&gt;JSR223 Sampler&lt;/a&gt;+Groovy以提高性能，支持新的Java功能且减少BeanShell库的维护。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;测试元件支持&lt;code&gt;ThreadListener&lt;/code&gt;和&lt;code&gt;TestListener&lt;/code&gt;接口方法。这些必须在初始化文件中定义。有关定义的示例，请参阅文件&lt;code&gt;BeanShellListeners.bshrc&lt;/code&gt;。 &lt;/p&gt;
&lt;p&gt;BeanShell取样器还支持&lt;code&gt;Interruptible&lt;/code&gt;接口。&lt;code&gt;interrupt()&lt;/code&gt;方法可以在脚本或初始化文件中定义。 &lt;/p&gt;
&lt;p&gt;&lt;img alt="Screenshot for Control-Panel of BeanShell Sampler" src="http://jmeter.apache.org/images/screenshots/beanshellsampler.png"&gt;&lt;br&gt;
&lt;em&gt;BeanShell 取样器控制面板的截图&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参数&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th align="left"&gt;是否必须&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;名称&lt;/td&gt;
&lt;td&gt;树中显示的此取样器的描述性名称。该名称存储在脚本变量&lt;code&gt;Label&lt;/code&gt;中&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;每次调用前重置bsh.Interpreter&lt;/td&gt;
&lt;td&gt;如果选中此选项，则将为每个样本重新创建解释器。对于某些长时间运行的脚本，这可能是必需的。有关详细信息请参阅&lt;a href="http://jmeter.apache.org/usermanual/best-practices#bsh_scripting"&gt;最佳实践 -  BeanShell脚本&lt;/a&gt;。&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;参数&lt;/td&gt;
&lt;td&gt;要传递给BeanShell脚本的参数。这适用于脚本文件；对于GUI中定义的脚本，您可以在脚本本身中使用所需的任何变量和函数引用。参数存储在以下变量中：&lt;br /&gt;&lt;code&gt;Parameters&lt;/code&gt;：包含参数的字符串，作为单个变量&lt;br /&gt;&lt;code&gt;bsh.args&lt;/code&gt;：包含参数的字符串数组，在空格处分割&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;脚本文件&lt;/td&gt;
&lt;td&gt;包含要运行的BeanShell脚本的文件。文件名存储在脚本变量&lt;code&gt;FileName&lt;/code&gt;中&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;脚本&lt;/td&gt;
&lt;td&gt;要运行的BeanShell脚本。返回值（如果不为&lt;code&gt;null&lt;/code&gt;）存储为取样器结果。&lt;/td&gt;
&lt;td align="left"&gt;是（除非提供脚本文件）&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;blockquote&gt;
&lt;p&gt;注意每个取样器实例都有自己的BeanShell解释器，而取样器只能被单个线程调用&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果定义了“&lt;code&gt;beanshell.sampler.init&lt;/code&gt;”属性，则将其作为源文件的名称传递给解析器。这可以用于定义常用方法和变量。bin目录中有一个示例init文件：&lt;code&gt;BeanShellSampler.bshrc&lt;/code&gt;。 &lt;/p&gt;
&lt;p&gt;如果提供了脚本文件，将使用该脚本文件，否则将使用脚本。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在将脚本字段传递给解释器之前，JMeter处理函数和变量的引用，因此引用只会被解析一次。脚本文件中的变量和函数引用将逐字传递给解释器，这可能会导致语法错误。为了使用运行时变量，请使用适当的props方法，例如&lt;code&gt;props.get("START.HMS");&lt;/code&gt; &lt;code&gt;props.put("PROP1","1234");&lt;/code&gt;&lt;br&gt;
 BeanShell目前不支持Java 5语法，例如泛型和增强的for循环。 &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在调用脚本之前，BeanShell解释器会设置一些变量：&lt;/p&gt;
&lt;p&gt;参数字段的内容放入变量“&lt;code&gt;Parameters&lt;/code&gt;”中。该字符串也使用单个空格作为分隔符拆分为单独的标记，并将结果列表存储在字符串数组&lt;code&gt;bsh.args&lt;/code&gt;中。&lt;/p&gt;
&lt;p&gt;可设置的BeanShell变量的完整列表如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;log&lt;/code&gt; - &lt;a href="https://www.slf4j.org/api/org/slf4j/Logger.html"&gt;日志记录器&lt;/a&gt; &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Label&lt;/code&gt; - 取样器标签&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;FileName&lt;/code&gt; - 文件名（如果有）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Parameters&lt;/code&gt; - 参数字段中的文本&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;bsh.args&lt;/code&gt; - 参数，按上面描述的拆分&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;SampleResult&lt;/code&gt; - 指向当前&lt;a href="http://jmeter.apache.org/api/org/apache/jmeter/samplers/SampleResult.html"&gt;SampleResult&lt;/a&gt;的指针 &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;ResponseCode&lt;/code&gt; - 默认为&lt;code&gt;200&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;ResponseMessage&lt;/code&gt; - 默认为“&lt;code&gt;OK&lt;/code&gt;”&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;IsSuccess&lt;/code&gt; - 默认为&lt;code&gt;true&lt;/code&gt; &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;ctx&lt;/code&gt; - &lt;a href="http://jmeter.apache.org/api/org/apache/jmeter/threads/JMeterContext.html"&gt;JMeter上下文&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;vars&lt;/code&gt; - &lt;a href="http://jmeter.apache.org/api/org/apache/jmeter/threads/JMeterVariables.html"&gt;JMeter变量&lt;/a&gt; - 例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;vars.get(&amp;quot;VAR1&amp;quot;);
vars.put(&amp;quot;VAR2&amp;quot;,&amp;quot;value&amp;quot;);
vars.remove(&amp;quot;VAR3&amp;quot;);
vars.putObject(&amp;quot;OBJ1&amp;quot;,new Object());
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;props&lt;/code&gt; - JMeter属性（&lt;code&gt;java.util.Properties&lt;/code&gt;类） - 例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;props.get(&amp;quot;START.HMS&amp;quot;);
props.put(&amp;quot;PROP1&amp;quot;,&amp;quot;1234&amp;quot;);
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;脚本完成后，控制权返回给取样器，并将以下脚本变量的内容复制到&lt;a href="http://jmeter.apache.org/api/org/apache/jmeter/samplers/SampleResult.html"&gt;SampleResult&lt;/a&gt;中的相应变量中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ResponseCode&lt;/code&gt; - 例如&lt;code&gt;200&lt;/code&gt; &lt;/li&gt;
&lt;li&gt;&lt;code&gt;ResponseMessage&lt;/code&gt; - 例如“&lt;code&gt;OK&lt;/code&gt;”&lt;/li&gt;
&lt;li&gt;&lt;code&gt;IsSuccess&lt;/code&gt; - &lt;code&gt;true&lt;/code&gt;或&lt;code&gt;false&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;SampleResult和ResponseData根据脚本的返回值来设置。如果脚本返回&lt;code&gt;null&lt;/code&gt;，则可以使用方法&lt;code&gt;SampleResult.setResponseData(data)&lt;/code&gt;直接设置响应，其中data是String或byte数组。data类型默认为“&lt;code&gt;text&lt;/code&gt;”，但可以通过&lt;code&gt;SampleResult.setDataType(SampleResult.BINARY)&lt;/code&gt;方法设置为二进制值 。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;SampleResult&lt;/code&gt;变量给予脚本对&lt;code&gt;SampleResult&lt;/code&gt;内所有字段和方法完全的访问权限。例如，脚本可以访问&lt;code&gt;setStopThread(boolean)&lt;/code&gt;和&lt;code&gt;setStopTest(boolean)&lt;/code&gt;方法。这是一个简单的（不是很有用）示例脚本：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;if (bsh.args[0].equalsIgnoreCase(&amp;quot;StopThread&amp;quot;)) {
    log.info(&amp;quot;Stop Thread detected!&amp;quot;);
    SampleResult.setStopThread(true);
}
return &amp;quot;Data from sample with Label &amp;quot;+Label;
//or
SampleResult.setResponseData(&amp;quot;My data&amp;quot;);
return null;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;另一个例子：
确保在&lt;code&gt;jmeter.properties&lt;/code&gt;中定义属性&lt;code&gt;beanshell.sampler.init=BeanShellSampler.bshrc&lt;/code&gt;。以下脚本将显示&lt;code&gt;ResponseData&lt;/code&gt;字段中所有变量的值： &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;return getVariables();
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;有关各种类可用方法的详细信息（&lt;a href="http://jmeter.apache.org/api/org/apache/jmeter/threads/JMeterVariables.html"&gt;JMeterVariables&lt;/a&gt;，&lt;a href="http://jmeter.apache.org/api/org/apache/jmeter/samplers/SampleResult.html"&gt;SampleResult&lt;/a&gt;等），请查阅Javadoc或源代码。但要注意，滥用任何方法都可能导致难以发现的细微错误。 &lt;/p&gt;
&lt;p&gt;&lt;a href="#toc"&gt;【返回目录】&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="jrs223"&gt;JRS223取样器&lt;/h3&gt;
&lt;p&gt;JSR223取样器允许使用JSR223脚本代码来执行一个样本或创建/更新变量所需的一些计算。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如果您不想在运行此取样器时生成&lt;a href="http://jmeter.apache.org/api/org/apache/jmeter/samplers/SampleResult.html"&gt;SampleResult&lt;/a&gt;，请调用以下方法：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;   SampleResult.setIgnore();
&lt;/pre&gt;&lt;/div&gt;


&lt;/blockquote&gt;
&lt;p&gt;JSR223测试元件具有可以显著提高性能的功能（编译）。要利用这个特性，请：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;使用脚本文件而不是内联它们。如果ScriptEngine上有此功能，JMeter将编译并缓存它们。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;或者使用脚本文本并检查&lt;code&gt;Cache compiled script if available&lt;/code&gt;属性。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;使用此功能时，请确保您的脚本代码不直接在代码中使用JMeter变量而是使用脚本参数，因为缓存只会缓存第一次替换。&lt;/p&gt;
&lt;p&gt;要从缓存和编译中受益，用于脚本编写的语言引擎必须实现JSR223&lt;a href="https://docs.oracle.com/javase/8/docs/api/javax/script/Compilable.html"&gt;Compilable&lt;/a&gt;接口（Groovy就是其中之一，java，beanshell和javascript都不是）&lt;/p&gt;
&lt;p&gt;当使用Groovy作为脚本语言并且不检查&lt;code&gt;Cache compiled script if available&lt;/code&gt;时（建议使用缓存），由于版本2.4.6中的Groovy内存泄漏问题，您应该设置JVM属性&lt;code&gt;-Dgroovy.use.classvalue=true&lt;/code&gt;，请参阅：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://issues.apache.org/jira/browse/GROOVY-7683"&gt;GROOVY-7683&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://issues.apache.org/jira/browse/GROOVY-7591"&gt;GROOVY-7591&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://bugs.openjdk.java.net/browse/JDK-8136353"&gt;JDK-8136353&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;缓存大小由以下JMeter属性（&lt;code&gt;jmeter.properties&lt;/code&gt;）控制：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;jsr223.compiled_scripts_cache_size=100
&lt;/pre&gt;&lt;/div&gt;


&lt;blockquote&gt;
&lt;p&gt;与&lt;a href="http://jmeter.apache.org/usermanual/component_reference.html#BeanShell_Sampler"&gt;BeanShell取样器&lt;/a&gt;不同，解释器不会在调用之间保存。&lt;/p&gt;
&lt;p&gt;如果脚本引擎支持此功能，使用脚本文件或脚本文本+检查&lt;code&gt;Cache compiled script if available&lt;/code&gt;的JSR223测试元件将执行编译，这可以实现性能的显著提升。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img alt="Screenshot for Control-Panel of JSR223 Sampler" src="http://jmeter.apache.org/images/screenshots/jsr223-sampler.png"&gt;&lt;br&gt;
&lt;em&gt;JSR223取样器控制面板的截图&lt;/em&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在将脚本字段传递给解释器之前，JMeter处理函数和变量的引用，因此引用只会被解析一次。脚本文件中的变量和函数引用将逐字传递给解释器，这可能会导致语法错误。为了使用运行时变量，请使用适当的props方法，例如&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt; props.get(&amp;quot;START.HMS&amp;quot;);
 props.put(&amp;quot;PROP1&amp;quot;,&amp;quot;1234&amp;quot;);
&lt;/pre&gt;&lt;/div&gt;


&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;参数&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th align="left"&gt;是否必须&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;名称&lt;/td&gt;
&lt;td&gt;树中显示的此取样器的描述性名称。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;脚本语言&lt;/td&gt;
&lt;td&gt;要使用的JSR223脚本语言的名称。&lt;blockquote&gt;支持的语言比下拉列表中显示的要多。如果在JMeter lib目录中安装了相应的jar，则可使用相应的语言。&lt;/blockquote&gt;&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;脚本文件&lt;/td&gt;
&lt;td&gt;要用作JSR223脚本的文件的名称，如果使用文件的相对路径，则它将使用相对于系统属性“&lt;code&gt;user.dir&lt;/code&gt;” 所引用的目录&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;参数&lt;/td&gt;
&lt;td&gt;要传递给脚本文件或脚本的参数列表。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;缓存编译脚本（如果可用）&lt;/td&gt;
&lt;td&gt;如果选中（建议）并且使用的语言支持&lt;a href="https://docs.oracle.com/javase/8/docs/api/javax/script/Compilable.html"&gt;Compilable&lt;/a&gt;接口（Groovy就是其中之一，java，beanshell和javascript都不是），JMeter将编译并缓存脚本，且使用它的MD5哈希值作为唯一缓存密钥&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;脚本&lt;/td&gt;
&lt;td&gt;要传递给JSR223语言的脚本&lt;/td&gt;
&lt;td align="left"&gt;是（除非提供脚本文件）&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;如果提供了脚本文件，则使用该脚本文件，否则使用脚本。&lt;/p&gt;
&lt;p&gt;在调用脚本之前，会设置一些变量。请注意，这些是JSR223变量 - 即它们可以直接在脚本中使用。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;log&lt;/code&gt; - &lt;a href="https://www.slf4j.org/api/org/slf4j/Logger.html"&gt;日志记录器&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Label&lt;/code&gt; - 取样器标签&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;FileName&lt;/code&gt; - 文件名（如果有）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Parameters&lt;/code&gt; - 参数字段中的文本&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;args&lt;/code&gt; - 参数，按照上面描述的拆分&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;SampleResult&lt;/code&gt; - 指向当前&lt;a href="http://jmeter.apache.org/api/org/apache/jmeter/samplers/SampleResult.html"&gt;SampleResult&lt;/a&gt;的指针&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;sampler&lt;/code&gt; - （&lt;a href="http://jmeter.apache.org/api/org/apache/jmeter/samplers/Sampler.html"&gt;Sampler&lt;/a&gt;） - 指向当前取样器的指针&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;ctx&lt;/code&gt; - &lt;a href="http://jmeter.apache.org/api/org/apache/jmeter/threads/JMeterContext.html"&gt;JMeter上下文&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;vars&lt;/code&gt; - &lt;a href="http://jmeter.apache.org/api/org/apache/jmeter/threads/JMeterVariables.html"&gt;JMeter变量&lt;/a&gt; - 例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;vars.get(&amp;quot;VAR1&amp;quot;);
vars.put(&amp;quot;VAR2&amp;quot;,&amp;quot;value&amp;quot;);
vars.remove(&amp;quot;VAR3&amp;quot;);
vars.putObject(&amp;quot;OBJ1&amp;quot;,new Object());
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;props&lt;/code&gt; - JMeter属性（&lt;code&gt;java.util.Properties&lt;/code&gt;类） - 例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;props.get(&amp;quot;START.HMS&amp;quot;);
props.put(&amp;quot;PROP1&amp;quot;,&amp;quot;1234&amp;quot;);
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;OUT&lt;/code&gt; - System.out - 例如&lt;code&gt;OUT.println("message")&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href="http://jmeter.apache.org/api/org/apache/jmeter/samplers/SampleResult.html"&gt;SampleResult&lt;/a&gt;和ResponseData根据脚本的返回值来设置。如果脚本返回&lt;code&gt;null&lt;/code&gt;，则可以使用&lt;code&gt;SampleResult.setResponseData(data)&lt;/code&gt;方法直接设置响应 ，其中data是String或byte数组。data类型默认为“&lt;code&gt;text&lt;/code&gt;”，但可以通过&lt;code&gt;SampleResult.setDataType(SampleResult.BINARY)&lt;/code&gt;方法设置为二进制值 。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;SampleResult&lt;/code&gt;变量给予脚本对&lt;code&gt;SampleResult&lt;/code&gt;内所有字段和方法完全的访问权限。例如，脚本可以访问&lt;code&gt;setStopThread(boolean)&lt;/code&gt;和&lt;code&gt;setStopTest(boolean)&lt;/code&gt;方法。&lt;/p&gt;
&lt;p&gt;与BeanShell取样器不同，JSR223取样器不通过脚本变量设置&lt;code&gt;ResponseCode&lt;/code&gt;，&lt;code&gt;ResponseMessage&lt;/code&gt;和样本status。目前改变这些的唯一方法是通过&lt;a href="http://jmeter.apache.org/api/org/apache/jmeter/samplers/SampleResult.html"&gt;SampleResult&lt;/a&gt;方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;SampleResult.setSuccessful(true/false)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SampleResult.setResponseCode("code")&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SampleResult.setResponseMessage("message")&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href="#toc"&gt;【返回目录】&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="tcp"&gt;TCP取样器&lt;/h3&gt;
&lt;p&gt;TCP取样器打开与指定服务器的TCP/IP连接。然后发送文本，并等待响应。&lt;/p&gt;
&lt;p&gt;如果选中“&lt;code&gt;Re-use connection&lt;/code&gt;”，则在同一线程中的取样器之间共享连接，前提是使用完全相同的主机名称和端口。不同的主机/端口组合将使用不同的连接，不同的线程也是如此。如果同时选中“ &lt;code&gt;Re-use connection&lt;/code&gt; ”和“&lt;code&gt;Close connection&lt;/code&gt;”，则运行取样器后将关闭套接字。在下一个取样器上，将创建另一个套接字。您可能希望在每个线程循环结束时关闭套接字。&lt;/p&gt;
&lt;p&gt;如果检测到错误 - 或未选中“&lt;code&gt;Re-use connection&lt;/code&gt;” - 则关闭套接字。下一个样本将打开另一个套接字。&lt;/p&gt;
&lt;p&gt;以下属性可用于控制其操作：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;tcp.status.prefix&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;状态码之前的文本&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;tcp.status.suffix&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;状态码之后的文本&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;tcp.status.properties&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;用于将状态代码转换为消息的属性文件的名称&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;tcp.handler&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;TCP Handler类的名称（默认&lt;code&gt;TCPClientImpl&lt;/code&gt;） - 仅在GUI上未指定时使用&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;处理连接的类由GUI定义，如果未定义，取&lt;code&gt;tcp.handler&lt;/code&gt;属性的值。如果还是取不到，则在&lt;/p&gt;
&lt;p&gt;&lt;code&gt;org.apache.jmeter.protocol.tcp.sampler&lt;/code&gt;包中搜索该类。&lt;/p&gt;
&lt;p&gt;用户可以提供自己的实现。该类必须扩展&lt;code&gt;org.apache.jmeter.protocol.tcp.sampler.TCPClient&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;目前提供以下实现。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;TCPClientImpl&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;BinaryTCPClientImpl&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;LengthPrefixedBinaryTCPClientImpl&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;实现的行为如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;TCPClientImpl&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;这种实现是相当基础的。读取响应时，如果配置了&lt;code&gt;tcp.eolByte&lt;/code&gt;属性，则读取直到行字节结束，否则直到输入流结束。您可以通过设置&lt;code&gt;tcp.charset&lt;/code&gt;来控制字符集编码，默认为平台默认编码。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;BinaryTCPClientImpl&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;此实现将GUI输入（必须是十六进制编码的字符串）转换为二进制，并在读取响应时执行相反的操作。读取响应时，如果配置了&lt;code&gt;tcp.BinaryTCPClient.eomByte&lt;/code&gt;属性，则读取直到消息字节结束，否则直到输入流结束。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;LengthPrefixedBinaryTCPClientImpl&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;此实现通过在二进制消息数据前加二进制长度字节来扩展BinaryTCPClientImpl。长度前缀默认为2个字节。可以通过设置属性&lt;code&gt;tcp.binarylength.prefix.length&lt;/code&gt;来变更。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;超时处理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果设置了超时，则读取将在超时后终止。因此，如果您使用的是&lt;code&gt;eolByte/eomByte&lt;/code&gt;，请确保超时设置的足够长，否则将过早终止读取。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;响应处理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果定义了&lt;code&gt;tcp.status.prefix&lt;/code&gt;，则会在响应消息中从此开始搜索文本，直到后缀结束。如果找到任何此类文本，则用于设置响应代码。然后从属性文件（如果提供）中获取响应消息。&lt;/p&gt;
&lt;blockquote&gt;
&lt;h4 id="prefixsuffix"&gt;使用前缀（prefix）和后缀（suffix）&lt;/h4&gt;
&lt;p&gt;例如，如果prefix = “ &lt;code&gt;[&lt;/code&gt;“和suffix =“&lt;code&gt;]&lt;/code&gt;”，则下面的响应：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;   [J28] XI123,23,GBP,CR
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;将获取到响应代码为&lt;code&gt;J28&lt;/code&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;“&lt;code&gt;400&lt;/code&gt;”-“&lt;code&gt;499&lt;/code&gt;”和“&lt;code&gt;500&lt;/code&gt;”-“&lt;code&gt;599&lt;/code&gt;” 范围内的响应代码目前被视为失败; 其他的视为成功。【这需要进行配置！】&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;提供的TCP实现不使用登录名/密码。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在测试运行结束时断开套接字。&lt;/p&gt;
&lt;p&gt;&lt;img alt="Screenshot for Control-Panel of TCP Sampler" src="http://jmeter.apache.org/images/screenshots/tcpsampler.png"&gt;&lt;br&gt;
&lt;em&gt;TCP取样器控制面板的截图&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参数&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th align="left"&gt;是否必须&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;名称&lt;/td&gt;
&lt;td&gt;树中显示的此取样器元件的描述性名称。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;TCPClient classname&lt;/td&gt;
&lt;td&gt;TCPClient类的名称。默认取属性&lt;code&gt;tcp.handler&lt;/code&gt;，若取不到则取&lt;code&gt;TCPClientImpl&lt;/code&gt;。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;服务器名称或IP&lt;/td&gt;
&lt;td&gt;TCP服务器的名称或IP&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;端口号&lt;/td&gt;
&lt;td&gt;使用的端口&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Re-use connection&lt;/td&gt;
&lt;td&gt;如果选中，则连接保持打开状态。否则，数据读取完将关闭。&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;关闭连接&lt;/td&gt;
&lt;td&gt;如果选中，取样器执行完毕将关闭连接。&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;SO_LINGER&lt;/td&gt;
&lt;td&gt;创建套接字时通过启用/禁用&lt;code&gt;SO_LINGER&lt;/code&gt;指定延迟时间（以秒为单位）。如果将“&lt;code&gt;SO_LINGER&lt;/code&gt;”值设置为&lt;code&gt;0&lt;/code&gt;，可以防止大量套接字处于&lt;code&gt;TIME_WAIT&lt;/code&gt;状态。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;行尾（EOL）字节值&lt;/td&gt;
&lt;td&gt;行尾的字节值，将其设置为&lt;code&gt;-128&lt;/code&gt;到&lt;code&gt;+127&lt;/code&gt;范围之外的值以跳过&lt;code&gt;eol&lt;/code&gt;检查。您可以在&lt;code&gt;jmeter.properties&lt;/code&gt;文件中设置&lt;code&gt;eolByte&lt;/code&gt;属性也可以在此处设置。如果在TCP取样器配置和&lt;code&gt;jmeter.properties&lt;/code&gt;文件中同时设置此项，将使用TCP取样器配置中设置的值。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;连接超时&lt;/td&gt;
&lt;td&gt;连接超时时间（毫秒，&lt;code&gt;0&lt;/code&gt;为禁用）。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;响应超时&lt;/td&gt;
&lt;td&gt;响应超时时间（毫秒，&lt;code&gt;0&lt;/code&gt;为禁用）。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;设置无延迟&lt;/td&gt;
&lt;td&gt;请参阅&lt;code&gt;java.net.Socket.setTcpNoDelay()&lt;/code&gt;。如果选中，则将禁用Nagle算法，否则将使用Nagle算法。&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;要发送的文本&lt;/td&gt;
&lt;td&gt;要发送的文本&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;登录用户&lt;/td&gt;
&lt;td&gt;用户名 - 默认实现不使用&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;密码&lt;/td&gt;
&lt;td&gt;密码 - 默认实现不使用（注意，它在测试计划中是没有加密存储的）&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;a href="#toc"&gt;【返回目录】&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="jms"&gt;JMS发布&lt;/h3&gt;
&lt;p&gt;JMS发布将消息发布到给定目标（主题/队列）。对于那些不熟悉JMS的人来说，它是用于消息传递的J2EE规范。市场上有许多JMS服务器，还有一些是开源的。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;JMeter不包含任何JMS实现jar；必须从JMS提供方下载并放入lib目录&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img alt="Screenshot for Control-Panel of JMS Publisher" src="http://jmeter.apache.org/images/screenshots/jmspublisher.png"&gt;&lt;br&gt;
&lt;em&gt;JMS发布控制面板的截图&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参数&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th align="left"&gt;是否必须&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;名称&lt;/td&gt;
&lt;td&gt;树中显示的此元件的描述性名称。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;use JNDI properties file&lt;/td&gt;
&lt;td&gt;使用&lt;code&gt;jndi.properties&lt;/code&gt;。注意该文件必须在classpath中 - 例如，通过更新JMeter&lt;code&gt;user.classpath&lt;/code&gt;属性。如果未选中此项，JMeter将使用“&lt;code&gt;JNDI Initial Context Factory&lt;/code&gt;”和“&lt;code&gt;Provider URL&lt;/code&gt;”字段来创建连接。&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;JNDI Initial Context Factory&lt;/td&gt;
&lt;td&gt;上下文工厂的名称&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Provider URL&lt;/td&gt;
&lt;td&gt;JMS提供方的URL&lt;/td&gt;
&lt;td align="left"&gt;是，除非使用jndi.properties&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Destination&lt;/td&gt;
&lt;td&gt;消息目标（主题或队列名称）&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Setup&lt;/td&gt;
&lt;td&gt;目标设置类型。设置为&lt;code&gt;At startup&lt;/code&gt;时，目标名称是静态的（即在测试期间名称始终是一致的），设置为&lt;code&gt;Each sample&lt;/code&gt;时，目标名称是动态的，并在每个样本被评估（即，目标名称是可变的）&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Authentication&lt;/td&gt;
&lt;td&gt;JMS提供方的身份验证要求&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;User&lt;/td&gt;
&lt;td&gt;用户名&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Password&lt;/td&gt;
&lt;td&gt;密码（注意，它在测试计划中是没有加密存储的）&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Expiration&lt;/td&gt;
&lt;td&gt;消息过期时间（以毫秒为单位）。如果未指定过期时间，则默认值为&lt;code&gt;0&lt;/code&gt;（永不过期）。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Priority&lt;/td&gt;
&lt;td&gt;消息的优先级。从&lt;code&gt;0&lt;/code&gt;（最低）到&lt;code&gt;9&lt;/code&gt;（最高）共10个优先级。如果未指定优先级，则默认级别为&lt;code&gt;4&lt;/code&gt;。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Reconnect on error codes (regex)&lt;/td&gt;
&lt;td&gt;强制重新连接的JMSException错误代码的正则表达式。如果为空则不会重新连接&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Number of samples to aggregate&lt;/td&gt;
&lt;td&gt;要聚合的样本数&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Message source&lt;/td&gt;
&lt;td&gt;获取消息来源：  &lt;ul&gt;&lt;li&gt;&lt;code&gt;From File&lt;/code&gt;表示所有样本都将读取和重用所引用的文件。从JMeter 3.0开始，如果文件名更改会重新加载&lt;/li&gt;&lt;li&gt;&lt;code&gt;Random File from folder specified below&lt;/code&gt;表示将从下面指定的文件夹中选择随机文件，此文件夹必须包含扩展名为&lt;code&gt;.dat&lt;/code&gt;的文件用于字节消息，或扩展名为&lt;code&gt;.txt&lt;/code&gt;或&lt;code&gt;.obj&lt;/code&gt;的文件用于对象或文本消息&lt;/li&gt;&lt;li&gt;&lt;code&gt;Text area&lt;/code&gt;用于文本或对象消息的消息&lt;/li&gt;&lt;/ul&gt;&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Message type&lt;/td&gt;
&lt;td&gt;文本，字典，对象消息或字节消息&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Content encoding&lt;/td&gt;
&lt;td&gt;指定用于读取消息源文件的编码：&lt;ul&gt;&lt;li&gt;&lt;code&gt;RAW&lt;/code&gt;：文件没有变量支持，并使用默认系统字符集加载它。 &lt;/li&gt;&lt;li&gt;&lt;code&gt;DEFAULT&lt;/code&gt;：使用默认系统编码加载文件，但依赖于XML prolog的XML除外。如果文件包含变量，则将对其进行处理。&lt;/li&gt;&lt;li&gt; &lt;code&gt;Standard charsets&lt;/code&gt;：指定的编码（有效或无效）用于读取文件和处理变量&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Use non-persistent delivery mode?&lt;/td&gt;
&lt;td&gt;是否设置&lt;code&gt;DeliveryMode.NON_PERSISTENT&lt;/code&gt;（默认为&lt;code&gt;false&lt;/code&gt;）&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;JMS Properties&lt;/td&gt;
&lt;td&gt;JMS属性是特定于底层消息传递系统的属性。您可以设置值的名称，值和类（类型）。默认类型为&lt;code&gt;String&lt;/code&gt;。例如：对于WebSphere 5.1 Web服务，您需要设置JMS Property targetService来通过JMS测试Web服务。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;对于MapMessage类型，JMeter将源文件读取为文本行。每行必须有3个字段，用逗号分隔。这些字段是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;条目名称&lt;/li&gt;
&lt;li&gt;对象类名，例如“&lt;code&gt;String&lt;/code&gt;”（如果未指定，则假定为&lt;code&gt;java.lang&lt;/code&gt;包）&lt;/li&gt;
&lt;li&gt;对象字符串值&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;valueOf(String)&lt;/code&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;name,String,Example
size,Integer,1234
&lt;/pre&gt;&lt;/div&gt;


&lt;blockquote&gt;
&lt;p&gt;对象消息的实现和工作方式如下： &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将包含对象及其依赖项的JAR放在&lt;code&gt;jmeter_home/lib/&lt;/code&gt;文件夹中&lt;/li&gt;
&lt;li&gt;使用XStream将对象序列化为XML&lt;/li&gt;
&lt;li&gt;将结果放在以&lt;code&gt;.txt&lt;/code&gt;或&lt;code&gt;.obj&lt;/code&gt;为后缀的文件中，或将XML内容直接放在文本区域中&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;请注意，如果消息位于文件中，则在使用文本区域时将不会替换属性。 &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;下表显示了在配置JMS时可能有用的一些值：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Apache &lt;a href="http://activemq.apache.org/"&gt;ActiveMQ&lt;/a&gt;&lt;/th&gt;
&lt;th&gt;值&lt;/th&gt;
&lt;th&gt;备注&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;上下文工厂&lt;/td&gt;
&lt;td&gt;org.apache.activemq.jndi.ActiveMQInitialContextFactory&lt;/td&gt;
&lt;td&gt;.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;提供者URL&lt;/td&gt;
&lt;td&gt;vm://localhost&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;提供者URL&lt;/td&gt;
&lt;td&gt;vm:(broker:(vm://localhost)?persistent=false)&lt;/td&gt;
&lt;td&gt;禁用持久性&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;队列参考&lt;/td&gt;
&lt;td&gt;dynamicQueues/QUEUENAME&lt;/td&gt;
&lt;td&gt;&lt;a href="http://activemq.apache.org/jndi-support.html#JNDISupport-Dynamicallycreatingdestinations"&gt;动态定义&lt;/a&gt;QUEUENAME到JNDI&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;主题参考&lt;/td&gt;
&lt;td&gt;dynamicTopics/TOPICNAME&lt;/td&gt;
&lt;td&gt;&lt;a href="http://activemq.apache.org/jndi-support.html#JNDISupport-Dynamicallycreatingdestinations"&gt;动态定义&lt;/a&gt;TOPICNAME到JNDI&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;a href="#toc"&gt;【返回目录】&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="jms_1"&gt;JMS订阅&lt;/h3&gt;
&lt;p&gt;JMS订阅将订阅给定目标（主题或队列）中的消息。对于那些不熟悉JMS的人来说，它是用于消息传递的J2EE规范。市场上有许多JMS服务器，还有一些是开源的。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;JMeter不包含任何JMS实现jar；必须从JMS提供方下载并放入lib目录&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img alt="Screenshot for Control-Panel of JMS Subscriber" src="http://jmeter.apache.org/images/screenshots/jmssubscriber.png"&gt;&lt;br&gt;
&lt;em&gt;JMS订阅控制面板的截图&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参数&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th align="left"&gt;是否必须&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;名称&lt;/td&gt;
&lt;td&gt;树中显示的此元件的描述性名称。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;use JNDI properties file&lt;/td&gt;
&lt;td&gt;使用&lt;code&gt;jndi.properties&lt;/code&gt;。注意该文件必须在classpath中 - 例如，通过更新JMeter&lt;code&gt;user.classpath&lt;/code&gt;属性。如果未选中此项，JMeter将使用“&lt;code&gt;JNDI Initial Context Factory&lt;/code&gt;”和“&lt;code&gt;Provider URL&lt;/code&gt;”字段来创建连接。&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;JNDI Initial Context Factory&lt;/td&gt;
&lt;td&gt;上下文工厂的名称&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Provider URL&lt;/td&gt;
&lt;td&gt;JMS提供方的URL&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Destination&lt;/td&gt;
&lt;td&gt;消息目标（主题或队列名称）&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Durable Subscription ID&lt;/td&gt;
&lt;td&gt;用于持久订阅的ID。首次使用时，相应的队列若不存在，则会由JMS提供方自动生成。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Client ID&lt;/td&gt;
&lt;td&gt;持久订阅时使用的客户端ID。当你有多个线程时，一定要添加一个像&lt;code&gt;${__threadNum}&lt;/code&gt;这样的变量。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;JMS Selector&lt;/td&gt;
&lt;td&gt;由JMS规范定义的消息选择器，仅提取与选择器条件相关的消息。语法使用SQL 92的子部分。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Setup&lt;/td&gt;
&lt;td&gt;目标设置类型。设置为&lt;code&gt;At startup&lt;/code&gt;时，目标名称是静态的（即在测试期间名称始终是一致的），设置为&lt;code&gt;Each sample&lt;/code&gt;时，目标名称是动态的，并在每个样本被评估（即，目标名称是可变的）&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Authentication&lt;/td&gt;
&lt;td&gt;JMS提供方的身份验证要求&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;User&lt;/td&gt;
&lt;td&gt;用户名&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Password&lt;/td&gt;
&lt;td&gt;密码（注意，它在测试计划中是没有加密存储的）&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Number of samples to aggregate&lt;/td&gt;
&lt;td&gt;要聚合的样本数&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Save response&lt;/td&gt;
&lt;td&gt;取样器是否存储响应。如果否，则仅返回响应长度。&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Timeout&lt;/td&gt;
&lt;td&gt;指定的超时时间，以毫秒为单位。&lt;code&gt;0&lt;/code&gt;=none。这是整体聚合超时，而不是每个样本的超时。&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Client&lt;/td&gt;
&lt;td&gt;使用哪个客户端实现。它们都创建了可以读取消息的连接。但是，他们使用不同的策略，如下所述：&lt;ul&gt;&lt;li&gt;&lt;code&gt;MessageConsumer.receive()&lt;/code&gt;为每个请求的消息调用&lt;code&gt;receive()&lt;/code&gt;。保留样本之间的连接，但仅在取样器处于活动状态时才获取消息。这最适合队列订阅。&lt;/li&gt;&lt;li&gt;&lt;code&gt;MessageListener.onMessage()&lt;/code&gt;建立一个监听器，将所有传入的消息存储在队列中。监听器在取样器完成后仍保持活动状态。这最适合主题订阅。&lt;/li&gt;&lt;/ul&gt;&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Stop between samples?&lt;/td&gt;
&lt;td&gt;如果选中，则JMeter在每个样本的末尾调用&lt;code&gt;Connection.stop()&lt;/code&gt;（并在每个样本之前调用&lt;code&gt;start()&lt;/code&gt;）。在多个样本/线程与同一队列连接的某些情况下，这可能很有用。如果未选中，JMeter将在线程的开始调用&lt;code&gt;Connection.start()&lt;/code&gt;，并且在线程结束之后调用&lt;code&gt;stop()&lt;/code&gt;。&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Separator&lt;/td&gt;
&lt;td&gt;分隔符用于在有多个消息时分隔消息（与设置要聚合的样本数相关）。注意&lt;code&gt;\n&lt;/code&gt;，&lt;code&gt;\r&lt;/code&gt;，&lt;code&gt;\t&lt;/code&gt;都可以。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Reconnect on error codes (regex)&lt;/td&gt;
&lt;td&gt;强制重新连接的JMSException错误代码的正则表达式。如果为空则不会重新连接&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Pause between errors (ms)&lt;/td&gt;
&lt;td&gt;发生错误时，订阅服务器的暂停时间，以毫秒为单位&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;a href="#toc"&gt;【返回目录】&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="jms_2"&gt;JMS点到点&lt;/h3&gt;
&lt;p&gt;此取样器通过点到点连接（队列）发送并可选地接收JMS消息。与发布/订阅消息不同，它通常用于处理事务。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;request_only&lt;/code&gt;通常用于对JMS系统产生负载。
&lt;code&gt;request_reply&lt;/code&gt;这个模式将等待此服务发送的回复队列的响应，所以可以用于测试处理发送到请求队列消息的JMS服务的响应时间。&lt;br&gt;
&lt;code&gt;browse&lt;/code&gt;返回当前队列深度，即队列中的消息数。&lt;br&gt;
&lt;code&gt;read&lt;/code&gt;从队列中读取消息（如果有的话）。&lt;br&gt;
&lt;code&gt;clear&lt;/code&gt;清除队列，即从队列中删除所有消息。&lt;/p&gt;
&lt;p&gt;JMeter在创建队列连接时使用&lt;code&gt;java.naming.security.[principal|credentials]&lt;/code&gt;属性 - 如果存在。如果不需要此行为，请设置JMeter属性&lt;code&gt;JMSSampler.useSecurity.properties=false&lt;/code&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;JMeter不包含任何JMS实现jar；必须从JMS提供方下载并放入lib目录&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img alt="Screenshot for Control-Panel of JMS Point-to-Point" src="http://jmeter.apache.org/images/screenshots/jms/JMS_Point-to-Point.png"&gt;&lt;br&gt;
&lt;em&gt;JMS点到点控制面板的截图&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参数&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th align="left"&gt;是否必须&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;名称&lt;/td&gt;
&lt;td&gt;树中显示的此元件的描述性名称。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;QueueConnection Factory&lt;/td&gt;
&lt;td&gt;用于连接到消息传递系统的队列连接工厂的JNDI名称。&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;JNDI Name Request queue&lt;/td&gt;
&lt;td&gt;这是发送消息的队列的JNDI名称。&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;JNDI Name Reply queue&lt;/td&gt;
&lt;td&gt;接收队列的JNDI名称。如果此处提供了值并且通信模式为“&lt;code&gt;Request Response&lt;/code&gt;”， 则将监视此队列以获得发送请求的响应。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Number of samples to aggregate&lt;/td&gt;
&lt;td&gt;要聚合的样本数。仅适用于read通讯模式。&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;JMS Selector&lt;/td&gt;
&lt;td&gt;由JMS规范定义的消息选择器，仅提取与选择器条件相关的消息。语法使用SQL 92的子部分。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Communication style&lt;/td&gt;
&lt;td&gt;通信模式可以是&lt;code&gt;Request Only&lt;/code&gt;（也称为Fire and Forget），&lt;code&gt;Request Response&lt;/code&gt;，&lt;code&gt;Read&lt;/code&gt;，&lt;code&gt;Browse&lt;/code&gt;，&lt;code&gt;Clear&lt;/code&gt;：&lt;ul&gt;&lt;li&gt;&lt;code&gt;Request Only&lt;/code&gt;只会发送消息，不会监控回复。因此，它可用于对系统产生负载。&lt;/li&gt;&lt;li&gt;&lt;code&gt;Request Response&lt;/code&gt;将发送消息并监控它收到的回复。行为取决于JNDI Name Reply queue的值。如果JNDI Name Reply Queue有值，则此队列用于监视结果。使用请求的消息id和回复的相关id完成请求和回复的匹配。如果JNDI Name Reply queue为空，则创建临时队列用于请求者和服务器之间的通信。这与固定回复队列非常不同。使用临时队列，发送线程将阻塞，直到收到回复消息。使用“&lt;code&gt;Request Response&lt;/code&gt;”模式，您需要一个服务器来监听发送到请求队列的消息，并将回复发送到&lt;code&gt;message.getJMSReplyTo()&lt;/code&gt;引用的队列。&lt;/li&gt;&lt;li&gt;&lt;code&gt;Read&lt;/code&gt;将从没有附加监听器的传出队列中读取消息。这对于测试目的很方便。可以用来处理没有绑定文件的队列（假设使用了jmeter-jms-skip-jndi库），该方法仅适用于JMS点到点取样器。在使用绑定文件的情况下，也可以使用JMS订阅取样器从队列中读取。&lt;/li&gt;&lt;li&gt;&lt;code&gt;Browse&lt;/code&gt;将确定当前队列深度而不从队列中删除消息，返回队列中的消息数。&lt;/li&gt;&lt;li&gt;&lt;code&gt;Clear&lt;/code&gt;将清除队列，即从队列中删除所有消息。&lt;/li&gt;&lt;/ul&gt;&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Use alternate fields for message correlation&lt;/td&gt;
&lt;td&gt;这些复选框选择用于将响应消息与原始请求进行匹配的字段。&lt;ul&gt;&lt;li&gt;&lt;code&gt;Use Request Message Id&lt;/code&gt;如果选中，将使用request JMSMessageID，否则将使用request JMSCorrelationID。在后一种情况下，必须在请求中指定相关ID。&lt;/li&gt;&lt;li&gt;&lt;code&gt;Use Response Message Id&lt;/code&gt;如果选中，将使用Response JMSMessageID，否则将使用Response JMSCorrelationID。&lt;/li&gt;&lt;/ul&gt;有两种常用的JMS关联模式：&lt;ul&gt;&lt;li&gt;&lt;strong&gt;JMS Correlation ID&lt;/strong&gt;：即以相关性的Ids匹配请求和响应 =&amp;gt;取消选中两个复选框，并提供相关ID。&lt;/li&gt;&lt;li&gt;&lt;strong&gt;JMS Message ID&lt;/strong&gt;：即匹配请求消息id与响应相关id =&amp;gt;仅选择“Use Request Message Id”。&lt;/li&gt;&lt;/ul&gt;在这两种情况下，JMS应用程序都负责根据需要填充相关ID。&lt;blockquote&gt;如果使用相同的队列发送和接收消息，则响应消息将与请求消息相同。在这种情况下，要么提供相关ID并清除两个复选框; 或选中两个复选框以使用消息Id进行关联。这对于检查原始JMS吞吐量非常有用。&lt;/blockquote&gt;&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Timeout&lt;/td&gt;
&lt;td&gt;回复消息的超时时间（以毫秒为单位）。如果在指定时间内未收到回复，则特定测试用例将失败，并且将丢弃超时后收到的特定回复消息。默认为&lt;code&gt;2000&lt;/code&gt;毫秒。&lt;code&gt;0&lt;/code&gt;表示不设超时。&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Expiration&lt;/td&gt;
&lt;td&gt;消息过期时间（以毫秒为单位）。如果未指定，则默认值为&lt;code&gt;0&lt;/code&gt;（永不过期）。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Priority&lt;/td&gt;
&lt;td&gt;消息的优先级。从&lt;code&gt;0&lt;/code&gt;（最低）到&lt;code&gt;9&lt;/code&gt;（最高）有10个优先级。如果未指定优先级，则默认级别为&lt;code&gt;4&lt;/code&gt;。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Use non-persistent delivery mode?&lt;/td&gt;
&lt;td&gt;是否设置&lt;code&gt;DeliveryMode.NON_PERSISTENT&lt;/code&gt;。&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Content&lt;/td&gt;
&lt;td&gt;消息的内容。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;JMS Properties&lt;/td&gt;
&lt;td&gt;JMS属性是特定于底层消息传递系统的属性。您可以设置值的名称，值和类（类型）。默认类型为&lt;code&gt;String&lt;/code&gt;。例如：对于WebSphere 5.1 Web服务，您需要设置JMS Property targetService来通过JMS测试Web服务。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Initial Context Factory&lt;/td&gt;
&lt;td&gt;Initial Context Factory是用于查找JMS资源的工厂。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;JNDI properties&lt;/td&gt;
&lt;td&gt;JNDI属性是底层JNDI实现的特定属性。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Provider URL&lt;/td&gt;
&lt;td&gt;JMS提供方的URL。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;a href="#toc"&gt;【返回目录】&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="junit"&gt;JUnit请求&lt;/h3&gt;
&lt;p&gt;当前实现支持标准JUnit约定和扩展。它还包括&lt;code&gt;oneTimeSetUp&lt;/code&gt;和&lt;code&gt;oneTimeTearDown&lt;/code&gt;等扩展。取样器的工作方式与&lt;a href="http://jmeter.apache.org/usermanual/component_reference.html#Java_Request"&gt;Java请求&lt;/a&gt;类似，但 存在一些差异。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;与使用JMeter的测试接口不同，它会扫描jar文件以寻找扩展JUnit&lt;code&gt;TestCase&lt;/code&gt;类的类。这包括任何类或子类。&lt;/li&gt;
&lt;li&gt;JUnit测试jar文件应该放在&lt;code&gt;jmeter/lib/junit&lt;/code&gt;而不是&lt;code&gt;/lib&lt;/code&gt;目录中。您还可以使用“&lt;code&gt;user.classpath&lt;/code&gt;”属性指定查找&lt;code&gt;TestCase&lt;/code&gt;类的位置。&lt;/li&gt;
&lt;li&gt;JUnit取样器不像&lt;a href="http://jmeter.apache.org/usermanual/component_reference.html#Java_Request"&gt;Java请求&lt;/a&gt;那样使用名称/值对进行配置。取样器假定&lt;code&gt;setUp&lt;/code&gt;和&lt;code&gt;tearDown&lt;/code&gt;将正确配置测试。&lt;/li&gt;
&lt;li&gt;取样器仅测量测试方法的经过时间，不包括&lt;code&gt;setUp&lt;/code&gt;和&lt;code&gt;tearDown&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;每次调用测试方法时，JMeter都会将结果传递给监听器。&lt;/li&gt;
&lt;li&gt;支持&lt;code&gt;oneTimeSetUp&lt;/code&gt;和&lt;code&gt;oneTimeTearDown&lt;/code&gt;作为方法完成。由于JMeter是多线程的，我们不能像Maven那样调用&lt;code&gt;oneTimeSetUp/oneTimeTearDown&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;取样器将意外异常报告为错误。标准JUnit测试运行与JMeter实现之间存在一些重要差异。JMeter不是为每个测试创建一个新的类实例，而是为每个取样器创建一个实例并重用它。这可以通过复选框“&lt;code&gt;Create a new instance per sample&lt;/code&gt;”进行更改。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;取样器的当前实现将尝试首先使用字符串构造函数创建实例。如果测试类没有声明字符串构造函数，则取样器将查找空构造函数。示例如下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;h4 id="junit_1"&gt;JUnit构造函数&lt;/h4&gt;
&lt;p&gt;空构造函数：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    public class myTestCase {
      public myTestCase() {}
    }
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;字符串构造函数：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    public class myTestCase {
      public myTestCase(String text) {
          super(text);
      }
    }
&lt;/pre&gt;&lt;/div&gt;


&lt;/blockquote&gt;
&lt;p&gt;默认情况下，JMeter将为成功/失败代码和消息提供一些默认值。用户应定义一组唯一的成功和失败代码，并在所有测试中统一使用它们。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;一般准则&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果使用&lt;code&gt;setUp&lt;/code&gt;和&lt;code&gt;tearDown&lt;/code&gt;，请确保将方法声明为public。如果不这样做，测试可能无法正常运行。&lt;br&gt;
以下是编写JUnit测试的一般准则，能使它们在JMeter下运行良好。由于JMeter运行多线程，因此记住某些事情非常重要。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;编写的&lt;code&gt;setUp&lt;/code&gt;和&lt;code&gt;tearDown&lt;/code&gt;方法应是线程安全的。这通常意味着避免使用静态成员。&lt;/li&gt;
&lt;li&gt;使测试方法成为离散的工作单元，而不是长的动作序列。通过将测试方法保持为离散操作，可以更轻松地组合测试方法以创建新的测试计划。&lt;/li&gt;
&lt;li&gt;避免使测试方法相互依赖。由于JMeter允许对测试方法进行任意排序，因此运行行为与默认的JUnit行为不同。&lt;/li&gt;
&lt;li&gt;如果测试方法是可配置的，请注意存储属性的位置。建议从Jar文件中读取属性。&lt;/li&gt;
&lt;li&gt;每个取样器都会创建一个测试类的实例，因此编写测试时，应在&lt;code&gt;oneTimeSetUp&lt;/code&gt;和&lt;code&gt;oneTimeTearDown&lt;/code&gt;中进行初始化等配置。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img alt="Screenshot for Control-Panel of JUnit Request" src="http://jmeter.apache.org/images/screenshots/junit_sampler.png"&gt;&lt;br&gt;
&lt;em&gt;JUnit请求控制面板的截图&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参数&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th align="left"&gt;是否必须&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;名称&lt;/td&gt;
&lt;td&gt;树中显示的此元件的描述性名称。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Search for JUnit4 annotations&lt;/td&gt;
&lt;td&gt;选择此项以搜索JUnit4测试（&lt;code&gt;@Test&lt;/code&gt;注释）&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Package filter&lt;/td&gt;
&lt;td&gt;以逗号分隔的要显示的包列表。例如，&lt;code&gt;org.apache.jmeter,junit.framework&lt;/code&gt;。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Class name&lt;/td&gt;
&lt;td&gt;JUnit测试类的完全限定名称。&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Constructor string&lt;/td&gt;
&lt;td&gt;传递给字符串构造函数的字符串。如果设置了字符串，则取样器将使用字符串构造函数而不是空构造函数。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Test method&lt;/td&gt;
&lt;td&gt;测试方法。&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Success message&lt;/td&gt;
&lt;td&gt;测试成功的描述性信息。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Success code&lt;/td&gt;
&lt;td&gt;表示测试成功的唯一代码。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Failure message&lt;/td&gt;
&lt;td&gt;测试失败的描述性信息。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Failure code&lt;/td&gt;
&lt;td&gt;表示测试失败的唯一代码。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Error message&lt;/td&gt;
&lt;td&gt;错误描述。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Error code&lt;/td&gt;
&lt;td&gt;一些错误代码。不需要唯一。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Do not call setUp and tearDown&lt;/td&gt;
&lt;td&gt;设置取样器不要调用&lt;code&gt;setUp&lt;/code&gt;和&lt;code&gt;tearDown&lt;/code&gt;。默认情况下，会调用&lt;code&gt;setUp&lt;/code&gt;和&lt;code&gt;tearDown&lt;/code&gt;。不调用这些方法可能会影响测试并使其不准确。此选项应仅与调用&lt;code&gt;oneTimeSetUp&lt;/code&gt;和&lt;code&gt;oneTimeTearDown&lt;/code&gt;一起使用。如果所选方法是&lt;code&gt;oneTimeSetUp&lt;/code&gt;或&lt;code&gt;oneTimeTearDown&lt;/code&gt;，则应检查此选项。&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Append assertion errors&lt;/td&gt;
&lt;td&gt;是否在响应消息中附加断言错误。&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Append runtime exceptions&lt;/td&gt;
&lt;td&gt;是否将运行时异常附加到响应消息。仅在未选择“&lt;code&gt;Append assertion errors&lt;/code&gt;”时适用。&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Create a new Instance per sample&lt;/td&gt;
&lt;td&gt;是否为每个样本创建新的JUnit实例。默认为false，表示创建一个JUnit&lt;code&gt;TestCase&lt;/code&gt;并重复使用。&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;识别以下JUnit4注释：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;@Test&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;用于查找测试方法和类。支持“&lt;code&gt;expected&lt;/code&gt;”和“&lt;code&gt;timeout&lt;/code&gt;”属性。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;@Before&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在JUnit3中当做&lt;code&gt;setUp()&lt;/code&gt;对待&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;@After&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在JUnit3中当做&lt;code&gt;tearDown()&lt;/code&gt;对待&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;@BeforeClass&lt;/code&gt;，&lt;code&gt;@AfterClass&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;作为测试方法处理，因此可以根据需要独立运行&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注意，当前版本JMeter直接运行测试方法，而不是将其留给JUnit。这是为了可以从采样时间中排除&lt;code&gt;setUp&lt;/code&gt;/&lt;code&gt;tearDown&lt;/code&gt;方法。因此，取样器时间排除了调用&lt;code&gt;setUp&lt;/code&gt;/&lt;code&gt;tearDown&lt;/code&gt;方法及基于其注释的替代方法所花费的时间。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href="#toc"&gt;【返回目录】&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="_1"&gt;邮件阅读者取样器&lt;/h3&gt;
&lt;p&gt;邮件阅读者取样器可以使用POP3(S)或IMAP(S)协议读取（可选删除）邮件消息。&lt;/p&gt;
&lt;p&gt;&lt;img alt="Screenshot for Control-Panel of Mail Reader Sampler" src="http://jmeter.apache.org/images/screenshots/mailreader_sampler.png"&gt;&lt;br&gt;
&lt;em&gt;邮件阅读者取样器控制面板的截图&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参数&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th align="left"&gt;是否必须&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;名称&lt;/td&gt;
&lt;td&gt;树中显示的此元件的描述性名称。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Server Type&lt;/td&gt;
&lt;td&gt;提供者使用的协议：例如&lt;code&gt;pop3&lt;/code&gt;，&lt;code&gt;pop3s&lt;/code&gt;，&lt;code&gt;imap&lt;/code&gt;，&lt;code&gt;imaps&lt;/code&gt;。或其他表示服务器协议的字符串。例如&lt;code&gt;file&lt;/code&gt;用于只读邮件文件提供者。POP3和IMAP的实际提供者名称是&lt;code&gt;pop3&lt;/code&gt;和&lt;code&gt;imap&lt;/code&gt;&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Server&lt;/td&gt;
&lt;td&gt;服务器的主机名或IP地址。请参阅下面的&lt;code&gt;file&lt;/code&gt;协议。&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Port&lt;/td&gt;
&lt;td&gt;用于连接服务器的端口号（可选）&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Username&lt;/td&gt;
&lt;td&gt;用户登录名&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Password&lt;/td&gt;
&lt;td&gt;用户登录密码（注意，它在测试计划中是没有加密存储的）&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Folder&lt;/td&gt;
&lt;td&gt;要使用的IMAP(S)文件夹。请参阅下面的&lt;code&gt;file&lt;/code&gt;协议。&lt;/td&gt;
&lt;td align="left"&gt;是，如果使用IMAP(S)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Number of messages to retrieve&lt;/td&gt;
&lt;td&gt;设置此项以检索所有或部分消息&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Fetch headers only&lt;/td&gt;
&lt;td&gt;如果选中，则仅检索邮件信息头。&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Delete messages from the server&lt;/td&gt;
&lt;td&gt;如果设置，将在检索后删除邮件&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Store the message using MIME&lt;/td&gt;
&lt;td&gt;是否将邮件存储为MIME。如果选中，则整个原始消息存储在响应数据中；信息头不会存储，因为它们在数据中可用。如果未选中，则将邮件信息头存储为响应信息头。部分信息头（&lt;code&gt;Date&lt;/code&gt;，&lt;code&gt;To&lt;/code&gt;，&lt;code&gt;From&lt;/code&gt;，&lt;code&gt;Subject&lt;/code&gt;）存储在消息体中。&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Use no security features&lt;/td&gt;
&lt;td&gt;表示与服务器的连接不使用任何安全协议。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Use SSL&lt;/td&gt;
&lt;td&gt;表示与服务器的连接必须使用SSL协议。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Use StartTLS&lt;/td&gt;
&lt;td&gt;表示与服务器的连接应尝试启动TLS协议。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Enforce StartTLS&lt;/td&gt;
&lt;td&gt;如果服务器未启动TLS协议，则终止连接。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Trust All Certificates&lt;/td&gt;
&lt;td&gt;选择后，它将接受独立于CA的所有证书。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Use local truststore&lt;/td&gt;
&lt;td&gt;选择后，它只接受本地信任的证书。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Local truststore&lt;/td&gt;
&lt;td&gt;包含受信任证书的文件路径。是针对当前目录的相对路径。&lt;br/&gt;如果查找证书失败，则到包含测试脚本（JMX文件）的目录中寻找。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;blockquote&gt;
&lt;p&gt;您可以通过向user.properties添加&lt;a href="https://javaee.github.io/javamail/docs/api/com/sun/mail/pop3/package-summary.html"&gt;此处&lt;/a&gt;描述的任何属性来传递与邮件相关的环境属性。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;消息存储为主取样器的子样本。多部分消息按部分存储为消息的子样本。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;关于&lt;code&gt;file&lt;/code&gt;协议的特殊处理：&lt;/strong&gt; 
JavaMail中&lt;code&gt;file&lt;/code&gt;提供者可用于从文件中读取原始邮件。&lt;code&gt;server&lt;/code&gt;字段用于指定路径的父&lt;code&gt;folder&lt;/code&gt;。应使用名称&lt;code&gt;n.msg&lt;/code&gt;存储单个消息文件，其中&lt;code&gt;n&lt;/code&gt;为消息编号。或者，&lt;code&gt;server&lt;/code&gt;字段可以是包含单个消息的文件的名称。此实现非常基础，主要用于调试目的。&lt;/p&gt;
&lt;p&gt;&lt;a href="#toc"&gt;【返回目录】&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="flow-control-action"&gt;测试活动（Flow Control Action）&lt;/h3&gt;
&lt;p&gt;测试活动取样器是一个适用于条件控制器的取样器。测试元件不是生成样本，而是暂停或停止所选目标。&lt;/p&gt;
&lt;p&gt;此取样器也可以与事务控制器结合使用，因为它允许包含暂停而无需生成样本。对于可变延迟，将暂停时间设置为零，并将定时器添加为子级。&lt;/p&gt;
&lt;p&gt;完成正在进行的任何样本后 ，“&lt;code&gt;stop&lt;/code&gt;”操作将停止线程或测试。“&lt;code&gt;Stop Now&lt;/code&gt;”操作将停止测试，而无需等待样本完成; 它会中断任何活动样本。如果某些线程未能在5秒的时间限制内停止，则将在GUI模式下显示一条消息。您可以使用&lt;code&gt;Stop&lt;/code&gt;命令尝试停止线程，如果不能停止，可以手动退出JMeter。在CLI模式下，如果某些线程未能在5秒的时间限制内停止，JMeter将退出。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;可以使用JMeter属性&lt;code&gt;jmeterengine.threadstop.wait&lt;/code&gt;更改等待时间。以毫秒为单位。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img alt="Screenshot for Control-Panel of Flow Control Action" src="http://jmeter.apache.org/images/screenshots/test_action.png"&gt;&lt;br&gt;
&lt;em&gt;测试活动控制面板的截图&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参数&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th align="left"&gt;是否必须&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;名称&lt;/td&gt;
&lt;td&gt;树中显示的此元件的描述性名称。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Target&lt;/td&gt;
&lt;td&gt;&lt;code&gt;Current Thread&lt;/code&gt;/&lt;code&gt;All Threads&lt;/code&gt;( &lt;code&gt;Pause&lt;/code&gt; 和 &lt;code&gt;Go to next loop iteration&lt;/code&gt;时忽略)&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Action&lt;/td&gt;
&lt;td&gt;&lt;code&gt;Pause&lt;/code&gt;/&lt;code&gt;Stop&lt;/code&gt;/&lt;code&gt;Stop Now&lt;/code&gt;/&lt;code&gt;Go to next loop iteration&lt;/code&gt;&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Duration&lt;/td&gt;
&lt;td&gt;暂停多长时间（毫秒）&lt;/td&gt;
&lt;td align="left"&gt;是，如果选中暂停&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;a href="#toc"&gt;【返回目录】&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="smtp"&gt;SMTP取样器&lt;/h3&gt;
&lt;p&gt;SMTP取样器可以使用SMTP/SMTPS协议发送邮件。可以为连接（SSL和TLS）以及用户身份认证设置安全协议。如果使用安全协议，则将对服务器证书进行验证。&lt;br&gt;
有两种方法可以处理此验证：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Trust all certificates&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这将忽略证书链验证&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Use a local truststore&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;使用此选项，将根据本地信任库文件验证证书链。&lt;/p&gt;
&lt;p&gt;&lt;img alt="Screenshot for Control-Panel of SMTP Sampler" src="http://jmeter.apache.org/images/screenshots/smtp_sampler.png"&gt;&lt;br&gt;
&lt;em&gt;SMTP取样器控制面板的截图&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参数&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th align="left"&gt;是否必须&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;名称&lt;/td&gt;
&lt;td&gt;树中显示的此元件的描述性名称。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Server&lt;/td&gt;
&lt;td&gt;服务器的主机名或IP地址。请参阅下面的&lt;code&gt;file&lt;/code&gt;协议。&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Port&lt;/td&gt;
&lt;td&gt;用于连接服务器的端口号。默认值为：SMTP=25，SSL=465，StartTLS=587&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Connection timeout&lt;/td&gt;
&lt;td&gt;连接超时时间，以毫秒为单位（套接字级别）。默认不设超时。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Read timeout&lt;/td&gt;
&lt;td&gt;读取超时时间（以毫秒为单位）（套接字级别）。默认不设超时。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Address From&lt;/td&gt;
&lt;td&gt;将出现在电子邮件中的发件人地址&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Address To&lt;/td&gt;
&lt;td&gt;目标电子邮件地址（多个值以“&lt;code&gt;;&lt;/code&gt;” 分隔）&lt;/td&gt;
&lt;td align="left"&gt;是，除非指定了CC或BCC&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Address To CC&lt;/td&gt;
&lt;td&gt;抄送目标电子邮件地址（多个值以“&lt;code&gt;;&lt;/code&gt;” 分隔）&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Address To BCC&lt;/td&gt;
&lt;td&gt;密送目标电子邮件地址（多个值以“&lt;code&gt;;&lt;/code&gt;” 分隔）&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Address Reply-To&lt;/td&gt;
&lt;td&gt;备用回复地址（多个值以“&lt;code&gt;;&lt;/code&gt;” 分隔）&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Use Auth&lt;/td&gt;
&lt;td&gt;指示SMTP服务器是否需要户身份验证&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Username&lt;/td&gt;
&lt;td&gt;用户登录名&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Password&lt;/td&gt;
&lt;td&gt;用户登录密码（注意，它在测试计划中是没有加密存储的）&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Use no security features&lt;/td&gt;
&lt;td&gt;表示与SMTP服务器的连接不使用任何安全协议。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Use SSL&lt;/td&gt;
&lt;td&gt;表示与SMTP服务器的连接必须使用SSL协议。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Use StartTLS&lt;/td&gt;
&lt;td&gt;表示与SMTP服务器的连接应尝试启动TLS协议。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Enforce StartTLS&lt;/td&gt;
&lt;td&gt;如果服务器未启动TLS协议，则终止连接。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Trust All Certificates&lt;/td&gt;
&lt;td&gt;选择后，它将接受独立于CA的所有证书。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Use local truststore&lt;/td&gt;
&lt;td&gt;选择后，它只接受本地信任的证书。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Local truststore&lt;/td&gt;
&lt;td&gt;包含受信任证书的文件路径。是针对当前目录的相对路径。&lt;br/&gt;如果查找证书失败，则到包含测试脚本（JMX文件）的目录中寻找。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Override System SSL/TLS Protocols&lt;/td&gt;
&lt;td&gt;在握手时使用的自定义SSL/TLS协议，它是以空格分隔的列表，例如&lt;code&gt;TLSv1 TLSv1.1 TLSv1.2&lt;/code&gt;。默认为所有支持的协议。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Subject&lt;/td&gt;
&lt;td&gt;电子邮件主题。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Suppress Subject Header&lt;/td&gt;
&lt;td&gt;如果选中，则从发送的邮件中省略“&lt;code&gt;Subject:&lt;/code&gt;”邮件头。这与发送空的“ &lt;code&gt;Subject:&lt;/code&gt;”邮件头不同，尽管某些电子邮件客户端可能会以相同的方式显示它。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Include timestamp in subject&lt;/td&gt;
&lt;td&gt;包含主题行中的&lt;code&gt;System.currentTimemillis()&lt;/code&gt;。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Add Header&lt;/td&gt;
&lt;td&gt;可以使用此按钮定义其他邮件头。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Message&lt;/td&gt;
&lt;td&gt;消息体。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Send plain body (i.e. not multipart/mixed)&lt;/td&gt;
&lt;td&gt;如果选中，则将主体作为简单消息发送，即不是&lt;code&gt;multipart/mixed&lt;/code&gt;，如果可能的话。如果消息正文为空并且只有一个文件，则将文件内容作为消息体发送。&lt;blockquote&gt;注意：如果邮件正文不为空，并且至少有一个附加文件，则消息体将使用&lt;code&gt;multipart/mixed&lt;/code&gt;发送。&lt;/blockquote&gt;&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Attach files&lt;/td&gt;
&lt;td&gt;要附加到邮件的文件&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Send .eml&lt;/td&gt;
&lt;td&gt;如果设置，将发送&lt;code&gt;.eml&lt;/code&gt;文件而不是&lt;code&gt;Subject&lt;/code&gt;，&lt;code&gt;Message&lt;/code&gt;和&lt;code&gt;Attach file(s)&lt;/code&gt;字段中的条目&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Calculate message size&lt;/td&gt;
&lt;td&gt;计算消息大小并将其存储在样本结果中。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Enable debug logging?&lt;/td&gt;
&lt;td&gt;如果设置，则“&lt;code&gt;mail.debug&lt;/code&gt;”属性设置为“&lt;code&gt;true&lt;/code&gt;”&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;a href="#toc"&gt;【返回目录】&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="os"&gt;OS进程取样器&lt;/h3&gt;
&lt;p&gt;OS进程取样器是一个可用于在本地计算机上执行命令的取样器。&lt;br&gt;
它应该允许执行可以从命令行运行的任何命令。&lt;br&gt;
可以启用返回代码的验证，并可以指定预期的返回代码。&lt;/p&gt;
&lt;p&gt;注意OS shell通常提供命令行解析。这在操作系统之间有所不同，但通常shell会按照空格拆分参数。一些shell扩展了通配符文件名；另一些没有。操作系统之间的引用机制也各不相同。取样器故意不进行任何解析或引用处理。必须以可执行文件期望的形式提供命令及其参数。这意味着取样器设置将无法在操作系统之间移植。&lt;/p&gt;
&lt;p&gt;许多操作系统都有一些内置命令，这些命令不作为单独的可执行文件提供。例如，Windows&lt;code&gt;DIR&lt;/code&gt;命令是命令解释器（&lt;code&gt;CMD.EXE&lt;/code&gt;）的一部分。这些内置函数不能作为独立程序运行，但必须作为参数提供给相应的命令解释器。&lt;/p&gt;
&lt;p&gt;例如，Windows命令行：&lt;code&gt;DIR C:\TEMP&lt;/code&gt;需要指定如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;命令：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;CMD&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;参数1：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;/C&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;参数2：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;DIR&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;参数3：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;C:\TEMP&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="Screenshot for Control-Panel of OS Process Sampler" src="http://jmeter.apache.org/images/screenshots/os_process_sampler.png"&gt;&lt;br&gt;
&lt;em&gt;OS进程取样器控制面板的截图&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参数&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th align="left"&gt;是否必须&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;名称&lt;/td&gt;
&lt;td&gt;树中显示的此元件的描述性名称。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;命令&lt;/td&gt;
&lt;td&gt;要执行的程序名称。&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;工作目录&lt;/td&gt;
&lt;td&gt;执行命令的目录，默认为系统属性“&lt;code&gt;user.dir&lt;/code&gt;”引用的文件夹&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;命令行参数&lt;/td&gt;
&lt;td&gt;传递给程序名称的参数。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;环境变量&lt;/td&gt;
&lt;td&gt;执行命令时添加到环境的键/值对。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Standard input (stdin)&lt;/td&gt;
&lt;td&gt;要从中获取输入的文件的名称（&lt;code&gt;STDIN&lt;/code&gt;）。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Standard output (stdout)&lt;/td&gt;
&lt;td&gt;标准输出（&lt;code&gt;STDOUT&lt;/code&gt;）的输出文件名。如果省略，则捕获输出并作为响应数据返回。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Standard error (stderr)&lt;/td&gt;
&lt;td&gt;标准错误（&lt;code&gt;STDERR&lt;/code&gt;）的输出文件名。如果省略，则捕获输出并作为响应数据返回。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;检查返回码&lt;/td&gt;
&lt;td&gt;如果选中，则取样器会将返回码与&lt;code&gt;预期返回代码&lt;/code&gt;进行比较。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;预期返回代码&lt;/td&gt;
&lt;td&gt;系统调用的预期返回代码，需要选中“&lt;code&gt;检查返回码&lt;/code&gt; ”。注意500在JMeter中用作错误指示符，因此您不应使用它。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Timeout&lt;/td&gt;
&lt;td&gt;命令超时时间（以毫秒为单位），默认为&lt;code&gt;0&lt;/code&gt;，表示不设超时。如果命令执行完之前超时了，JMeter将尝试终止OS进程。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;a href="#toc"&gt;【返回目录】&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="mongodb"&gt;MongoDB脚本（已弃用）&lt;/h3&gt;
&lt;p&gt;略&lt;/p&gt;
&lt;p&gt;&lt;a href="#toc"&gt;【返回目录】&lt;/a&gt;&lt;/p&gt;
&lt;h2 id="182"&gt;18.2 逻辑控制器&lt;/h2&gt;
&lt;p&gt;逻辑控制器决定取样器的处理顺序。&lt;/p&gt;
&lt;h3 id="_2"&gt;简单控制器&lt;/h3&gt;
&lt;p&gt;简单逻辑控制器允许您组织取样器和其他逻辑控制器。与其他逻辑控制器不同，该控制器不提供超出存储设备的功能。&lt;/p&gt;
&lt;p&gt;&lt;img alt="Screenshot for Control-Panel of Simple Controller" src="http://jmeter.apache.org/images/screenshots/logic-controller/simple-controller.png"&gt;&lt;br&gt;
&lt;em&gt;简单控制器控制面板的截图&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参数&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th align="left"&gt;是否必须&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;名称&lt;/td&gt;
&lt;td&gt;树中显示的此控制器的描述性名称。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;blockquote&gt;
&lt;h4 id="_3"&gt;使用简单控制器&lt;/h4&gt;
&lt;p&gt;&lt;a href="http://jmeter.apache.org/demos/SimpleTestPlan.jmx"&gt;下载&lt;/a&gt;此示例（参见图6）。在此示例中，我们创建了一个测试计划，该计划发送两个Ant HTTP请求和两个Log4J HTTP请求。我们通过把Ant和Log4J请求放在简单逻辑控制器中将它们分组。请记住，简单逻辑控制器对JMeter如何处理您添加到其中的控制器没有影响。因此，在此示例中，JMeter按以下顺序发送请求：Ant Home Page，Ant News Page，Log4J Home Page， Log4J History Page。&lt;/p&gt;
&lt;p&gt;注意，File Reporter配置为将结果存储在当前目录中名为“&lt;code&gt;simple-test.dat&lt;/code&gt;”的文件中。&lt;/p&gt;
&lt;p&gt;&lt;img alt="Figure 6 Simple Controller Example" src="http://jmeter.apache.org/images/screenshots/logic-controller/simple-example.png"&gt;&lt;br&gt;
&lt;em&gt;图6 - 简单控制器示例&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href="#toc"&gt;【返回目录】&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="_4"&gt;循环控制器&lt;/h3&gt;
&lt;p&gt;如果将生成器或逻辑控制器添加到循环控制器，除了为线程组指定的循环次数外，JMeter还将循环它们一定次数。例如，如果将一个HTTP请求添加到循环计数为2的循环控制器，并将线程组循环计数配置为3，则JMeter将发送总共&lt;code&gt;2 * 3 = 6&lt;/code&gt;个 HTTP请求。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;JMeter将循环索引公开为名为&lt;code&gt;__jm__&amp;lt;Name of your element&amp;gt;__idx&lt;/code&gt;的变量。因此，例如，假设您的循环控制器名称为LC，那么您可以通过&lt;code&gt;${__jm__LC__idx}&lt;/code&gt;访问循环索引。索引从0开始&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img alt="Screenshot for Control-Panel of Loop Controller" src="http://jmeter.apache.org/images/screenshots/logic-controller/loop-controller.png"&gt;&lt;br&gt;
&lt;em&gt;循环控制器控制面板的截图&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参数&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th align="left"&gt;是否必须&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;名称&lt;/td&gt;
&lt;td&gt;树中显示的此控制器的描述性名称。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;循环次数&lt;/td&gt;
&lt;td&gt;每次测试执行时，将重复此控制器的子元件的次数。&lt;br /&gt;值&lt;code&gt;-1&lt;/code&gt;等同于选中&lt;code&gt;永远&lt;/code&gt;。&lt;br /&gt;&lt;strong&gt;特殊情况：&lt;/strong&gt;嵌入在&lt;a href="http://jmeter.apache.org/usermanual/test_plan.html#thread_group"&gt;线程组&lt;/a&gt;元件中的循环控制器的行为略有不同。除非设置为永久，否则在完成给定的迭代次数后，它将停止测试。&lt;blockquote&gt;在此字段中使用函数时，请注意可能会多次评估它。例如在循环控制器中使用&lt;code&gt;__Random&lt;/code&gt;，循环控制器的每个子取样器都会将其评估为不同的值，并导致非预期的行为。&lt;/blockquote&gt;&lt;/td&gt;
&lt;td align="left"&gt;是，除非选中“永远”&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;blockquote&gt;
&lt;h4 id="_5"&gt;循环示例&lt;/h4&gt;
&lt;p&gt;&lt;a href="http://jmeter.apache.org/demos/LoopTestPlan.jmx"&gt;下载&lt;/a&gt;此示例（参见图4）。在此示例中，我们创建了一个测试计划，该计划发送一个HTTP请求1次，并发送另一个HTTP请求5次。&lt;/p&gt;
&lt;p&gt;&lt;img alt="Figure 4 - Loop Controller Example" src="http://jmeter.apache.org/images/screenshots/logic-controller/loop-example.png"&gt;&lt;br&gt;
&lt;em&gt;图4 - 循环控制器示例&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;我们为单个线程配置了线程组，并将循环次数配置为1。我们使用循环控制器，而不是让线程组控制循环。您可以看到我们向线程组添加了一个HTTP请求，并向循环控制器添加了另一个HTTP请求。我们将循环控制器循环次数配置为5。&lt;/p&gt;
&lt;p&gt;JMeter将按以下顺序发送请求：Home Page，News Page，News Page，News Page，News Page，和News Page。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注意，File Reporter配置为将结果存储在当前目录中名为“&lt;code&gt;loop-test.dat&lt;/code&gt;”的文件中。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href="#toc"&gt;【返回目录】&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="_6"&gt;仅一次控制器&lt;/h3&gt;
&lt;p&gt;仅一次逻辑控制器告诉JMeter每个线程只处理一次其内部的控制器，并在测试计划之后的迭代期间执行其后的所有请求。&lt;/p&gt;
&lt;p&gt;仅一次控制器现在将始终在任何循环父控制器的第一次迭代期间执行。因此，如果将仅一次控制器放置在指定循环5次的循环控制器下，那么仅一次控制器将仅在循环控制器第一次迭代时执行（即每5次）。&lt;/p&gt;
&lt;p&gt;注意这意味着如果将它置于一个线程组（每个线程每次测试只运行一次），那么仅一次控制器仍然会像预期的那样运行，但现在用户可以更灵活地使用仅一次控制器。&lt;/p&gt;
&lt;p&gt;对于需要登录的测试，请考虑将登录请求放在此控制器中，因为每个线程只需登录一次即可建立会话。&lt;/p&gt;
&lt;p&gt;&lt;img alt="Screenshot for Control-Panel of Once Only Controller" src="http://jmeter.apache.org/images/screenshots/logic-controller/once-only-controller.png"&gt;&lt;br&gt;
&lt;em&gt;仅一次控制器控制面板的截图&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参数&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th align="left"&gt;是否必须&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;名称&lt;/td&gt;
&lt;td&gt;树中显示的此控制器的描述性名称。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;blockquote&gt;
&lt;h4 id="_7"&gt;仅一次示例&lt;/h4&gt;
&lt;p&gt;&lt;a href="http://jmeter.apache.org/demos/OnceOnlyTestPlan.jmx"&gt;下载&lt;/a&gt;此示例（参见图5）。在此示例中，我们创建了一个测试计划，其中包含两个发送HTTP请求的线程。每个线程向Home Page发送一次请求，然后向Bug Page发送三次请求。虽然我们将线程组配置为迭代三次，但每个JMeter线程只向Home Page发送一次请求，因为此请求位于仅一次控制器内。&lt;/p&gt;
&lt;p&gt;&lt;img alt="Figure 5. Once Only Controller Example" src="http://jmeter.apache.org/images/screenshots/logic-controller/once-only-example.png"&gt;&lt;br&gt;
&lt;em&gt;图5 - 仅一次控制器示例&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;每个JMeter线程将按以下顺序发送请求：Home Page，Bug Page，Bug Page，Bug Page。&lt;/p&gt;
&lt;p&gt;注意，File Reporter配置为将结果存储在当前目录中名为“&lt;code&gt;loop-test.dat&lt;/code&gt;”的文件中。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href="#toc"&gt;【返回目录】&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="_8"&gt;交替控制器&lt;/h3&gt;
&lt;p&gt;如果将生成器或逻辑控制器添加到交替控制器，则JMeter每次循环迭代时将在每个其他控制器之间交替进行。&lt;/p&gt;
&lt;p&gt;&lt;img alt="Screenshot for Control-Panel of Interleave Controller" src="http://jmeter.apache.org/images/screenshots/logic-controller/interleave-controller.png"&gt;&lt;br&gt;
&lt;em&gt;交替控制器控制面板的截图&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参数&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th align="left"&gt;是否必须&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;名称&lt;/td&gt;
&lt;td&gt;树中显示的此控制器的描述性名称。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;忽略子控制器块&lt;/td&gt;
&lt;td&gt;如果选中，交替控制器将把子控制器当作单个请求元件来处理，并且每个控制器一次只允许一个请求。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Interleave across threads&lt;/td&gt;
&lt;td&gt;如果选中，交替控制器每次循环迭代时将跨所有线程在每个子控制器之间交替进行。例如在具有4个线程和3个子控制器的配置中，在第一次迭代时线程1将运行第一个子节点，线程2第二个子节点，线程3第三个子线程，线程4第一个子节点，在下一次迭代中，每个线程将运行下一个子控制器&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;blockquote&gt;
&lt;h4 id="_9"&gt;简单交替示例&lt;/h4&gt;
&lt;p&gt;&lt;a href="http://jmeter.apache.org/demos/InterleaveTestPlan.jmx"&gt;下载&lt;/a&gt;此示例（参见图1）。在此示例中，我们将线程组配置为具有两个线程且循环次数为5，每个线程总共10个请求。请参阅下表，了解JMeter发送HTTP请求的顺序。&lt;/p&gt;
&lt;p&gt;&lt;img alt="Figure 1 - Interleave Controller Example 1" src="http://jmeter.apache.org/images/screenshots/logic-controller/interleave.png"&gt;&lt;br&gt;
&lt;em&gt;图1 - 交替控制器示例1&lt;/em&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align="left"&gt;循环迭代&lt;/th&gt;
&lt;th align="left"&gt;每个JMeter线程发送这些HTTP请求&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align="left"&gt;1&lt;/td&gt;
&lt;td align="left"&gt;News Page&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;1&lt;/td&gt;
&lt;td align="left"&gt;Log Page&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;2&lt;/td&gt;
&lt;td align="left"&gt;FAQ Page&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;2&lt;/td&gt;
&lt;td align="left"&gt;Log Page&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;3&lt;/td&gt;
&lt;td align="left"&gt;Gump Page&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;3&lt;/td&gt;
&lt;td align="left"&gt;Log Page&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;4&lt;/td&gt;
&lt;td align="left"&gt;因为控制器中没有更多请求，JMeter重新开始并发送第一个HTTP请求，即News Page&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;4&lt;/td&gt;
&lt;td align="left"&gt;Log Page&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;5&lt;/td&gt;
&lt;td align="left"&gt;FAQ Page&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;5&lt;/td&gt;
&lt;td align="left"&gt;Log Page&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4 id="_10"&gt;有用的交替示例&lt;/h4&gt;
&lt;p&gt;&lt;a href="http://jmeter.apache.org/demos/InterleaveTestPlan2.jmx"&gt;下载&lt;/a&gt;另一个示例（参见图2）。在此示例中，我们将线程组配置为具有1个线程且循环次数为8。请注意，测试计划有一个外部交替控制器，其下有两个交替控制器。&lt;/p&gt;
&lt;p&gt;&lt;img alt="Figure 2 - Interleave Controller Example 2 " src="http://jmeter.apache.org/images/screenshots/logic-controller/interleave2.png"&gt;
&lt;em&gt;图2 - 交替控制器示例2&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;外部交替控制器在两个内部控制器之间交替。然后，每个内部交替控制器在每个HTTP请求之间交替。每个JMeter线程将按以下顺序发送请求： Home Page，Interleaved，Bug Page，Interleaved，CVS Page，Interleaved，和FAQ Page，Interleaved。&lt;/p&gt;
&lt;p&gt;注意，File Reporter配置为将结果存储在当前目录中名为“&lt;code&gt;interleave-test2.dat&lt;/code&gt;”的文件中。&lt;/p&gt;
&lt;p&gt;&lt;img alt="         Figure 3 - Interleave Controller Example 3 " src="http://jmeter.apache.org/images/screenshots/logic-controller/interleave3.png"&gt;
&lt;em&gt;图3 - 交替控制器示例3&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;如果主交替控制器下的两个交替控制器是简单控制器，那么顺序将是：Home Page，CVS Page，Interleaved，Bug Page，FAQ Page，Interleaved。&lt;/p&gt;
&lt;p&gt;但是，如果在主交替控制器上选中了“&lt;code&gt;忽略子控制器块&lt;/code&gt;”，那么顺序将是：Home Page，Interleaved，Bug Page，Interleaved，CVS Page，Interleaved，和FAQ Page，Interleaved。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href="#toc"&gt;【返回目录】&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="_11"&gt;随机控制器&lt;/h3&gt;
&lt;p&gt;随机逻辑控制器的作用类似于交替控制器，不同之处在于它通过其子控制器和取样器时不是按排列顺序，而是在每次通过时随机选取一个。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;多个控制器之间的交互可以产生复杂的行为。随机控制器尤其如此。请在假设任何给定的交互产生的结果之前进行实验&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img alt="Screenshot for Control-Panel of Random Controller" src="http://jmeter.apache.org/images/screenshots/logic-controller/random-controller.png"&gt;&lt;br&gt;
&lt;em&gt;随机控制器控制面板的截图&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参数&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th align="left"&gt;是否必须&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;名称&lt;/td&gt;
&lt;td&gt;树中显示的此控制器的描述性名称。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;忽略子控制器块&lt;/td&gt;
&lt;td&gt;如果选中，交替控制器将把子控制器当作单个请求元件来处理，并且每个控制器一次只允许一个请求。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;a href="#toc"&gt;【返回目录】&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="_12"&gt;随机顺序控制器&lt;/h3&gt;
&lt;p&gt;随机顺序控制器很像简单控制器，因为它的每个子元件最多只执行一次，但节点的执行顺序是随机的。&lt;/p&gt;
&lt;p&gt;&lt;img alt="Screenshot for Control-Panel of Random Order Controller" src="http://jmeter.apache.org/images/screenshots/randomordercontroller.png"&gt;&lt;br&gt;
&lt;em&gt;随机顺序控制器控制面板的截图&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参数&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th align="left"&gt;是否必须&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;名称&lt;/td&gt;
&lt;td&gt;树中显示的此控制器的描述性名称。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;a href="#toc"&gt;【返回目录】&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="_13"&gt;吞吐量控制器&lt;/h3&gt;
&lt;p&gt;吞吐量控制器允许用户控制执行的频率。有两种模式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Percent executions&lt;/li&gt;
&lt;li&gt;Total executions&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;Percent executions&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;使控制器对测试计划执行一定比例的迭代。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Total executions&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;使控制器在执行了一定数量的执行后停止执行。&lt;/p&gt;
&lt;p&gt;与仅一次控制器一样，当父循环控制器重新启动时，此设置将被重置。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;该控制器的命名不太好，因为它不控制吞吐量。有关可用于调整吞吐量的元件，请参阅&lt;a href="http://jmeter.apache.org/usermanual/component_reference.html#Constant_Throughput_Timer"&gt;常数吞吐量定时器&lt;/a&gt;。 &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img alt="Screenshot for Control-Panel of Throughput Controller" src="http://jmeter.apache.org/images/screenshots/throughput_controller.png"&gt;&lt;br&gt;
&lt;em&gt;吞吐量控制器控制面板的截图&lt;/em&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;当与其他控制器结合使用时，吞吐量控制器会产生非常复杂的行为 - 特别是父项是交替或随机控制器的情况（也非常有用）。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;参数&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th align="left"&gt;是否必须&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;名称&lt;/td&gt;
&lt;td&gt;树中显示的此控制器的描述性名称。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;执行方式&lt;/td&gt;
&lt;td&gt;控制器是以Percent executions模式还是以Total executions模式运行。&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;吞吐量&lt;/td&gt;
&lt;td&gt;一个数字。对于Percent executions模式，&lt;code&gt;0&lt;/code&gt;到&lt;code&gt;100&lt;/code&gt;之间的数字表示控制器执行的次数百分比。“&lt;code&gt;50&lt;/code&gt;”表示控制器将在测试计划的一半迭代期间执行。对于Total executions模式，该数字表示控制器将执行的总次数。&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Per User&lt;/td&gt;
&lt;td&gt;如果选中，控制器的计算是在每个用户（每个线程）的基础上执行。如果未选中，则所有用户的计算都将是全局的。例如，如果使用Total executions模式，并取消选中“&lt;code&gt;per user&lt;/code&gt;”，则为吞吐量指定的数字将是执行的总执行次数。如果选中“&lt;code&gt;per user&lt;/code&gt;”，那么执行的总数将是用户数量乘以吞吐量的数量。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;a href="#toc"&gt;【返回目录】&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="runtime"&gt;Runtime控制器&lt;/h3&gt;
&lt;p&gt;Runtime控制器控制其子节点运行多长时间。控制器将运行其子项，直到超出配置的&lt;code&gt;Runtime(s)&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img alt="Screenshot for Control-Panel of Runtime Controller" src="http://jmeter.apache.org/images/screenshots/runtimecontroller.png"&gt;&lt;br&gt;
&lt;em&gt;Runtime控制器控制面板的截图&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参数&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th align="left"&gt;是否必须&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;名称&lt;/td&gt;
&lt;td&gt;树中显示的此控制器的描述性名称，同时用于命名事务。&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Runtime (seconds)&lt;/td&gt;
&lt;td&gt;期望的运行时间。0表示不运行。&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;a href="#toc"&gt;【返回目录】&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="if"&gt;如果（If）控制器&lt;/h3&gt;
&lt;p&gt;If控制器允许用户控制其下方的测试元件（其子元件）是否运行。&lt;/p&gt;
&lt;p&gt;默认情况下，条件仅在初始条目时计算一次，但您可以选择对控制器中包含的每个可运行元件进行计算。&lt;/p&gt;
&lt;p&gt;If控制器将在内部使用javascript来计算条件，但这会导致性能下降。&lt;/p&gt;
&lt;p&gt;&lt;img alt="If Controller using javascript" src="http://jmeter.apache.org/images/screenshots/if_controller_javascript.png"&gt;
&lt;em&gt;If控制器使用javascript&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;更好的选项（默认选项）是使用&lt;code&gt;Interpret Condition as Variable Expression?&lt;/code&gt;，然后在条件字段中，您有2个选项：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;选项1：使用包含&lt;code&gt;true&lt;/code&gt;或&lt;code&gt;false&lt;/code&gt;的变量&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如果要测试最后一个样本是否成功，可以使用&lt;code&gt;${JMeterThread.last_sample_ok}&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="If Controller using Variable" src="http://jmeter.apache.org/images/screenshots/if_controller_variable.png"&gt;
&lt;em&gt;If控制器使用变量&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;选项2：使用函数（建议使用&lt;code&gt;${__jexl3()}&lt;/code&gt;）来计算表达式，表达式必须返回&lt;code&gt;true&lt;/code&gt;或&lt;code&gt;false&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="If Controller using expression" src="http://jmeter.apache.org/images/screenshots/if_controller_expression.png"&gt;
&lt;em&gt;If控制器使用表达式&lt;/em&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;例如，以前可以使用条件：&lt;code&gt;${__jexl3(${VAR} == 23)}&lt;/code&gt;并将其评估为&lt;code&gt;true&lt;/code&gt;/&lt;code&gt;false&lt;/code&gt;，然后将结果传递给JavaScript，然后返回&lt;code&gt;true&lt;/code&gt;/&lt;code&gt;false&lt;/code&gt;。如果选择了Variable Expression选项，则会计算表达式并与“&lt;code&gt;true&lt;/code&gt;” 进行比较，而无需使用JavaScript。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;要测试变量是否未定义（或为null），请执行以下操作，假设变量名为&lt;code&gt;myVar&lt;/code&gt;，表达式如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;   &amp;quot;&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;myVar&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;&amp;quot; == &amp;quot;\&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;myVar&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;&amp;quot;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;或使用：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;   &amp;quot;&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;myVar&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;&amp;quot; != &amp;quot;\&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;myVar&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;&amp;quot;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;测试变量是否已定义且不为null。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img alt="Screenshot for Control-Panel of If Controller" src="http://jmeter.apache.org/images/screenshots/if_controller_expression.png"&gt;&lt;br&gt;
&lt;em&gt;IF控制器控制面板的截图&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参数&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th align="left"&gt;是否必须&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;名称&lt;/td&gt;
&lt;td&gt;树中显示的此控制器的描述性名称。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Condition (default JavaScript)&lt;/td&gt;
&lt;td&gt;默认情况下，条件按&lt;strong&gt;JavaScript&lt;/strong&gt;代码解析并返回“&lt;code&gt;true&lt;/code&gt;”或“&lt;code&gt;false&lt;/code&gt;”，但这可以被覆盖（见下文）&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Interpret Condition as Variable Expression?&lt;/td&gt;
&lt;td&gt;如果选中，则条件必须是计算结果为“&lt;code&gt;true&lt;/code&gt;”的表达式（忽略大小写）。例如，&lt;code&gt;${FOUND}&lt;/code&gt;或&lt;code&gt;${__jexl3(${VAR} &amp;gt; 100)}&lt;/code&gt;。与JavaScript情况不同，仅检查条件是否匹配“&lt;code&gt;true&lt;/code&gt;”（忽略大小写）。&lt;blockquote&gt;对于性能测试，建议在条件中使用&lt;a href="http://jmeter.apache.org/usermanual/functions.html#__jexl3"&gt;__jexl3&lt;/a&gt;或&lt;a href="http://jmeter.apache.org/usermanual/functions.html#__groovy"&gt;__groovy&lt;/a&gt;函数&lt;/blockquote&gt;&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Evaluate for all children&lt;/td&gt;
&lt;td&gt;是否应对所有子元件进行评估？如果未选中，则仅在输入时评估条件。&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;blockquote&gt;
&lt;h4 id="javascript"&gt;示例（JavaScript）&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;${COUNT} &amp;lt; 10&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;"${VAR}" == "abcd"&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果解析代码时出错，则假定条件判断为&lt;code&gt;false&lt;/code&gt;，并在&lt;code&gt;jmeter.log&lt;/code&gt;中记录消息。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注意，性能测试中建议避免使用JavaScript模式。&lt;/p&gt;
&lt;p&gt;使用&lt;a href="http://jmeter.apache.org/usermanual/functions.html#__groovy"&gt;__groovy&lt;/a&gt;时请注意不要在字符串中使用变量替换，因为使用更改脚本的变量会无法缓存。应该使用&lt;code&gt;vars.get("myVar")&lt;/code&gt;获取变量&lt;strong&gt;。&lt;/strong&gt; 请参阅下面的Groovy示例。  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id="_14"&gt;示例（变量表达式）&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;${__groovy(vars.get("myVar") != "Invalid" )}&lt;/code&gt; (Groovy检查myVar是否不等于Invalid)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;${__groovy(vars.get("myInt").toInteger() &amp;lt;=4 )}&lt;/code&gt; (Groovy 检查myInt是否小于或等于4)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;${__groovy(vars.get("myMissing") != null )}&lt;/code&gt; (Groovy 检查myMissing变量是否没有设置)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;${__jexl3(${COUNT} &amp;lt; 10)}&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;${RESULT}&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;${JMeterThread.last_sample_ok}&lt;/code&gt; (检查最后一个样本是否成功)&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href="#toc"&gt;【返回目录】&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="while"&gt;While控制器&lt;/h3&gt;
&lt;p&gt;While控制器运行其子项，直到条件为“&lt;code&gt;false&lt;/code&gt;”时停止。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;JMeter将循环索引公开为名为&lt;code&gt;__jm__&amp;lt;Name of your element&amp;gt;__idx&lt;/code&gt;的变量。因此，例如，如果您的While控制器名为WC，那么您可以通过&lt;code&gt;${__jm__WC__idx}&lt;/code&gt;访问循环索引。索引从0开始&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;可能的条件值：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;空白 - 当循环中的最后一个样本失败时退出循环&lt;/li&gt;
&lt;li&gt;&lt;code&gt;LAST&lt;/code&gt; - 当循环中的最后一个样本失败时退出循环。如果循环之前的最后一个样本失败，不进入循环。&lt;/li&gt;
&lt;li&gt;其他 - 当条件等于字符串“&lt;code&gt;false&lt;/code&gt;” 时退出（或不进入）循环&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;条件可以是最终计算为字符串“&lt;code&gt;false&lt;/code&gt;”的任何变量或函数。这允许根据需要使用&lt;a href="http://jmeter.apache.org/usermanual/functions.html#__jexl3"&gt;__jexl3&lt;/a&gt;，&lt;a href="http://jmeter.apache.org/usermanual/functions.html#__groovy"&gt;__groovy&lt;/a&gt;函数，属性或变量。&lt;/p&gt;
&lt;p&gt;请注意，条件被评估两次，一次是在开始采样子项之前，一次是在子项采样结束时，因此将非幂等函数放入Condition（如&lt;a href="http://jmeter.apache.org/usermanual/functions.html#__counter"&gt;__counter&lt;/a&gt;）可能会产生问题。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;${VAR}&lt;/code&gt; - 其他测试元件将&lt;code&gt;VAR&lt;/code&gt; 设置为false&lt;/li&gt;
&lt;li&gt;&lt;code&gt;${__jexl3(${C}==10)}&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;${__jexl3("${VAR2}"=="abcd")}&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;${_P(property)}&lt;/code&gt; - 其他某个地方将属性设置为"&lt;code&gt;false&lt;/code&gt;"&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="Screenshot for Control-Panel of While Controller" src="http://jmeter.apache.org/images/screenshots/whilecontroller.png"&gt;&lt;br&gt;
&lt;em&gt;While控制器控制面板的截图&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参数&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th align="left"&gt;是否必须&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;名称&lt;/td&gt;
&lt;td&gt;树中显示的此控制器的描述性名称。同时用于命名事务。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Condition&lt;/td&gt;
&lt;td&gt;空白，&lt;code&gt;LAST&lt;/code&gt;，或变量/函数&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;a href="#toc"&gt;【返回目录】&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="switch"&gt;Switch控制器&lt;/h3&gt;
&lt;p&gt;Switch控制器的作用类似于&lt;a href="http://jmeter.apache.org/usermanual/component_reference.html#Interleave_Controller"&gt;交替控制器&lt;/a&gt;，它在每次迭代时运行一个子元件，但控制器运行顺序不是按排列顺序，而是按switch value定义。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;switch value也可以是名称。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果switch value超出范围，它将运行第0个元件，这是数字情况的默认值。如果value为空字符串，它也是运行第0个元件。&lt;/p&gt;
&lt;p&gt;如果value为非数字（且非空），则Switch控制器将查找具有相同名称的元件（要考虑大小写）。如果没有匹配的名称，则选择名为“&lt;code&gt;default&lt;/code&gt;”（要考虑大小写）的元件。如果没有默认值，则不选择任何元件，并且控制器不会进行任何操作。&lt;/p&gt;
&lt;p&gt;&lt;img alt="Screenshot for Control-Panel of Switch Controller" src="http://jmeter.apache.org/images/screenshots/switchcontroller.png"&gt;&lt;br&gt;
&lt;em&gt;Switch控制器控制面板的截图&lt;/em&gt;  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参数&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th align="left"&gt;是否必须&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;名称&lt;/td&gt;
&lt;td&gt;树中显示的此控制器的描述性名称。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;em&gt;Switch Value&lt;/em&gt;&lt;/td&gt;
&lt;td&gt;要调用的从属元件的值（或名称）。元件从0开始编号。默认值为0&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;a href="#toc"&gt;【返回目录】&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="foreach"&gt;ForEach控制器&lt;/h3&gt;
&lt;p&gt;ForEach控制器循环遍历一组相关变量的值。将取样器（或控制器）添加到ForEach控制器时，每个取样器（或控制器）执行一次或多次，在每个循环期间变量会有新值。输入应包含多个变量，每个变量都用下划线和数字扩展。每个这样的变量都必须有一个值。因此，例如当输入变量的名称为&lt;code&gt;inputVar&lt;/code&gt;时，应该定义以下变量：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;inputVar_1 = wendy&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;inputVar_2 = charles&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;inputVar_3 = peter&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;inputVar_4 = john&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;注意：“&lt;code&gt;_&lt;/code&gt;”分隔符现在是可选的。&lt;/p&gt;
&lt;p&gt;当返回变量以“&lt;code&gt;returnVar&lt;/code&gt;” 给出时，ForEach控制器下的取样器和控制器的集合将连续执行&lt;code&gt;4&lt;/code&gt;次，返回变量具有相应的上述值，并且可以在取样器中使用。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;JMeter将循环索引公开为名为&lt;code&gt;__jm__&amp;lt;Name of your element&amp;gt;__idx&lt;/code&gt;的变量。因此，例如，如果您的循环控制器名为FEC，那么您可以通过&lt;code&gt;${__jm__FEC__idx}&lt;/code&gt;访问循环索引。索引从0开始&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;它特别适合与正则表达式后置处理器一起运行。这可以从先前请求的结果数据中“创建”必要的输入变量。通过省略“&lt;code&gt;_&lt;/code&gt;”分隔符，可以使用ForEach控制器通过输入变量&lt;code&gt;refName_g&lt;/code&gt;循环遍历组，并且还可以使用形如&lt;code&gt;refName_${C}_g&lt;/code&gt;的输入变量循环遍历所有匹配中的所有组，其中&lt;code&gt;C&lt;/code&gt;是计数器变量。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如果&lt;code&gt;inputVar_1&lt;/code&gt;值为&lt;code&gt;null&lt;/code&gt;，ForEach控制器不会执行任何取样。如果正则表达式没有返回匹配，则会出现这种情况。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img alt="Screenshot for Control-Panel of ForEach Controller" src="http://jmeter.apache.org/images/screenshots/logic-controller/foreach-controller.png"&gt;&lt;br&gt;
&lt;em&gt;ForEach控制器控制面板的截图&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参数&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th align="left"&gt;是否必须&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;名称&lt;/td&gt;
&lt;td&gt;树中显示的此控制器的描述性名称。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;输入变量前缀&lt;/td&gt;
&lt;td&gt;要用作输入的变量名称的前缀。默认为空字符串作为前缀。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;开始循环字段&lt;/td&gt;
&lt;td&gt;变量循环开始字段（独占）（第一个元件在起始索引+1）&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;结束循环字段&lt;/td&gt;
&lt;td&gt;循环变量的结束字段（包含）&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;输出变量名称&lt;/td&gt;
&lt;td&gt;变量的名称，可以用于循环中的取样器中的替换。默认为空变量名，很可能不需要。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;使用分隔符&lt;/td&gt;
&lt;td&gt;如果未选中，则忽略“&lt;code&gt;_&lt;/code&gt;”分隔符。&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;blockquote&gt;
&lt;h4 id="foreach_1"&gt;ForEach示例&lt;/h4&gt;
&lt;p&gt;&lt;a href="http://jmeter.apache.org/demos/forEachTestPlan.jmx"&gt;下载&lt;/a&gt;此示例（参见图7）。在此示例中，我们创建了一个测试计划，该计划仅发送一次特定的HTTP请求，并将另一个HTTP请求发送到页面上可找到的每个链接。&lt;/p&gt;
&lt;p&gt;&lt;img alt="Figure 7 - ForEach Controller Example" src="http://jmeter.apache.org/images/screenshots/logic-controller/foreach-example.png"&gt;&lt;br&gt;
&lt;em&gt;图7 - ForEach控制器示例&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;我们为单个线程配置了线程组，并将循环次数配置为1。您可以看到我们向线程组添加了一个HTTP请求，并向ForEach控制器添加了另一个HTTP请求。&lt;/p&gt;
&lt;p&gt;在第一个HTTP请求之后，添加了一个正则表达式提取器，它从返回页面中提取所有html链接并将它们放在&lt;code&gt;inputVar&lt;/code&gt;变量中&lt;/p&gt;
&lt;p&gt;在ForEach循环中，添加了一个HTTP取样器，它请求从第一个返回的HTML页面中提取的所有链接。&lt;/p&gt;
&lt;h4 id="foreach_2"&gt;ForEach示例&lt;/h4&gt;
&lt;p&gt;这是您可以下载的&lt;a href="http://jmeter.apache.org/demos/ForEachTest2.jmx"&gt;另一个示例&lt;/a&gt;。这有两个正则表达式和ForEach控制器。第一个正则有匹配，第二个没有匹配，因此第二个ForEach控制器不运行任何样本&lt;/p&gt;
&lt;p&gt;&lt;img alt="Figure 8 - ForEach Controller Example 2" src="http://jmeter.apache.org/images/screenshots/logic-controller/foreach-example2.png"&gt;&lt;br&gt;
&lt;em&gt;图8 - ForEach控制器示例2&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;线程组设置一个线程，循环次数为2。&lt;/p&gt;
&lt;p&gt;Sample 1使用JavaTest取样器返回字符串“&lt;code&gt;a b c d&lt;/code&gt;”。&lt;/p&gt;
&lt;p&gt;正则表达式提取器使用表达式&lt;code&gt;(\w)\s&lt;/code&gt;匹配一个字母后跟一个空格，并返回字母（而不是空格）。所有匹配都以字符串“&lt;code&gt;inputVar&lt;/code&gt;” 为前缀。&lt;/p&gt;
&lt;p&gt;ForEach控制器提取包含前缀“&lt;code&gt;inputVar_&lt;/code&gt;” 的所有变量，并执行其样本，传递变量“&lt;code&gt;returnVar&lt;/code&gt;”中的值。在这种情况下，它将依次将变量设置为值“&lt;code&gt;a&lt;/code&gt;” “&lt;code&gt;b&lt;/code&gt;”和“&lt;code&gt;c&lt;/code&gt;”。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;For 1&lt;/code&gt;是另一个Java取样，使用返回变量“&lt;code&gt;returnVar&lt;/code&gt;”作为样本标签的一部分，同时作为采样数据。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Sample 2&lt;/code&gt;，&lt;code&gt;Regex 2&lt;/code&gt;和&lt;code&gt;For 2&lt;/code&gt;几乎相同，只是正则表达式变成“&lt;code&gt;(\w)\sx&lt;/code&gt;”，这显然无法获得任何匹配。因此&lt;code&gt;For 2&lt;/code&gt;样本将不会运行。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href="#toc"&gt;【返回目录】&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="_15"&gt;模块控制器&lt;/h3&gt;
&lt;p&gt;模块控制器提供了一种在运行时将测试计划片段替换为当前测试计划的机制。&lt;/p&gt;
&lt;p&gt;测试计划片段由控制器和其中包含的所有测试元件（取样器等）组成。片段可以位于任何线程组中。如果片段位于线程组中，则可以禁用其控制器以防止片段在模块控制器以外运行。或者，您可以将片段存储在虚拟线程组中，并禁用整个线程组。&lt;/p&gt;
&lt;p&gt;可以有多个片段，每个片段下面都有不同系列的取样器。然后，只需在模块控制器的下拉框中选择适当的控制器即可在这些多个测试用例之间轻松切换。这为快速轻松地运行许多备用测试计划提供了便利。&lt;/p&gt;
&lt;p&gt;片段名称由控制器名称及其所有父名称组成。例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Test Plan / Protocol: JDBC / Control / Interleave Controller (Module1)
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;模块控制器使用的&lt;/strong&gt;任何&lt;strong&gt;片段都必须具有唯一的名称&lt;/strong&gt;，因为该名称用于在重新加载测试计划时查找目标控制器。因此，最好确保控制器名称不是默认值 - 如上例所示 - 否则在新元件添加到测试计划时可能会意外创建副本。&lt;/p&gt;
&lt;p&gt;&lt;img alt="Screenshot for Control-Panel of Module Controller" src="http://jmeter.apache.org/images/screenshots/module_controller.png"&gt;&lt;br&gt;
&lt;em&gt;模块控制器控制面板的截图&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参数&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th align="left"&gt;是否必须&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;名称&lt;/td&gt;
&lt;td&gt;树中显示的此控制器的描述性名称。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Module to Run&lt;/td&gt;
&lt;td&gt;模块控制器提供加载到gui中的所有控制器的列表。在运行时选择要替换的那个。&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;a href="#toc"&gt;【返回目录】&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="include"&gt;Include控制器&lt;/h3&gt;
&lt;p&gt;Include控制器旨在使用外部JMX文件。要使用它，在测试计划下创建一个测试片段，并在其下面添加任何所需的取样器，控制器等。然后保存测试计划。该文件现在可以作为其他测试计划的一部分包含在内。&lt;/p&gt;
&lt;p&gt;为方便起见，还可以在外部JMX文件中添加&lt;a href="http://jmeter.apache.org/usermanual/component_reference.html#Thread_Group"&gt;线程组&lt;/a&gt;以进行调试。&lt;a href="http://jmeter.apache.org/usermanual/component_reference.html#Module_Controller"&gt;模块控制器&lt;/a&gt;可用于引用试验片段。该&lt;a href="http://jmeter.apache.org/usermanual/component_reference.html#Thread_Group"&gt;线程组&lt;/a&gt;在include进程中将被忽略。&lt;/p&gt;
&lt;p&gt;如果测试使用Cookie管理器或用户定义的变量，则应将这些变量放在顶级测试计划中，而不是include的文件中，否则无法保证它们正常工作。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;此元件不支持文件名字段中的变量/函数。&lt;br&gt;
但是，如果定义了属性&lt;code&gt;includecontroller.prefix&lt;/code&gt;，则内容将用于路径名称的前缀。&lt;/p&gt;
&lt;p&gt;使用Include控制器并包含相同的JMX文件时，请确保Include控制器命名不同以避免遇到已知问题&lt;a href="https://bz.apache.org/bugzilla/show_bug.cgi?id=50898"&gt;Bug 50898&lt;/a&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果在&lt;code&gt;prefix&lt;/code&gt;+&lt;code&gt;Filename&lt;/code&gt;给定的位置找不到该文件，则控制器会尝试打开相对于JMX启动目录下的&lt;code&gt;Filename&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img alt="Screenshot for Control-Panel of Include Controller" src="http://jmeter.apache.org/images/screenshots/includecontroller.png"&gt;&lt;br&gt;
&lt;em&gt;Include控制器控制面板的截图&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参数&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th align="left"&gt;是否必须&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;名称&lt;/td&gt;
&lt;td&gt;树中显示的此控制器的描述性名称。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;文件名&lt;/td&gt;
&lt;td&gt;要包含的文件。&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;a href="#toc"&gt;【返回目录】&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="_16"&gt;事务控制器&lt;/h3&gt;
&lt;p&gt;事务控制器生成一个额外的样本，用于测量执行嵌套测试元件所花费的总时间。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注意：如果选中“&lt;code&gt;Include duration of timer and pre-post processors in generated sample&lt;/code&gt;”复选框，则时间包括控制器范围内的所有处理，而不仅仅是样本执行时间。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;有两种操作模式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;嵌套样本后添加额外的样本&lt;/li&gt;
&lt;li&gt;添加额外的样本作为嵌套样本的父级&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;生成的采样时间包括嵌套取样器的所有时间，默认情况下（从2.11开始）不包括定时器和前置/后置处理器执行时间，除非选中“&lt;code&gt;Include duration of timer and pre-post processors in generated sample&lt;/code&gt;”复选框。根据时钟精度，它可能略长于各个取样器加定时器的总和。在控制器记录开始时间之后但在第一个样本开始之前，时钟开始滴答。在最后也一样。&lt;/p&gt;
&lt;p&gt;仅当所有子样本都成功时，生成的样本才被视为成功。&lt;/p&gt;
&lt;p&gt;在父模式下，仍可以在查看结果树监听器中看到各个样本，但不再在其他监听器中显示为单独的条目。此外，子样本不会出现在CSV日志文件中，但可以保存到XML文件中。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在父模式下，可以将断言（等）添加到事务控制器中。但是，默认情况下，它们将同时应用于单个样本和整个事务样本。要限制断言的范围，请使用简单控制器来包含样本，并将断言添加到简单控制器。父模式控制器当前不能正确支持任何类型的嵌套事务控制器。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img alt="Screenshot for Control-Panel of Transaction Controller" src="http://jmeter.apache.org/images/screenshots/transactioncontroller.png"&gt;&lt;br&gt;
&lt;em&gt;事务控制器控制面板的截图&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参数&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th align="left"&gt;是否必须&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;名称&lt;/td&gt;
&lt;td&gt;树中显示的此控制器的描述性名称，用于命名事务。&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Generate Parent Sample&lt;/td&gt;
&lt;td&gt;如果选中，则生成样本作为其他样本的父项，否则样本将作为独立样本生成。&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Include duration of timer and pre-post processors in generated sample&lt;/td&gt;
&lt;td&gt;是否在生成的样本中包括定时器，前置和后置处理延迟。默认值为&lt;code&gt;false&lt;/code&gt;&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;a href="#toc"&gt;【返回目录】&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="_17"&gt;录制控制器&lt;/h3&gt;
&lt;p&gt;记录控制器是指示代理服务器录制样本位置的占位符。在测试运行期间，它没有任何效果，类似于简单控制器。但在使用&lt;a href="http://jmeter.apache.org/usermanual/component_reference.html#HTTP(S)_Test_Script_Recorder"&gt;HTTP代理服务器&lt;/a&gt;录制时，所有录制的样本将默认保存在录制控制器下。&lt;/p&gt;
&lt;p&gt;&lt;img alt="Screenshot for Control-Panel of Recording Controller" src="http://jmeter.apache.org/images/screenshots/logic-controller/recording-controller.png"&gt;&lt;br&gt;
&lt;em&gt;录制控制器控制面板的截图&lt;/em&gt;  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参数&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th align="left"&gt;是否必须&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;名称&lt;/td&gt;
&lt;td&gt;树中显示的此控制器的描述性名称。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;a href="#toc"&gt;【返回目录】&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="_18"&gt;临界部分控制器&lt;/h3&gt;
&lt;p&gt;临界部分控制器确保其子元件（取样器/控制器等）将仅由一个线程执行，在执行控制器的子节点之前将执行命名锁定。&lt;/p&gt;
&lt;p&gt;&lt;img alt="Screenshot for Control-Panel of Critical Section Controller" src="http://jmeter.apache.org/images/screenshots/logic-controller/critical-section-controller.png"&gt;&lt;br&gt;
&lt;em&gt;临界部分控制器控制面板的截图&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;下图显示了使用临界部分控制器的示例，如下图所示2个临界部分控制器用来确保：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;DS2-${__threadNum}&lt;/code&gt;一次只能由一个线程执行&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;DS4-${__threadNum}&lt;/code&gt;一次只能由一个线程执行&lt;/p&gt;
&lt;p&gt;&lt;img alt="Test Plan using Critical Section Controller" src="http://jmeter.apache.org/images/screenshots/logic-controller/critical-section-controller-tp.png"&gt;&lt;br&gt;
&lt;em&gt;使用临界部分控制器的测试计划&lt;/em&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;参数&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th align="left"&gt;是否必须&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;名称&lt;/td&gt;
&lt;td&gt;树中显示的此控制器的描述性名称。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;锁名称&lt;/td&gt;
&lt;td&gt;锁定将由控制器执行，确保为不相关的部分使用不同的锁名称&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;blockquote&gt;
&lt;p&gt;临界部分控制器仅在一个JVM中获取锁，因此如果使用分布式测试，请确保您的用例不依赖于所有JVM阻塞的所有线程。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href="#toc"&gt;【返回目录】&lt;/a&gt;&lt;/p&gt;
&lt;h2 id="183"&gt;18.3 监听器&lt;/h2&gt;
&lt;p&gt;除了“监听”测试结果之外，大多数监听器扮演多种角色。它们还提供查看，保存和读取已保存测试结果的方法。&lt;/p&gt;
&lt;p&gt;注意，监听器在找到它们的范围的最后处理。&lt;/p&gt;
&lt;p&gt;测试结果的保存和读取是通用功能。各种监听器都有一个面板，用户可以指定要写入（或读取）结果的文件。默认情况下，结果存储为XML文件，通常带有“&lt;code&gt;.jtl&lt;/code&gt;”扩展名。存储为CSV是最有效的选项，但不如XML（另一个可用选项）详细。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;监听器不处理在CLI模式下的取样数据，但是，如果配置了输出文件，原始数据将被保存。&lt;/strong&gt;为了分析CLI运行生成的数据，您需要将文件加载到相应的监听器中。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;要读取现有结果并显示它们，请使用文件面板的浏览按钮打开该文件。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果要在加载新文件之前清除所有当前数据，请在加载文件之前使用菜单项&lt;em&gt;“运行”&lt;/em&gt;→&lt;em&gt;“清除”&lt;/em&gt; （&lt;code&gt;Ctrl&lt;/code&gt;+&lt;code&gt;Shift&lt;/code&gt;+&lt;code&gt;E&lt;/code&gt;） 或&lt;em&gt;“运行”&lt;/em&gt;→“&lt;em&gt;清除全部”&lt;/em&gt; （&lt;code&gt;Ctrl&lt;/code&gt;+&lt;code&gt;E&lt;/code&gt;） 。&lt;/p&gt;
&lt;p&gt;可以从XML或CSV格式文件中读取结果。从CSV结果文件中读取时，标题（如果存在）用于确定存在哪些字段。&lt;strong&gt;为了正确解析无标题的CSV文件，必须在&lt;code&gt;jmeter.properties&lt;/code&gt;中设置相应的属性。&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;JMeter编写的XML文件在头文件中声明版本1.0，而实际文件使用1.1规则序列化。（这样做是出于历史兼容性原因；请参阅&lt;a href="https://bz.apache.org/bugzilla/show_bug.cgi?id=59973"&gt;Bug 59973&lt;/a&gt;和&lt;a href="https://bz.apache.org/bugzilla/show_bug.cgi?id=58679"&gt;Bug 58679&lt;/a&gt;）这会导致严格的XML解析器失败。考虑使用非严格的XML解析器来读取JTL文件。&lt;/p&gt;
&lt;p&gt;文件名可以包含函数和/或变量引用。但是，变量引用在客户端 - 服务器模式下不起作用（函数可以正常工作）。这是因为文件是在客户端上创建的，而客户端不在本地运行测试，因此不会设置变量。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;如果有大量样本，监听器会使用大量内存。&lt;/strong&gt;目前大多数监听器都在其范围内拷贝每个样本的副本，下列监听器除外：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;简单数据写入器&lt;/li&gt;
&lt;li&gt;BeanShell/JSR223监听器&lt;/li&gt;
&lt;li&gt;邮件观察器&lt;/li&gt;
&lt;li&gt;汇总报告&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以下监听器不再需要保存每个样本的副本。相反，聚合具有相同经过时间的样本。现在需要更少的内存，特别是如果大多数样本只需要一两秒钟。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;聚合报告&lt;/li&gt;
&lt;li&gt;汇总图&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;要最小化所需的内存量，请使用简单数据写入器，并使用CSV格式。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;JMeter变量可以保存到输出文件中。这只能使用属性指定。有关详细信息， 请参阅&lt;a href="http://jmeter.apache.org/usermanual/listeners.html#sample_variables"&gt;监听器样本变量&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;有关设置要保存的默认项的完整详细信息，请参阅&lt;a href="http://jmeter.apache.org/usermanual/listeners.html#defaults"&gt;监听器默认配置&lt;/a&gt;文档。有关输出文件内容的详细信息，请参阅&lt;a href="http://jmeter.apache.org/usermanual/listeners.html#csvlogformat"&gt;CSV日志&lt;/a&gt;格式或&lt;a href="http://jmeter.apache.org/usermanual/listeners.html#xmlformat2.1"&gt;XML日志&lt;/a&gt;格式。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;jmeter.properties&lt;/code&gt;中的条目用于定义默认值；可以使用“配置”按钮为单个监听器重写这些内容，如下所示。&lt;code&gt;jmeter.properties&lt;/code&gt;中的设置也适用于使用命令行标志&lt;code&gt;-l&lt;/code&gt;添加的监听器。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;下图显示了结果文件配置面板的示例&lt;/p&gt;
&lt;p&gt;&lt;img alt="Result file configuration panel" src="http://jmeter.apache.org/images/screenshots/simpledatawriter.png"&gt;&lt;br&gt;
&lt;em&gt;结果文件配置面板&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参数&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th align="left"&gt;是否必须&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;名称&lt;/td&gt;
&lt;td&gt;树中显示的此元件的描述性名称。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;文件名&lt;/td&gt;
&lt;td&gt;包含样本结果的文件的名称。可以使用相对路径名或绝对路径名指定文件名。相对路径相对于当前工作目录（默认为&lt;code&gt;bin/&lt;/code&gt;目录）进行解析。JMeter还支持相对于包含当前测试计划（JMX文件）的目录的路径。如果路径名以“&lt;code&gt;〜/&lt;/code&gt;”（或JMeter&lt;code&gt;jmeter.save.saveservice.base_prefix&lt;/code&gt;属性中的任何内容）开头，则假定路径相对于JMX文件位置。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;浏览...&lt;/td&gt;
&lt;td&gt;文件浏览按钮&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;仅错误日志&lt;/td&gt;
&lt;td&gt;选择此选项可以写入/只读错误的结果&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;仅成功日志&lt;/td&gt;
&lt;td&gt;选择此选项可以写入/读取没有错误的结果。如果未选择“&lt;code&gt;仅错误日志&lt;/code&gt;”或“&lt;code&gt;仅成功日志&lt;/code&gt;”，则处理所有结果。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;配置&lt;/td&gt;
&lt;td&gt;配置按钮，见下文&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id="_19"&gt;样本结果保存配置&lt;/h3&gt;
&lt;p&gt;监听器可以通过配置弹窗将不同的选项保存到结果日志文件（JTL），如下所示。默认值的定义如&lt;a href="http://jmeter.apache.org/usermanual/listeners.html#defaults"&gt;监听器默认配置&lt;/a&gt;文档中所述。后面带有（&lt;code&gt;CSV&lt;/code&gt;）的选项仅适用于CSV格式；带有（&lt;code&gt;XML&lt;/code&gt;）的选项仅适用于XML格式。目前CSV格式无法用于保存包含换行符的任何选项。&lt;/p&gt;
&lt;p&gt;注意，cookie、方法和查询字符串将保存为“&lt;code&gt;Sampler Data&lt;/code&gt;”选项的一部分。&lt;/p&gt;
&lt;p&gt;&lt;img alt="Screenshot for Control-Panel of Sample Result Save Configuration" src="http://jmeter.apache.org/images/screenshots/sample_result_config.png"&gt;&lt;br&gt;
&lt;em&gt;样本结果保存配置控制面板的截图&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="#toc"&gt;【返回目录】&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="_20"&gt;图形结果&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;在压力测试期间不得使用图形结果，因为它消耗了大量资源（内存和CPU）。仅用于功能测试或测试计划调试和验证期间。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;图形结果监听器生成一个简单的图形，用于绘制所有取样时间。沿着图的底部，以毫秒为单位显示当前样本（黑色），所有样本的当前平均值（蓝色），当前标准差（红色）和当前吞吐量（绿色）。&lt;/p&gt;
&lt;p&gt;吞吐量数字表示服务器处理的实际请求数/分钟数。此计算包括您添加到测试中的任何延迟以及JMeter自身的内部处理时间。像这样进行计算的优点是这个数字代表了一些真实的东西 - 你的服务器实际上每分钟处理了多少请求，你可以增加线程数和/或减少延迟来发现服务器的最大吞吐量。然而，如果您的计算考虑了延迟和JMeter的处理时间，那么您可能不清楚从该数字可以得出什么结论。&lt;/p&gt;
&lt;p&gt;&lt;img alt="Screenshot for Control-Panel of Graph Results" src="http://jmeter.apache.org/images/screenshots/graph_results.png"&gt;&lt;br&gt;
&lt;em&gt;图形结果控制面板的截图&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;下表简要介绍了图表中的项目。关于统计术语的确切含义的更多细节可以在网上找到 - 例如维基百科 - 或者查阅统计书。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;数据&lt;/code&gt; - 绘制实际数据值&lt;/li&gt;
&lt;li&gt;&lt;code&gt;平均值&lt;/code&gt; - 绘制平均值&lt;/li&gt;
&lt;li&gt;&lt;code&gt;中值&lt;/code&gt; - 绘制&lt;a href="http://jmeter.apache.org/usermanual/glossary.html#Median"&gt;中位数&lt;/a&gt;（中间值）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;偏离&lt;/code&gt; - 绘制&lt;a href="http://jmeter.apache.org/usermanual/glossary.html#StandardDeviation"&gt;标准差&lt;/a&gt;（衡量变化的一种方法）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;吞吐量&lt;/code&gt; - 绘制每单位时间的样本数&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;显示屏底部的各个数字是当前值。“&lt;code&gt;最新样本&lt;/code&gt;”是当前经过的采样时间，在图表上显示为“&lt;code&gt;数据&lt;/code&gt;”。&lt;/p&gt;
&lt;p&gt;图表左上角显示的值是响应时间第90百分位数的最大值。&lt;/p&gt;
&lt;p&gt;&lt;a href="#toc"&gt;【返回目录】&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="_21"&gt;断言结果&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;在压力测试期间不得使用断言结果，因为它消耗了大量资源（内存和CPU）。仅用于功能测试或测试计划调试和验证期间。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;断言结果可视化器显示每个样本的标签。它还报告了作为测试计划一部分的任何&lt;a href="http://jmeter.apache.org/usermanual/test_plan.html#assertions"&gt;断言&lt;/a&gt;的失败。&lt;/p&gt;
&lt;p&gt;&lt;img alt="Screenshot for Control-Panel of Assertion Results" src="http://jmeter.apache.org/images/screenshots/assertion_results.png"&gt;&lt;br&gt;
&lt;em&gt;断言结果控制面板的截图&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;另请参阅：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://jmeter.apache.org/usermanual/component_reference.html#Response_Assertion"&gt;响应断言&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href="#toc"&gt;【返回目录】&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="_22"&gt;查看结果树&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;在压力测试期间不得使用查看结果树，因为它消耗了大量资源（内存和CPU）。仅用于功能测试或测试计划调试和验证期间。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;查看结果树是一个显示所有样本响应的树，允许您查看任何样本的响应。除了显示响应之外，您还可以看到获得此响应所花费的时间以及一些响应代码。注意请求面板仅显示JMeter添加的信息头。它不显示可由HTTP协议实现添加的任何信息头（例如&lt;code&gt;Host&lt;/code&gt;）。&lt;/p&gt;
&lt;p&gt;有几种方法可以查看响应，可以通过左侧面板底部的下拉框进行选择。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align="left"&gt;&lt;strong&gt;渲染&lt;/strong&gt;&lt;/th&gt;
&lt;th align="left"&gt;&lt;strong&gt;描述&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align="left"&gt;&lt;code&gt;CSS/JQuery Tester&lt;/code&gt;&lt;/td&gt;
&lt;td align="left"&gt;&lt;em&gt;CSS/JQuery测试&lt;/em&gt;只适用于文本响应。它在上面板中显示纯文本。“&lt;code&gt;测试&lt;/code&gt;”按钮允许用户将CSS/JQuery表达式应用于上面板，结果将显示在下面板中。&lt;br /&gt;CSS / JQuery表达式引擎可以是JSoup或Jodd，二者实现的语法略有不同。 &lt;br /&gt;例如，应用于当前JMeter函数页面的具有&lt;code&gt;href&lt;/code&gt;属性的选择器&lt;code&gt;a[class=sectionlink]&lt;/code&gt;将给出以下输出：&lt;pre&gt;&lt;code&gt;Match count: 74&lt;/code&gt;&lt;br /&gt;&lt;code&gt;Match[1]=#functions&lt;/code&gt;&lt;br /&gt;&lt;code&gt;Match[2]=#what_can_do&lt;/code&gt;&lt;br /&gt;&lt;code&gt;Match[3]=#where&lt;/code&gt;&lt;br /&gt;&lt;code&gt;Match[4]=#how&lt;/code&gt;&lt;br /&gt;&lt;code&gt;Match[5]=#function_helper&lt;/code&gt;&lt;br /&gt;&lt;code&gt;Match[6]=#functions&lt;/code&gt;&lt;br /&gt;&lt;code&gt;Match[7]=#__regexFunction&lt;/code&gt;&lt;br /&gt;&lt;code&gt;Match[8]=#__regexFunction_parms&lt;/code&gt;&lt;br /&gt;&lt;code&gt;Match[9]=#__counter&lt;/code&gt;&lt;br /&gt;&lt;code&gt;… and so on …&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;&lt;code&gt;Document&lt;/code&gt;&lt;/td&gt;
&lt;td align="left"&gt;&lt;em&gt;Document视图&lt;/em&gt;将显示各种类型文档，如Microsoft Office（Word，Excel和PowerPoint 97-2003，2007-2010（OPENXML），Apache OpenOffice（writer, calc, impress），HTML，gzip，JAR/ZIP文件（内容列表）中提取的文本，以及“多媒体”文件的一些元数据，如mp3，mp4，flv等。支持格式的完整列表可在&lt;a href="http://tika.apache.org/1.2/formats.html"&gt;Apache Tika格式页面&lt;/a&gt;上找到。&lt;blockquote&gt;&lt;code&gt;Document视图&lt;/code&gt;需要下载&lt;a href="http://tika.apache.org/download.html"&gt; Apache Tika二进制包&lt;/a&gt;（&lt;code&gt;tika-app-xxjar&lt;/code&gt;）并将其放在&lt;code&gt;JMETER_HOME/lib&lt;/code&gt;目录中。&lt;/blockquote&gt;如果文档大于10MB，则不会显示。要更改此限制，请设置JMeter属性&lt;code&gt;document.max_size&lt;/code&gt;（单位为byte）或设置为&lt;code&gt;0&lt;/code&gt;以移除限制。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;&lt;code&gt;HTML&lt;/code&gt;&lt;/td&gt;
&lt;td align="left"&gt;&lt;em&gt;HTML视图&lt;/em&gt;试图将响应渲染为HTML。渲染的HTML可能与其他Web浏览器中的视图相比较差；但是，它确实提供了快速近似，有助于初始结果评估。&lt;br /&gt; 不下载图像，样式表等。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;&lt;code&gt;HTML (download resources)&lt;/code&gt;&lt;/td&gt;
&lt;td align="left"&gt;如果选择了&lt;em&gt;HTML(download resources)视图&lt;/em&gt;选项，则渲染器可以下载HTML代码引用的图像，样式表等。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;&lt;code&gt;HTML Source formatted&lt;/code&gt;&lt;/td&gt;
&lt;td align="left"&gt;如果选择了&lt;em&gt;HTML Source formatted视图&lt;/em&gt;选项，则渲染器将显示由&lt;a href="https://jsoup.org/"&gt;Jsoup&lt;/a&gt;格式化和整理的HTML源代码。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;&lt;code&gt;JSON&lt;/code&gt;&lt;/td&gt;
&lt;td align="left"&gt;&lt;em&gt;JSON视图&lt;/em&gt;将显示树风格的响应（也处理内含JSON的JavaScript响应）。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;&lt;code&gt;JSON Path Tester&lt;/code&gt;&lt;/td&gt;
&lt;td align="left"&gt;&lt;em&gt;JSON Path Tester视图&lt;/em&gt;允许您测试JSON-路径表达式，并从一个特定的响应看到所提取的数据。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;&lt;code&gt;Regexp Tester&lt;/code&gt;&lt;/td&gt;
&lt;td align="left"&gt;&lt;em&gt;Regexp Tester视图&lt;/em&gt;仅适用于文本响应。它在上面板中显示纯文本。“&lt;code&gt;Test&lt;/code&gt;”按钮允许用户将正则表达式应用于上面板，结果将显示在下面板中。 &lt;br /&gt;正则表达式引擎与正则表达式提取器中使用的引擎相同。 &lt;br /&gt;例如，应用于当前JMeter主页的正则表达式&lt;code&gt;(JMeter\w*).*&lt;/code&gt;提供以下输出：&lt;pre&gt;&lt;code&gt;Match count: 26&lt;/code&gt;&lt;br /&gt;&lt;code&gt;Match[1][0]=JMeter - Apache JMeter&lt;/title&gt;&lt;/code&gt;&lt;br /&gt;&lt;code&gt;Match[1][1]=JMeter&lt;/code&gt;&lt;br /&gt;&lt;code&gt;Match[2][0]=JMeter" title="JMeter" border="0"/&amp;gt;&lt;/a&gt;&lt;/code&gt;&lt;br /&gt;&lt;code&gt;Match[2][1]=JMeter&lt;/code&gt;&lt;br /&gt;&lt;code&gt;Match[3][0]=JMeterCommitters"&amp;gt;Contributors&lt;/a&gt;&lt;/code&gt;&lt;br /&gt;&lt;code&gt;Match[3][1]=JMeterCommitters&lt;/code&gt;&lt;br /&gt;&lt;code&gt;… and so on …&lt;/code&gt;&lt;/pre&gt;&lt;code&gt;[]&lt;/code&gt;中的第一个数字是匹配号码；第二个数字是其所在分组。组&lt;code&gt;[0]&lt;/code&gt;是与整个正则表达式匹配的。组&lt;code&gt;[1]&lt;/code&gt;是与第1组相匹配的，即在这种情况下的&lt;code&gt;(JMeter\w*)&lt;/code&gt;。见图9b（下图）。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;&lt;code&gt;Text&lt;/code&gt;&lt;/td&gt;
&lt;td align="left"&gt;默认的&lt;em&gt;Text视图&lt;/em&gt;显示响应中包含的所有文本。注意这仅在响应&lt;code&gt;content-type&lt;/code&gt;被视为文本时才有效。如果&lt;code&gt;content-type&lt;/code&gt;以下列任何一个开头，则将其视为二进制文件，否则将其视为文本。&lt;pre&gt;&lt;code&gt;image/&lt;/code&gt;&lt;br /&gt;&lt;code&gt;audio/&lt;/code&gt;&lt;br /&gt;&lt;code&gt;video/&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;&lt;code&gt;XML&lt;/code&gt;&lt;/td&gt;
&lt;td align="left"&gt;&lt;em&gt;XML视图&lt;/em&gt;将显示树风格的响应。任何DTD节点或Prolog节点都不会显示在树中；但是，响应可能包含那些节点。您可以右键单击任何节点，然后展开或折叠其下的所有节点。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;&lt;code&gt;XPath Tester&lt;/code&gt;&lt;/td&gt;
&lt;td align="left"&gt;&lt;em&gt;XPath Tester&lt;/em&gt;只适用于文本响应。它在上面板中显示纯文本。“&lt;code&gt;Test&lt;/code&gt;”按钮允许用户将XPath查询应用于上面板，结果将显示在下面板中。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;&lt;code&gt;边界提取器测试&lt;/code&gt;&lt;/td&gt;
&lt;td align="left"&gt;&lt;em&gt;边界提取器测试&lt;/em&gt;只适用于文本响应。它在上面板中显示纯文本。“&lt;code&gt;测试&lt;/code&gt;”按钮允许用户将边界提取器查询应用于上面板，结果将显示在下面板中。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;code&gt;Scroll automatically?&lt;/code&gt;选项允许在树选择中显示最后一个节点&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;从版本3.2开始，视图中的条目数限制为属性&lt;code&gt;view.results.tree.max_results&lt;/code&gt;的值，默认为&lt;code&gt;500&lt;/code&gt;个条目。通过将属性设置为&lt;code&gt;0&lt;/code&gt;可以恢复旧行为。请注意，这可能会占用大量内存。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;通过“&lt;code&gt;查找&lt;/code&gt;”选项，大多数视图还允许查找显示的数据；查询结果将在上面板中高亮显示。例如，下面的控制面板截图显示了查找“&lt;code&gt;Java&lt;/code&gt;”的一个结果。注意搜索仅对可见文本进行操作，因此在搜索文本和HTML视图时可能会得到不同的结果。 &lt;br&gt;
注意：正则表达式使用Java引擎（不是正则表达式提取器或Regexp Tester视图使用的ORO引擎）。&lt;/p&gt;
&lt;p&gt;如果未提供&lt;code&gt;content-type&lt;/code&gt;，则内容将不会显示在任何响应数据面板中。在这种情况下，您可以使用&lt;a href="http://jmeter.apache.org/usermanual/component_reference.html#Save_Responses_to_a_file"&gt;保存响应到文件&lt;/a&gt;来保存数据。注意，响应数据在样本结果中仍然可用，因此可使用后置处理器进行访问。&lt;/p&gt;
&lt;p&gt;如果响应数据大于200K，则不会显示。要更改此限制，请设置JMeter属性&lt;code&gt;view.results.tree.max_size&lt;/code&gt;。您还可以使用&lt;a href="http://jmeter.apache.org/usermanual/component_reference.html#Save_Responses_to_a_file"&gt;保存响应到文件&lt;/a&gt;来保存整个响应。&lt;/p&gt;
&lt;p&gt;可以创建其他渲染器。该类必须实现接口&lt;code&gt;org.apache.jmeter.visualizers.ResultRenderer&lt;/code&gt;和/或扩展抽象类&lt;code&gt;org.apache.jmeter.visualizers.SamplerResultTab&lt;/code&gt;，并且编译的代码必须可用于JMeter（例如，通过将其添加到&lt;code&gt;lib/ext&lt;/code&gt;目录）。&lt;/p&gt;
&lt;p&gt;&lt;img alt="Screenshot for Control-Panel of View Results Tree" src="http://jmeter.apache.org/images/screenshots/view_results_tree.png"&gt;&lt;br&gt;
&lt;em&gt;查看结果树控制面板的截图&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;上图控制面板是HTML显示的示例。
图9（下图）是XML显示的示例。
图9a（下图）是Regexp tester显示的示例。
图9b（下图）是Document显示的示例。&lt;/p&gt;
&lt;p&gt;&lt;img alt="Figure 9 Sample XML display" src="http://jmeter.apache.org/images/screenshots/view_results_tree_xml.png"&gt;
&lt;em&gt;图9 - XML样本显示&lt;/em&gt;  &lt;/p&gt;
&lt;p&gt;&lt;img alt="Figure 9a Sample Regexp Test display" src="http://jmeter.apache.org/images/screenshots/view_results_tree_regex.png"&gt;
&lt;em&gt;图9a - Regexp Tester样本显示&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="Figure 9b Sample Document (here PDF) display" src="http://jmeter.apache.org/images/screenshots/view_results_tree_document.png"&gt;
&lt;em&gt;图9b - Document（此处为PDF）样本显示&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="#toc"&gt;【返回目录】&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="_23"&gt;聚合报告&lt;/h3&gt;
&lt;p&gt;聚合报告为测试中的每个不同命名的请求创建一个表行。对于每个请求，它总计响应信息并提供请求计数，最小值，最大值，平均值，异常率，近似吞吐量（请求/秒）和每秒千字节吞吐量。测试完成后，吞吐量是整个测试期间的实际吞吐量。&lt;/p&gt;
&lt;p&gt;吞吐量是从取样器目标（例如，HTTP样本的远程服务器）的角度计算的。JMeter考虑了生成请求的总时间。如果其他取样器和定时器位于同一线程中，则会增加总时间，从而降低吞吐量值。因此，具有不同名称的两个相同的取样器将具有两个具有相同名称的取样器的吞吐量的一半。正确选择取样器名称以从聚合报告中获得最佳结果非常重要。&lt;/p&gt;
&lt;p&gt;计算&lt;a href="http://jmeter.apache.org/usermanual/glossary.html#Median"&gt;中位数&lt;/a&gt;和90％线（第90&lt;a href="http://jmeter.apache.org/usermanual/glossary.html#Percentile"&gt;百分位数&lt;/a&gt;）值需要额外的内存。JMeter现在将相同经过时间的样本相结合，因此使用的内存更少。但是，对于花费时间超过几秒的样本，或者另一种可能性是很少的样本具有相同的时间，在这种情况下需要更多的内存。注意您可以使用此监听器在测试结束后重新加载CSV或XML结果文件，这是避免性能影响的推荐方法。请参阅&lt;a href="http://jmeter.apache.org/usermanual/component_reference.html#Summary_Report"&gt;汇总报告&lt;/a&gt;了解类似的监听器，它不存储单个样本，因此需要恒定的内存。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;从JMeter 2.12开始，您可以通过设置属性来配置要计算的3个百分位值：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;aggregate_rpt_pct1&lt;/code&gt;：默认为第90&lt;a href="http://jmeter.apache.org/usermanual/glossary.html#Percentile"&gt;百分位数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;aggregate_rpt_pct2&lt;/code&gt;：默认为第95&lt;a href="http://jmeter.apache.org/usermanual/glossary.html#Percentile"&gt;百分位数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;aggregate_rpt_pct3&lt;/code&gt;：默认为第99&lt;a href="http://jmeter.apache.org/usermanual/glossary.html#Percentile"&gt;百分位数&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Label&lt;/code&gt; - 样本的标签。如果选择“&lt;code&gt;在标签中包含组名称？&lt;/code&gt;”，则会添加线程组的名称作为前缀。这允许来自不同线程组的相同标签根据需要被单独整理。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;# 样本&lt;/code&gt; - 具有相同标签的样本数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;平均值&lt;/code&gt; - 一组结果的平均时间&lt;/li&gt;
&lt;li&gt;&lt;code&gt;中位数&lt;/code&gt; - &lt;a href="http://jmeter.apache.org/usermanual/glossary.html#Median"&gt;中位数&lt;/a&gt;是一组结果中间的时间。50％的样本不超过这个时间；其余的至少花了这么长时间。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;90％百分位&lt;/code&gt; - 90％的样本不超过这个时间。剩下的样本至少花了这么长时间。（第90&lt;a href="http://jmeter.apache.org/usermanual/glossary.html#Percentile"&gt;百分位数&lt;/a&gt;）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;95％百分位&lt;/code&gt; - 95％的样本不超过这个时间。剩下的样本至少花了这么长时间。（第95&lt;a href="http://jmeter.apache.org/usermanual/glossary.html#Percentile"&gt;百分位数&lt;/a&gt;）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;99％百分位&lt;/code&gt; - 99％的样本不超过这个时间。剩下的样本至少花了这么长时间。（第99&lt;a href="http://jmeter.apache.org/usermanual/glossary.html#Percentile"&gt;百分位数&lt;/a&gt;）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;最小值&lt;/code&gt; - 具有相同标签的样本的最短时间&lt;/li&gt;
&lt;li&gt;&lt;code&gt;最大值&lt;/code&gt; - 具有相同标签的样本的最长时间&lt;/li&gt;
&lt;li&gt;&lt;code&gt;异常 ％&lt;/code&gt; - 异常请求的百分比&lt;/li&gt;
&lt;li&gt;&lt;code&gt;吞吐量&lt;/code&gt; - &lt;a href="http://jmeter.apache.org/usermanual/glossary.html#Throughput"&gt;吞吐量&lt;/a&gt;以每秒/分钟/小时的请求来衡量。时间的单位会自动选择，使显示的速率至少为1.0。当吞吐量保存到CSV文件时，它以请求/秒表示，即30.0请求/分钟保存为0.5。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;接收 KB/sec&lt;/code&gt; - 以每秒收到的千字节为单位测量的吞吐量&lt;/li&gt;
&lt;li&gt;&lt;code&gt;发送 KB/sec&lt;/code&gt; - 以每秒发送的千字节为单位测量的吞吐量&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;时间以毫秒为单位。&lt;/p&gt;
&lt;p&gt;&lt;img alt="Screenshot for Control-Panel of Aggregate Report" src="http://jmeter.apache.org/images/screenshots/aggregate_report.png"&gt;&lt;br&gt;
&lt;em&gt;聚合报告控制面板的截图&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;下图显示了选择“&lt;code&gt;在标签中包含组名称？&lt;/code&gt;”复选框的示例。&lt;/p&gt;
&lt;p&gt;&lt;img alt="Sample &amp;quot;" src="http://jmeter.apache.org/images/screenshots/aggregate_report_grouped.png"&gt;
&lt;em&gt;“&lt;code&gt;在标签中包含组名称？&lt;/code&gt;”样本显示&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="#toc"&gt;【返回目录】&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="_24"&gt;用表格查看结果&lt;/h3&gt;
&lt;p&gt;此可视化工具为每个样本结果创建一行。像&lt;a href="http://jmeter.apache.org/usermanual/component_reference.html#View_Results_Tree"&gt;查看结果树&lt;/a&gt;一样，此可视化工具使用大量内存。&lt;/p&gt;
&lt;p&gt;默认情况下，它只显示主（父）样本；它不显示子样本。JMeter有一个“&lt;code&gt;Child Samples?&lt;/code&gt;”复选框。如果选择此选项，则显示子样本而不是主样本。&lt;/p&gt;
&lt;p&gt;&lt;img alt="Screenshot for Control-Panel of View Results in Table" src="http://jmeter.apache.org/images/screenshots/table_results.png"&gt;&lt;br&gt;
&lt;em&gt;用表格查看结果控制面板的截图&lt;/em&gt;  &lt;/p&gt;
&lt;p&gt;&lt;a href="#toc"&gt;【返回目录】&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="_25"&gt;简单数据写入器&lt;/h3&gt;
&lt;p&gt;此监听器可以将结果记录到文件中，但不能记录到UI。它旨在通过消除GUI开销来提供记录数据的有效方法。在CLI模式下运行时，&lt;code&gt;-l&lt;/code&gt;标志可用于创建数据文件。要保存的字段由JMeter属性定义。有关详细信息，请参阅&lt;code&gt;jmeter.properties&lt;/code&gt;文件。&lt;/p&gt;
&lt;p&gt;&lt;img alt="Screenshot for Control-Panel of Simple Data Writer" src="http://jmeter.apache.org/images/screenshots/simpledatawriter.png"&gt;&lt;br&gt;
&lt;em&gt;简单数据写入器控制面板的截图&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="#toc"&gt;【返回目录】&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="_26"&gt;汇总图&lt;/h3&gt;
&lt;p&gt;汇总图与聚合报告类似。主要区别在于汇总图提供了一种生成条形图并将图形保存为PNG文件的简便方法。&lt;/p&gt;
&lt;p&gt;&lt;img alt="Screenshot for Control-Panel of Aggregate Graph" src="http://jmeter.apache.org/images/screenshots/aggregate_graph.png"&gt;&lt;br&gt;
&lt;em&gt;汇总图控制面板的截图&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;下图显示了绘制此图表的设置示例。&lt;/p&gt;
&lt;p&gt;&lt;img alt="Aggregate graph settings" src="http://jmeter.apache.org/images/screenshots/aggregate_graph_settings.png"&gt;
&lt;em&gt;汇总图设置&lt;/em&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注意：所有这些参数都&lt;em&gt;不会&lt;/em&gt;保存在JMeter JMX脚本中。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;参数&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th align="left"&gt;是否必须&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;名称&lt;/td&gt;
&lt;td&gt;树中显示的此元件的描述性名称。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;列设置&lt;/td&gt;
&lt;td&gt;&lt;ul&gt;&lt;li&gt;&lt;code&gt;列显示：&lt;/code&gt;选择要在图表中显示的列。&lt;/li&gt;&lt;li&gt;&lt;code&gt;矩形颜色：&lt;/code&gt;单击右侧颜色矩形打开弹窗，为列选择自定义颜色。&lt;/li&gt;&lt;li&gt;&lt;code&gt;前景颜色&lt;/code&gt;允许更改值文本颜色。&lt;/li&gt;&lt;li&gt;&lt;code&gt;值字体：&lt;/code&gt;允许定义文本的字体设置。&lt;/li&gt;&lt;li&gt;&lt;code&gt;画出轮廓？&lt;/code&gt;在条形图上绘制或不绘制边框线&lt;/li&gt;&lt;li&gt;&lt;code&gt;显示号码分组？&lt;/code&gt;是否显示Y轴标签中的数字分组。&lt;/li&gt;&lt;li&gt;&lt;code&gt;值标签垂直&lt;/code&gt;更改值标签的方向。（默认为水平）&lt;/li&gt;&lt;li&gt;&lt;code&gt;列标签：&lt;/code&gt;按结果标签过滤。可以使用正则表达式，例如：&lt;code&gt;.*Transaction.*&lt;/code&gt;在显示图形之前，单击&lt;code&gt;Apply filter&lt;/code&gt;按钮刷新内部数据。&lt;/li&gt;&lt;/ul&gt;&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;标题&lt;/td&gt;
&lt;td&gt;在图表的头部定义图表的标题。为空是默认值：“&lt;code&gt;汇总图&lt;/code&gt;”。&lt;code&gt;同步名称&lt;/code&gt;按钮使用监听器的标签定义标题，并定义图表标题的字体设置&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;图表大小&lt;/td&gt;
&lt;td&gt;根据当前JMeter窗口大小的宽度和高度计算图形大小。使用&lt;code&gt;宽&lt;/code&gt;和&lt;code&gt;高度&lt;/code&gt;字段定义自定义大小。单位是像素。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;X轴设置&lt;/td&gt;
&lt;td&gt;定义X轴标签的最大长度（以像素为单位）。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Y轴设置&lt;/td&gt;
&lt;td&gt;为Y轴定义自定义最大值。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;图例&lt;/td&gt;
&lt;td&gt;定义图表图例的放置和字体设置&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;a href="#toc"&gt;【返回目录】&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="_27"&gt;响应时间图&lt;/h3&gt;
&lt;p&gt;响应时间图绘制了一个折线图，显示了测试期间每个标记请求的响应时间的演变。如果对于相同的时间戳存在许多样本，则显示平均值。&lt;/p&gt;
&lt;p&gt;&lt;img alt="Screenshot for Control-Panel of Response Time Graph" src="http://jmeter.apache.org/images/screenshots/response_time_graph.png"&gt;&lt;br&gt;
&lt;em&gt;响应时间图控制面板的截图&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;下图显示了绘制此图表的设置示例。&lt;/p&gt;
&lt;p&gt;&lt;img alt="Response time graph settings" src="http://jmeter.apache.org/images/screenshots/response_time_graph_settings.png"&gt;
&lt;em&gt;响应时间图设置&lt;/em&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注意：所有这些参数都保存在JMeter &lt;code&gt;.jmx&lt;/code&gt;文件中。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;参数&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th align="left"&gt;是否必须&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;名称&lt;/td&gt;
&lt;td&gt;树中显示的此元件的描述性名称。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;时间间隔（ms）&lt;/td&gt;
&lt;td&gt;X轴间隔的时间（以毫秒为单位）。样本根据此值进行分组。在显示图表之前，单击&lt;code&gt;应用区间&lt;/code&gt;按钮以刷新内部数据。&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;取样器标签选择&lt;/td&gt;
&lt;td&gt;按结果标签过滤。可以使用正则表达式，例如&lt;code&gt;.*Transaction.*&lt;/code&gt;。在显示图表之前，单击&lt;code&gt;应用过滤器&lt;/code&gt;按钮以刷新内部数据。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;标题&lt;/td&gt;
&lt;td&gt;在图表的头部定义图表的标题。为空是默认值：“&lt;code&gt;响应时间图&lt;/code&gt;”。&lt;code&gt;同步名称&lt;/code&gt;按钮使用监听器的标签定义标题，并定义图表标题的字体设置&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;线设置&lt;/td&gt;
&lt;td&gt;定义线的宽度。定义每个值点的类型。选择&lt;code&gt;空&lt;/code&gt;以获得没有标记的行&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;图表大小&lt;/td&gt;
&lt;td&gt;根据当前JMeter窗口大小的宽度和高度计算图形大小。使用&lt;code&gt;宽&lt;/code&gt;和&lt;code&gt;高度&lt;/code&gt;字段定义自定义大小。单位是像素。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;X轴设置&lt;/td&gt;
&lt;td&gt;自定义X轴标签的日期格式。语法是Java&lt;a href="http://docs.oracle.com/javase/8/docs/api/java/text/SimpleDateFormat.html"&gt;SimpleDateFormat API&lt;/a&gt;。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Y轴设置&lt;/td&gt;
&lt;td&gt;为Y轴定义自定义最大值（以毫秒为单位）。定义比例的增量（以毫秒为单位）。显示或不显示Y轴标签中的数字分组。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;图例&lt;/td&gt;
&lt;td&gt;定义图表图例的放置和字体设置&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;a href="#toc"&gt;【返回目录】&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="_28"&gt;邮件观察仪&lt;/h3&gt;
&lt;p&gt;如果测试运行从服务器收到太多失败的响应，可以设置使用邮件观察仪发送电子邮件。&lt;/p&gt;
&lt;p&gt;&lt;img alt="Screenshot for Control-Panel of Mailer Visualizer" src="http://jmeter.apache.org/images/screenshots/mailervisualizer.png"&gt;&lt;br&gt;
&lt;em&gt;邮件观察仪控制面板的截图&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参数&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th align="left"&gt;是否必须&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;名称&lt;/td&gt;
&lt;td&gt;树中显示的此元件的描述性名称。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;From&lt;/td&gt;
&lt;td&gt;用于发送邮件的电子邮件地址。&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Addressee(s)&lt;/td&gt;
&lt;td&gt;接收邮件的电子邮件地址，以逗号分隔。&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Success Subject&lt;/td&gt;
&lt;td&gt;成功消息的电子邮件主题行&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Success Limit&lt;/td&gt;
&lt;td&gt;一旦成功响应数量超过&lt;strong&gt;先前达到的失败的限制&lt;/strong&gt;之后，将发送成功电子邮件。因此，邮件程序将以失败-成功-失败-成功这样的顺序发送消息。&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Failure Subject&lt;/td&gt;
&lt;td&gt;失败消息的电子邮件主题行&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Failure Limit&lt;/td&gt;
&lt;td&gt;一旦失败响应数量超过此数，就会发送失败的电子邮件 - 即将计数设置为&lt;code&gt;0&lt;/code&gt;就会在第一次失败时发送电子邮件。&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Host&lt;/td&gt;
&lt;td&gt;SMTP服务器（电子邮件重定向器）的IP地址或主机名。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Port&lt;/td&gt;
&lt;td&gt;SMTP服务器的端口（默认为&lt;code&gt;25&lt;/code&gt;）。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Login&lt;/td&gt;
&lt;td&gt;用于验证的登录。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Password&lt;/td&gt;
&lt;td&gt;用于验证的密码。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Connection security&lt;/td&gt;
&lt;td&gt;SMTP身份验证的加密类型（SSL，TLS或无）。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Test Mail&lt;/td&gt;
&lt;td&gt;按此按钮发送测试邮件&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Failures&lt;/td&gt;
&lt;td&gt;一个字段，用于保持迄今为止收到的故障总数。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;a href="#toc"&gt;【返回目录】&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="beanshell_1"&gt;BeanShell监听器&lt;/h3&gt;
&lt;p&gt;BeanShell监听器允许使用BeanShell处理样本以保存等。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;有关使用BeanShell的完整详细信息，请参阅&lt;a href="http://www.beanshell.org/"&gt;BeanShell网站&lt;/a&gt;。&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;强烈建议迁移到&lt;a href="http://jmeter.apache.org/usermanual/component_reference.html#JSR223_Listener"&gt;JSR223监听器&lt;/a&gt; + Groovy，以提高性能，支持新的Java功能并减少BeanShell库的维护。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;测试元件支持&lt;code&gt;ThreadListener&lt;/code&gt;和&lt;code&gt;TestListener&lt;/code&gt;方法。这些应该在初始化文件中定义。有关定义的示例，请参阅文件&lt;code&gt;BeanShellListeners.bshrc&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img alt="Screenshot for Control-Panel of BeanShell Listener" src="http://jmeter.apache.org/images/screenshots/beanshell_listener.png"&gt;&lt;br&gt;
&lt;em&gt;BeanShell监听器控制面板的截图&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参数&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th align="left"&gt;是否必须&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;名称&lt;/td&gt;
&lt;td&gt;树中显示的此元件的描述性名称。该名称存储在脚本变量&lt;code&gt;Label&lt;/code&gt;中&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;每次调用前重置bsh.Interpreter&lt;/td&gt;
&lt;td&gt;如果选择此选项，则将为每个样本重新创建解释器。对于某些长时间运行的脚本，这可能是必需的。有关详细信息，请参阅&lt;a href="http://jmeter.apache.org/usermanual/best-practices#bsh_scripting"&gt;最佳实践 - BeanShell脚本&lt;/a&gt;。&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;参数&lt;/td&gt;
&lt;td&gt;要传递给BeanShell脚本的参数。参数存储在以下变量中：&lt;ul&gt;&lt;li&gt;&lt;code&gt;Parameters&lt;/code&gt;包含参数作为单个变量的字符串&lt;/li&gt;&lt;li&gt;&lt;code&gt;bsh.args&lt;/code&gt;包含参数的字符串数组，在空格处分割&lt;/li&gt;&lt;/ul&gt;&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;脚本文件&lt;/td&gt;
&lt;td&gt;包含要运行的BeanShell脚本的文件。文件名存储在脚本变量&lt;code&gt;FileName&lt;/code&gt;中&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;脚本&lt;/td&gt;
&lt;td&gt;要运行的BeanShell脚本。返回值被忽略。&lt;/td&gt;
&lt;td align="left"&gt;是（除非提供脚本文件）&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;在调用脚本之前，在BeanShell解释器中设置了一些变量：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;log&lt;/code&gt; - （&lt;a href="https://www.slf4j.org/api/org/slf4j/Logger.html"&gt;日志记录器&lt;/a&gt;） - 可用于写入日志文件&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;ctx&lt;/code&gt; - （&lt;a href="http://jmeter.apache.org/api/org/apache/jmeter/threads/JMeterContext.html"&gt;JMeter上下文&lt;/a&gt;） - 允许访问上下文&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;vars&lt;/code&gt; - (&lt;a href="http://jmeter.apache.org/api/org/apache/jmeter/threads/JMeterVariables.html"&gt;JMeter变量&lt;/a&gt;) - 提供对变量的读/写访问：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    vars.get(key);
    vars.put(key,val);
    vars.putObject(&amp;quot;OBJ1&amp;quot;,new Object());
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;props&lt;/code&gt; - （JMeter属性 - 类&lt;a href="https://docs.oracle.com/javase/8/docs/api/java/util/Properties.html"&gt;&lt;strong&gt;java.util.Properties&lt;/strong&gt;&lt;/a&gt;） - 例如&lt;code&gt;props.get("START.HMS");&lt;/code&gt; &lt;code&gt;props.put("PROP1","1234");&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;sampleResult&lt;/code&gt;，&lt;code&gt;prev&lt;/code&gt; - （&lt;a href="http://jmeter.apache.org/api/org/apache/jmeter/samplers/SampleResult.html"&gt;SampleResult&lt;/a&gt;） - 提供对前一个&lt;a href="http://jmeter.apache.org/api/org/apache/jmeter/samplers/SampleResult.html"&gt;SampleResult&lt;/a&gt;的访问&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;sampleEvent&lt;/code&gt;（&lt;a href="http://jmeter.apache.org/api/org/apache/jmeter/samplers/SampleEvent.html"&gt;SampleEvent&lt;/a&gt;）可以访问当前取样事件&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;有关上述每个变量的所有可用方法的详细信息，请查看Javadoc。&lt;/p&gt;
&lt;p&gt;如果定义了属性&lt;code&gt;beanshell.listener.init&lt;/code&gt;，则用于加载初始化文件，该文件可用于定义在BeanShell脚本中使用的方法等。&lt;/p&gt;
&lt;p&gt;&lt;a href="#toc"&gt;【返回目录】&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="_29"&gt;汇总报告&lt;/h3&gt;
&lt;p&gt;汇总报告为测试中的每个不同命名的请求创建一个表行。这与&lt;a href="http://jmeter.apache.org/usermanual/component_reference.html#Aggregate_Report"&gt;聚合报告&lt;/a&gt;类似，只是它使用更少的内存。&lt;/p&gt;
&lt;p&gt;吞吐量是从取样器目标（例如，HTTP样本的远程服务器）的角度计算的。JMeter考虑了生成请求的总时间。如果其他取样器和定时器位于同一线程中，则会增加总时间，从而降低吞吐量值。因此，具有不同名称的两个相同的取样器将具有两个具有相同名称的取样器的吞吐量的一半。正确选择取样器标签以从报告中获得最佳结果非常重要。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Label&lt;/code&gt; - 样本的标签。如果选择“&lt;code&gt;在标签中包含组名称？&lt;/code&gt;”，则会添加线程组的名称作为前缀。这允许来自不同线程组的相同标签根据需要被单独整理。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;# 样本&lt;/code&gt; - 具有相同标签的样本数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;平均值&lt;/code&gt; - 一组结果的平均经过时间&lt;/li&gt;
&lt;li&gt;&lt;code&gt;最小值&lt;/code&gt; - 具有相同标签样本的最短经过时间&lt;/li&gt;
&lt;li&gt;&lt;code&gt;最大值&lt;/code&gt; - 具有相同标签样本的最长经过时间&lt;/li&gt;
&lt;li&gt;&lt;code&gt;标准偏差&lt;/code&gt; - 样本经过时间的&lt;a href="http://jmeter.apache.org/usermanual/glossary.html#StandardDeviation"&gt;标准偏差&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;异常 ％&lt;/code&gt; - 异常请求的百分比&lt;/li&gt;
&lt;li&gt;&lt;code&gt;吞吐量&lt;/code&gt; - &lt;a href="http://jmeter.apache.org/usermanual/glossary.html#Throughput"&gt;吞吐量&lt;/a&gt;以每秒/分钟/小时的请求来衡量。自动选择时间单位，使显示的速率至少为&lt;code&gt;1.0&lt;/code&gt;。当吞吐量保存到CSV文件时，它以请求/秒表示，即30.0请求/分钟保存为&lt;code&gt;0.5&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;接收 KB/sec&lt;/code&gt; - 以千字节/秒为单位测量的吞吐量&lt;/li&gt;
&lt;li&gt;&lt;code&gt;发送 KB/sec&lt;/code&gt; - 以千字节/秒为单位测量的吞吐量&lt;/li&gt;
&lt;li&gt;&lt;code&gt;平均字节数&lt;/code&gt; - 样本响应的平均大小（以byte为单位）。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;时间以毫秒为单位。&lt;/p&gt;
&lt;p&gt;&lt;img alt="Screenshot for Control-Panel of Summary Report" src="http://jmeter.apache.org/images/screenshots/summary_report.png"&gt;&lt;br&gt;
&lt;em&gt;汇总报告控制面板的截图&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;下图显示了选择“&lt;code&gt;包含组名称&lt;/code&gt;”复选框的示例。&lt;/p&gt;
&lt;p&gt;&lt;img alt="Sample &amp;quot;" src="http://jmeter.apache.org/images/screenshots/summary_report_grouped.png"&gt;
&lt;em&gt;“&lt;code&gt;包含组名称&lt;/code&gt;”样本显示&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="#toc"&gt;【返回目录】&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="_30"&gt;保存响应到文件&lt;/h3&gt;
&lt;p&gt;该测试元件可以放置在测试计划的任何位置。对于其范围内的每个样本，它都会创建响应数据的文件。这个的主要用途是创建功能测试，但在响应太大而无法在&lt;a href="http://jmeter.apache.org/usermanual/component_reference.html#View_Results_Tree"&gt;查看结果树&lt;/a&gt;监听器中显示的情况下，它也很有用 。文件名是根据指定的前缀和数字（除非禁用此参数，请参见下文）创建的。如果文档类型已知，则从文档类型创建文件扩展名。如果未知，则文件扩展名设置为“&lt;code&gt;unknown&lt;/code&gt;”。如果禁用编号，并且禁用添加后缀，则将文件前缀作为整个文件名。这允许在需要时生成固定文件名。生成的文件名存储在样本响应中，如果需要，可以保存在测试日志输出文件中。&lt;/p&gt;
&lt;p&gt;首先保存当前样本，然后保存任何子样本。如果提供了变量名称，则文件名将按子样本的显示顺序保存。见下文。&lt;/p&gt;
&lt;p&gt;&lt;img alt="Screenshot for Control-Panel of Save Responses to a file" src="http://jmeter.apache.org/images/screenshots/savetofile.png"&gt;&lt;br&gt;
&lt;em&gt;保存响应到文件控制面板的截图&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参数&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th align="left"&gt;是否必须&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;名称&lt;/td&gt;
&lt;td&gt;树中显示的此元件的描述性名称。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;文件名前缀（可包含文件夹）&lt;/td&gt;
&lt;td&gt;生成的文件名的前缀；这可以包括目录名称。相对路径相对于当前工作目录（默认为&lt;code&gt;bin/&lt;/code&gt;目录）进行解析。JMeter还支持相对于包含当前测试计划（JMX文件）的目录的路径。如果路径名以“&lt;code&gt;〜/&lt;/code&gt;”（或JMeter&lt;code&gt;jmeter.save.saveservice.base_prefix&lt;/code&gt;属性中的任何内容）开头，则假定路径相对于JMX文件位置。&lt;br/&gt;如果前缀中的父文件夹不存在，JMeter将创建它们，如果失败则停止测试。&lt;blockquote&gt;注意文件名前缀不得包含与线程相关的数据，因此请勿在此字段中使用任何变量（&lt;code&gt;${varName}&lt;/code&gt;）或函数，如&lt;code&gt;${__ threadNum}&lt;/code&gt;&lt;/blockquote&gt;&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Variable Name containing saved file name&lt;/td&gt;
&lt;td&gt;用于保存生成的文件名的变量的名称（因此可以在测试计划中稍后使用）。如果有子样本，则会在变量名称中添加数字后缀。例如，如果变量名称为&lt;code&gt;FILENAME&lt;/code&gt;，则父样本文件名保存在变量&lt;code&gt;FILENAME&lt;/code&gt;中，子样本的文件名保存在&lt;code&gt;FILENAME1&lt;/code&gt;，&lt;code&gt;FILENAME2&lt;/code&gt;等中。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Minimum Length of sequence number&lt;/td&gt;
&lt;td&gt;如果未选中“&lt;code&gt;Don't add number to prefix&lt;/code&gt;”，则添加到前缀的数字将填充为&lt;code&gt;0&lt;/code&gt;，前缀长度即为此值。默认为&lt;code&gt;0&lt;/code&gt;。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Save Failed Responses only&lt;/td&gt;
&lt;td&gt;如果选中，则仅保存失败的响应&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Save Successful Responses only&lt;/td&gt;
&lt;td&gt;如果选中，则仅保存成功的响应&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Don't add number to prefix&lt;/td&gt;
&lt;td&gt;如果选中，则前缀中不会添加任何数字。如果选择此选项，请确保前缀唯一，否则文件可能被覆盖。&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Don't add content type suffix&lt;/td&gt;
&lt;td&gt;如果选择，则不添加后缀。如果选择此选项，请确保前缀唯一，否则文件可能被覆盖。&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Add timestamp&lt;/td&gt;
&lt;td&gt;如果选中，则日期将包含在文件后缀中，格式为&lt;code&gt;yyyyMMdd-HHmm_&lt;/code&gt;&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Don't Save Transaction Controller SampleResult&lt;/td&gt;
&lt;td&gt;如果选中，则将忽略事务控制器生成的取样结果&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;a href="#toc"&gt;【返回目录】&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="jsr223"&gt;JSR223监听器&lt;/h3&gt;
&lt;p&gt;JSR223 监听器允许将JSR223脚本代码应用于样本结果。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参数&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th align="left"&gt;是否必须&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;名称&lt;/td&gt;
&lt;td&gt;树中显示的此元件的描述性名称。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;语言&lt;/td&gt;
&lt;td&gt;要使用的JSR223语言&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;参数&lt;/td&gt;
&lt;td&gt;要传递给脚本的参数。参数存储在以下变量中：&lt;ul&gt;&lt;li&gt;&lt;code&gt;Parameters&lt;/code&gt;包含参数作为单个变量的字符串&lt;/li&gt;&lt;li&gt;&lt;code&gt;args&lt;/code&gt;包含参数的字符串数组，在空格处分割&lt;/li&gt;&lt;/ul&gt;&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;脚本文件&lt;/td&gt;
&lt;td&gt;包含要运行的脚本的文件，如果使用相对文件路径，则它将相对于系统属性“&lt;code&gt;user.dir&lt;/code&gt;”引用的目录&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;脚本编译缓存&lt;/td&gt;
&lt;td&gt;测试计划中的唯一字符串，如果使用的语言支持&lt;a href="https://docs.oracle.com/javase/8/docs/api/javax/script/Compilable.html"&gt;Compilable&lt;/a&gt;接口（Groovy是其中之一，java，beanshell和javascript不是），则JMeter将用于缓存脚本编译的结果。&lt;blockquote&gt;如果您在不检查此选项的情况下使用Groovy，请参阅JSR223取样器Java系统属性中的注释&lt;/blockquote&gt;&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;脚本&lt;/td&gt;
&lt;td&gt;要运行的脚本。&lt;/td&gt;
&lt;td align="left"&gt;是（除非提供脚本文件）&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;在调用脚本之前，会设置一些变量。请注意，这些是JSR223变量 - 即它们可以直接在脚本中使用。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;log&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;（&lt;a href="https://www.slf4j.org/api/org/slf4j/Logger.html"&gt;Logger&lt;/a&gt;） - 可用于写入日志文件&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Label&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;标签字符串&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;FileName&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;脚本文件名（如果有）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Parameters&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;参数（作为字符串）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;ARGS&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;作为字符串数组的参数（在空格上拆分）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;CTX&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;（&lt;a href="http://jmeter.apache.org/api/org/apache/jmeter/threads/JMeterContext.html"&gt;JMeterContext&lt;/a&gt;） - 允许访问上下文&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;vars&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;（&lt;a href="http://jmeter.apache.org/api/org/apache/jmeter/threads/JMeterVariables.html"&gt;JMeterVariables&lt;/a&gt;） - 提供对变量的读/写访问权限：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;vars.get(key);
vars.put(key,val);
vars.putObject(&amp;quot;OBJ1&amp;quot;,new Object());
vars.getObject(&amp;quot;OBJ2&amp;quot;);
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;props&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;（JMeterProperties - 类&lt;a href="https://docs.oracle.com/javase/8/docs/api/java/util/Properties.html"&gt;&lt;strong&gt;java.util.Properties&lt;/strong&gt;&lt;/a&gt;） - 例如&lt;code&gt;props.get("START.HMS");&lt;/code&gt; &lt;code&gt;props.put("PROP1","1234");&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;sampleResult&lt;/code&gt;，&lt;code&gt;prev&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;（&lt;a href="http://jmeter.apache.org/api/org/apache/jmeter/samplers/SampleResult.html"&gt;SampleResult&lt;/a&gt;） - 允许访问SampleResult&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;sampleEvent&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;（&lt;a href="http://jmeter.apache.org/api/org/apache/jmeter/samplers/SampleEvent.html"&gt;SampleEvent&lt;/a&gt;） - 提供对SampleEvent的访问&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;sampler&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;（&lt;a href="http://jmeter.apache.org/api/org/apache/jmeter/samplers/Sampler.html"&gt;取样器&lt;/a&gt;） - 允许访问最后一个取样器&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;OUT&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;System.out&lt;/code&gt; - 例如&lt;code&gt;OUT.println("message")&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;有关上述每个变量的所有可用方法的详细信息，请查看Javadoc&lt;/p&gt;
&lt;p&gt;&lt;a href="#toc"&gt;【返回目录】&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="_31"&gt;生成概要结果&lt;/h3&gt;
&lt;p&gt;该测试元件可以放置在测试计划的任何位置。生成到目前为止测试运行的摘要到日志文件和/或标准输出。显示运行和差异总计。在适当的时间边界上每&lt;code&gt;n&lt;/code&gt;秒（默认为30秒）生成输出，以便同步多个同时运行的测试。有关汇总器配置项，请参阅&lt;code&gt;jmeter.properties&lt;/code&gt;文件：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;# Define the following property to automatically start a summariser with that name
# (applies to CLI mode only)
#summariser.name=summary
#
# interval between summaries (in seconds) default 3 minutes
#summariser.interval=30
#
# Write messages to log file
#summariser.log=true
#
# Write messages to System.out
#summariser.out=true
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;该元件主要用于批处理（CLI）运行。输出如下所示：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;label +     16 in 0:00:12 =    1.3/s Avg:  1608 Min:  1163 Max:  2009 Err:     0 (0.00%) Active: 5 Started: 5 Finished: 0
label +     82 in 0:00:30 =    2.7/s Avg:  1518 Min:  1003 Max:  2020 Err:     0 (0.00%) Active: 5 Started: 5 Finished: 0
label =     98 in 0:00:42 =    2.3/s Avg:  1533 Min:  1003 Max:  2020 Err:     0 (0.00%)
label +     85 in 0:00:30 =    2.8/s Avg:  1505 Min:  1008 Max:  2005 Err:     0 (0.00%) Active: 5 Started: 5 Finished: 0
label =    183 in 0:01:13 =    2.5/s Avg:  1520 Min:  1003 Max:  2020 Err:     0 (0.00%)
label +     79 in 0:00:30 =    2.7/s Avg:  1578 Min:  1089 Max:  2012 Err:     0 (0.00%) Active: 5 Started: 5 Finished: 0
label =    262 in 0:01:43 =    2.6/s Avg:  1538 Min:  1003 Max:  2020 Err:     0 (0.00%)
label +     80 in 0:00:30 =    2.7/s Avg:  1531 Min:  1013 Max:  2014 Err:     0 (0.00%) Active: 5 Started: 5 Finished: 0
label =    342 in 0:02:12 =    2.6/s Avg:  1536 Min:  1003 Max:  2020 Err:     0 (0.00%)
label +     83 in 0:00:31 =    2.7/s Avg:  1512 Min:  1003 Max:  1982 Err:     0 (0.00%) Active: 5 Started: 5 Finished: 0
label =    425 in 0:02:43 =    2.6/s Avg:  1531 Min:  1003 Max:  2020 Err:     0 (0.00%)
label +     83 in 0:00:29 =    2.8/s Avg:  1487 Min:  1023 Max:  2013 Err:     0 (0.00%) Active: 5 Started: 5 Finished: 0
label =    508 in 0:03:12 =    2.6/s Avg:  1524 Min:  1003 Max:  2020 Err:     0 (0.00%)
label +     78 in 0:00:30 =    2.6/s Avg:  1594 Min:  1013 Max:  2016 Err:     0 (0.00%) Active: 5 Started: 5 Finished: 0
label =    586 in 0:03:43 =    2.6/s Avg:  1533 Min:  1003 Max:  2020 Err:     0 (0.00%)
label +     80 in 0:00:30 =    2.7/s Avg:  1516 Min:  1013 Max:  2005 Err:     0 (0.00%) Active: 5 Started: 5 Finished: 0
label =    666 in 0:04:12 =    2.6/s Avg:  1531 Min:  1003 Max:  2020 Err:     0 (0.00%)
label +     86 in 0:00:30 =    2.9/s Avg:  1449 Min:  1004 Max:  2017 Err:     0 (0.00%) Active: 5 Started: 5 Finished: 0
label =    752 in 0:04:43 =    2.7/s Avg:  1522 Min:  1003 Max:  2020 Err:     0 (0.00%)
label +     65 in 0:00:24 =    2.7/s Avg:  1579 Min:  1007 Max:  2003 Err:     0 (0.00%) Active: 0 Started: 5 Finished: 5
label =    817 in 0:05:07 =    2.7/s Avg:  1526 Min:  1003 Max:  2020 Err:     0 (0.00%)
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;“&lt;code&gt;label&lt;/code&gt;”是元件的名称。“&lt;code&gt;+&lt;/code&gt;”意味着该行是一个变化行，即显示了从上次输出之后的变化。&lt;br&gt;
“&lt;code&gt;=&lt;/code&gt;”表示该行是一个总计行，即其示出了运行总数。&lt;br&gt;
JMeter日志文件中的条目还包括时间戳。例如“&lt;code&gt;817 in 0:05:07 = 2.7/s&lt;/code&gt;”表示在5分7秒内记录了817个样本，并且每秒处理2.7个样本。&lt;br&gt;
&lt;code&gt;Avg&lt;/code&gt;（平均值），&lt;code&gt;Min&lt;/code&gt;（最小值）和&lt;code&gt;Max&lt;/code&gt;（最大值）时间以毫秒为单位。&lt;br&gt;
“&lt;code&gt;Err&lt;/code&gt;”表示异常数量（也显示为百分比）。&lt;br&gt;
最后两行将出现在测试结束时。它们不会与适当的时间边界同步。注意初始和最终变化量可能小于设置的间隔（在上面的示例中，是30秒）。第一个变化量通常较低，因为JMeter与间隔边界同步。最后的变化量将更低，因为测试通常不会在精确的间隔边界上完成。&lt;/p&gt;
&lt;p&gt;标签用于将样本结果在一起分组。因此，如果您有多个线程组并希望对它���进行汇总，那么请使用相同的标签 - 或将汇总器添加到测试计划中（因此所有线程组都在范围内）。可以通过使用合适的标签并将摘要器添加到测试计划的适当部分来实现不同的概要分组。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在CLI模式，默认情况下会配置名为“&lt;code&gt;summariser&lt;/code&gt;”的生成概要结果监听器，如果您已在测试计划中添加了一个，请确保命名不同，否则将在此标签（概要）下累积结果，从而导致错误的结果（样本总和+位于生成摘要结果监听器父级下面的样本数）。
这不是一个bug，而是一个允许跨线程组进行汇总的设计选择。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img alt="Screenshot for Control-Panel of Generate Summary Results" src="http://jmeter.apache.org/images/screenshots/summary.png"&gt;&lt;br&gt;
&lt;em&gt;生成摘要结果控制面板的截图&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参数&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th align="left"&gt;是否必须&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;名称&lt;/td&gt;
&lt;td&gt;树中显示的此元件的描述性名称。它在输出中显示为“&lt;code&gt;label&lt;/code&gt;”。具有相同标签的所有元件的详细信息将加到一起。&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;a href="#toc"&gt;【返回目录】&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="_32"&gt;比较断言可视化器&lt;/h3&gt;
&lt;p&gt;比较断言可视化器显示任何&lt;a href="http://jmeter.apache.org/usermanual/component_reference.html#Compare_Assertion"&gt;比较断言&lt;/a&gt;元件的结果。&lt;/p&gt;
&lt;p&gt;&lt;img alt="Screenshot for Control-Panel of Comparison Assertion Visualizer" src="http://jmeter.apache.org/images/screenshots/comparison_assertion_visualizer.png"&gt;&lt;br&gt;
&lt;em&gt;比较断言可视化器控制面板的截图&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参数&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th align="left"&gt;是否必须&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;名称&lt;/td&gt;
&lt;td&gt;树中显示的此元件的描述性名称。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;a href="#toc"&gt;【返回目录】&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="_33"&gt;后端监听器&lt;/h3&gt;
&lt;p&gt;后端监听器是一个异步监听器，允许您插入&lt;a href="http://jmeter.apache.org/api/org/apache/jmeter/visualizers/backend/BackendListenerClient.html"&gt;BackendListenerClient&lt;/a&gt;的自定义实现。默认情况下，提供Graphite实现。&lt;/p&gt;
&lt;p&gt;&lt;img alt="Screenshot for Control-Panel of Backend Listener" src="http://jmeter.apache.org/images/screenshots/backend_listener.png"&gt;&lt;br&gt;
&lt;em&gt;后端监听器控制面板的屏幕截图&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参数&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th align="left"&gt;是否必须&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;名称&lt;/td&gt;
&lt;td&gt;树中显示的此元件的描述性名称。&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;后端监听器实现&lt;/td&gt;
&lt;td&gt;&lt;code&gt;BackendListenerClient&lt;/code&gt;类的实现。&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;异步队列大小&lt;/td&gt;
&lt;td&gt;异步处理的采样结果队列的大小。&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;参数&lt;/td&gt;
&lt;td&gt;&lt;code&gt;BackendListenerClient&lt;/code&gt;实现的参数。&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;以下参数适用于&lt;a href="http://jmeter.apache.org/api/org/apache/jmeter/visualizers/backend/graphite/GraphiteBackendListenerClient.html"&gt;GraphiteBackendListenerClient&lt;/a&gt;实现：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参数&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th align="left"&gt;是否必须&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;graphiteMetricsSender&lt;/td&gt;
&lt;td&gt;&lt;code&gt;org.apache.jmeter.visualizers.backend.graphite.TextGraphiteMetricsSenderor&lt;/code&gt;或&lt;code&gt;org.apache.jmeter.visualizers.backend.graphite.PickleGraphiteMetricsSender&lt;/code&gt;&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;graphiteHost&lt;/td&gt;
&lt;td&gt;Graphite或InfluxDB（启用Graphite插件）服务器主机&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;graphitePort&lt;/td&gt;
&lt;td&gt;Graphite或InfluxDB（启用Graphite插件）服务器端口，默认为&lt;code&gt;2003&lt;/code&gt;。注意&lt;code&gt;PickleGraphiteMetricsSender&lt;/code&gt;（端口&lt;code&gt;2004&lt;/code&gt;）只能与Graphite服务器通信。&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;rootMetricsPrefix&lt;/td&gt;
&lt;td&gt;发送到后端的指标的前缀。默认为“&lt;code&gt;jmeter.&lt;/code&gt;”。注意JMeter不会在根前缀和样本名称之间添加分隔符，这就是当前需要尾部点号的原因。&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;summaryOnly&lt;/td&gt;
&lt;td&gt;仅发送没有详细信息的摘要。默认为&lt;code&gt;true&lt;/code&gt;。&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;samplersList&lt;/td&gt;
&lt;td&gt;定义要发送到后端的样本结果的名称（标签）。如果&lt;code&gt;useRegexpForSamplersList=false&lt;/code&gt;则是一个以分号分隔的名称列表。如果&lt;code&gt;useRegexpForSamplersList=true&lt;/code&gt;则是一个与名称匹配的正则表达式。&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;useRegexpForSamplersList&lt;/td&gt;
&lt;td&gt;将samplersList视为正则表达式，以选择要将度量标准报告给后端的取样器。默认为&lt;code&gt;false&lt;/code&gt;。&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;percentiles&lt;/td&gt;
&lt;td&gt;要发送到后端的百分位数。百分位数可以包含小数部分，例如&lt;code&gt;12.5&lt;/code&gt;。（分隔符始终为“.”）列表必须以分号分隔。通常3或4个值就足够了。&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;有关更多详细信息，请参阅&lt;a href="http://jmeter.apache.org/usermanual/realtime-results.html"&gt;实时结果&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img alt="Grafana dashboard" src="http://jmeter.apache.org/images/screenshots/grafana_dashboard.png"&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Grafana仪表板&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;从JMeter 3.2开始，添加了一个允许使用自定义模式直接在InfluxDB中编写的新实现，它被称为&lt;code&gt;InfluxdbBackendListenerClient&lt;/code&gt;。以下参数适用于&lt;a href="http://jmeter.apache.org/api/org/apache/jmeter/visualizers/backend/influxdb/InfluxdbBackendListenerClient.html"&gt;InfluxdbBackendListenerClient&lt;/a&gt;实现：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参数&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th align="left"&gt;是否必须&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;influxdbMetricsSender&lt;/td&gt;
&lt;td&gt;&lt;code&gt;org.apache.jmeter.visualizers.backend.influxdb.HttpMetricsSender&lt;/code&gt;&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;influxdbUrl&lt;/td&gt;
&lt;td&gt;Influx URL (例如：http://influxHost:8086/write?db=jmeter)&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;application&lt;/td&gt;
&lt;td&gt;被测试应用的名称。此值也作为名为“application”的标记存储在“events”度量中&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;measurement&lt;/td&gt;
&lt;td&gt;根据&lt;a href="https://docs.influxdata.com/influxdb/v1.1/write_protocols/line_protocol_reference/"&gt;Influx线路协议参考&lt;/a&gt;来度量。默认为“&lt;code&gt;jmeter&lt;/code&gt;”。&lt;/td&gt;
&lt;td align="left"&gt;InfluxInflux是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;summaryOnly&lt;/td&gt;
&lt;td&gt;仅发送没有详细信息的摘要。默认为&lt;code&gt;true&lt;/code&gt;。&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;samplersRegex&lt;/td&gt;
&lt;td&gt;将与样本名称匹配并发送到后端的正则表达式。&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;testTitle&lt;/td&gt;
&lt;td&gt;测试名称。默认为&lt;code&gt;Test name&lt;/code&gt;。该值作为名为“text”的字段存储在“events”度量中。JMeter在测试的开始和结束时自动生成一个该值的注释，以'started'和'ended'结尾。&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;eventTags&lt;/td&gt;
&lt;td&gt;Grafana允许显示每个注释的标记。你可以在这里填写它们。该值作为名为“tags”的标记存储在“events”度量中。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;percentiles&lt;/td&gt;
&lt;td&gt;要发送到后端的百分位数。百分位数可以包含小数部分，例如&lt;code&gt;12.5&lt;/code&gt;。（分隔符始终为“.”）列表必须以分号分隔。通常3或4个值就足够了。&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;TAG_WhatEverYouWant&lt;/td&gt;
&lt;td&gt;您可以根据需要添加任意数量的自定义标签。对于它们中的每一个，只需创建一个新行并在其名称前加“&lt;code&gt;TAG_&lt;/code&gt;”&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;有关更多详细信息，另请参阅&lt;a href="http://jmeter.apache.org/usermanual/realtime-results.html"&gt;实时结果&lt;/a&gt;和&lt;a href="http://docs.grafana.org/reference/annotations/#influxdb-annotations"&gt;Grafana中的Influxdb注释&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;a href="#toc"&gt;【返回目录】&lt;/a&gt;&lt;/p&gt;
&lt;h2 id="184"&gt;18.4 配置元件&lt;/h2&gt;
&lt;p&gt;配置元件可用于设置默认值和变量，供后续取样器使用。注意这些元件在它们范围开始处处理，即在相同范围内的任何取样器之前处理。 &lt;/p&gt;
&lt;h3 id="csv"&gt;CSV 数据文件设置&lt;/h3&gt;
&lt;p&gt;CSV 数据文件设置用于从文件中读取行，并将它们拆分为变量。它比&lt;a href="http://jmeter.apache.org/usermanual/functions.html#__CSVRead"&gt;__CSVRead()&lt;/a&gt;和&lt;strong&gt;&lt;a href="http://jmeter.apache.org/usermanual/functions.html#__StringFromFile"&gt;__StringFromFile()&lt;/a&gt;&lt;/strong&gt;函数更容易使用。它非常适合处理大量变量，对于使用“随机”和唯一值进行测试也很有用。&lt;/p&gt;
&lt;p&gt;在运行时生成唯一的随机值在CPU和内存消耗方面是很大的，因此最好在测试之前创建数据。如有必要，文件中的“随机”数据可以与运行时参数一起使用，以便在每次运行中创建不同的值集 - 例如使用级联 - 这比在运行时生成所有内容消耗的资源小得多。&lt;/p&gt;
&lt;p&gt;JMeter允许引用值；这允许值包含分隔符。如果启用“&lt;code&gt;是否允许带引号&lt;/code&gt;”，则可以用双引号括起值。双引号在引用时会被删除。要在引用字段中包含双引号，请使用两个双引号。例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;1,&amp;quot;2,3&amp;quot;,&amp;quot;4&amp;quot;&amp;quot;5&amp;quot; =&amp;gt;
1
2,3
4&amp;quot;5
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;JMeter支持带具有定义列名称的标题行的CSV文件。要启用此功能，请将“&lt;code&gt;变量名称&lt;/code&gt;”字段留空。还必须提供正确的分隔符。&lt;/p&gt;
&lt;p&gt;JMeter支持包含新行的带引号数据的CSV文件。&lt;/p&gt;
&lt;p&gt;默认情况下，文件只打开一次，每个线程将使用文件中的不同行。但是，行传递给线程的顺序取决于它们执行的顺序，这可能在迭代之间有所不同。在每次测试迭代开始时读取行。在第一次迭代中解析文件名和模式。&lt;/p&gt;
&lt;p&gt;有关其他选项，请参阅下面的共享模式说明。如果您希望每个线程都有自己的一组值，那么您将需要创建一组文件，每个线程对应一个。例如&lt;code&gt;test1.csv&lt;/code&gt;，&lt;code&gt;test2.csv&lt;/code&gt;，...，&lt;code&gt;testn.csv&lt;/code&gt;。使用文件名&lt;code&gt;test${__threadNum}.csv&lt;/code&gt;并将“&lt;code&gt;线程共享模式&lt;/code&gt;”设置为“&lt;code&gt;当前线程&lt;/code&gt;”。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;CSV 数据文件变量在每次测试迭代开始时定义。由于这是在配置处理完成之后，它们不能用于某些配置选项 - 例如JDBC配置 - 在配置时处理它们的内容（参见&lt;a href="https://bz.apache.org/bugzilla/show_bug.cgi?id=40394"&gt;Bug 40394&lt;/a&gt;）。但是变量在HTTP授权管理器中起作用，如&lt;code&gt;用户名&lt;/code&gt;等。因为是在运行时处理。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;作为一种特殊情况，分隔符字段中的字符串“ &lt;code&gt;\t&lt;/code&gt;”（不带引号）被视为制表符（Tab）。&lt;/p&gt;
&lt;p&gt;到达文件结尾（&lt;code&gt;EOF&lt;/code&gt;）并且循环选项为&lt;code&gt;true&lt;/code&gt;时，将再次从文件的第一行开始读取。&lt;/p&gt;
&lt;p&gt;如果再次循环选项为&lt;code&gt;false&lt;/code&gt;，并且停止线程为&lt;code&gt;false&lt;/code&gt;，则在到达文件末尾时，所有变量都将设置为&lt;code&gt;&amp;lt;EOF&amp;gt;&lt;/code&gt;。可以通过设置JMeter属性&lt;code&gt;csvdataset.eofstring&lt;/code&gt;来更改此值。&lt;/p&gt;
&lt;p&gt;如果再次循环选项为&lt;code&gt;false&lt;/code&gt;，并且止线程为&lt;code&gt;true&lt;/code&gt;，则到达&lt;code&gt;EOF&lt;/code&gt;将导致线程停止。&lt;/p&gt;
&lt;p&gt;&lt;img alt="Screenshot for Control-Panel of CSV Data Set Config" src="http://jmeter.apache.org/images/screenshots/csvdatasetconfig.png"&gt;&lt;br&gt;
&lt;em&gt;CSV 数据文件设置控制面板的截图&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参数&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th align="left"&gt;是否必须&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;名称&lt;/td&gt;
&lt;td&gt;树中显示的此元件的描述性名称。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;文件名&lt;/td&gt;
&lt;td&gt;要读取的文件的名称。 &lt;strong&gt;根据活动测试计划的路径解析相对文件名。对于分布式测试，CSV文件必须存储在服务器主机系统上与JMeter服务器启动的正确相对目录中。&lt;/strong&gt; 也支持绝对文件名，但请注意，除非远程服务器具有相同的目录结构，否则它们不太可能在远程模式下工作。如果以两种不同的方式引用相同的物理文件 - 例如&lt;code&gt;csvdata.txt&lt;/code&gt;和&lt;code&gt;./csvdata.txt&lt;/code&gt; - 则将这些文件视为不同的文件。如果操作系统不区分大小写，则&lt;code&gt;csvData.TXT&lt;/code&gt;也将被视为不同文件单独打开。&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;文件编码&lt;/td&gt;
&lt;td&gt;用于读取文件的编码，如果不是平台默认值。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;变量名称&lt;/td&gt;
&lt;td&gt;变量名称列表。名称必须用分隔符分隔。可以使用双引号引用它们。JMeter支持CSV标题行：如果变量名称字段为空，则读取文件的第一行并将其解释为列名列表。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;忽略首行&lt;/td&gt;
&lt;td&gt;忽略CSV文件的第一行，仅当变量名称不为空时才使用它，如果变量名称为空，则第一行必须包含标题。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;分隔符&lt;/td&gt;
&lt;td&gt;用于拆分文件记录的分隔符。如果一行上的值少于变量数，则其余变量不会更新 - 因此它们将保留其先前的值（如果有）。&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;是否允许带引号？&lt;/td&gt;
&lt;td&gt;CSV文件是否允许值带引号？如果启用，则可以将值括在&lt;code&gt;"&lt;/code&gt; - 双引号中，允许值包含分隔符。&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;遇到文件结束符再次循环？&lt;/td&gt;
&lt;td&gt;是否在达到&lt;code&gt;EOF&lt;/code&gt;时从头开始重新读取文件？（默认为&lt;code&gt;true&lt;/code&gt;）&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;遇到文件结束符停止线程？&lt;/td&gt;
&lt;td&gt;如果再次循环设置为false，线程是否在&lt;code&gt;EOF&lt;/code&gt;上停止（默认为&lt;code&gt;false&lt;/code&gt;）&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;线程共享模式&lt;/td&gt;
&lt;td&gt;&lt;ul&gt;&lt;li&gt;&lt;code&gt;所有线程&lt;/code&gt; - （默认）文件在所有线程之间共享。&lt;/li&gt;&lt;li&gt;&lt;code&gt;当前线程组&lt;/code&gt; - 为每个出现该元件的线程组打开一个文件&lt;/li&gt;&lt;li&gt;&lt;code&gt;当前线程&lt;/code&gt; - 为每个线程单独打开每个文件&lt;/li&gt;&lt;li&gt;&lt;code&gt;标识符&lt;/code&gt; - 共享相同标识符的所有线程共享同一文件。因此，例如，如果您有4个线程组，则可以使用两个或更多组的公共ID在它们之间共享文件。或者您可以使用线程编号在不同线程组中的相同线程编号之间共享文件。&lt;/li&gt;&lt;/ul&gt;&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;a href="#toc"&gt;【返回目录】&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="ftp"&gt;FTP请求默认值&lt;/h3&gt;
&lt;p&gt;&lt;img alt="Screenshot for Control-Panel of FTP Request Defaults" src="http://jmeter.apache.org/images/screenshots/ftp-config/ftp-request-defaults.png"&gt;&lt;br&gt;
&lt;em&gt;FTP请求默认值控制面板的截图&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="#toc"&gt;【返回目录】&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="dns"&gt;DNS缓存管理器&lt;/h3&gt;
&lt;p&gt;当用户从不同的IP接收内容时，DNS缓存管理器元件允许测试在负载平衡器（CDN等）后面有多个服务器的应用程序。默认情况下，JMeter使用JVM DNS缓存。这就是集群中只有一台服务器接收负载的原因。DNS缓存管理器在每次迭代时分别解析每个线程的名称，并将解析结果保存到其内部DNS缓存中，该缓存独立于JVM和系统DNS缓存。&lt;/p&gt;
&lt;p&gt;静态主机的映射可用于模拟&lt;code&gt;/etc/hosts&lt;/code&gt;文件之类的。这些条目将优先于自定义解析程序。如果要使用此映射，则必须启用&lt;code&gt;Use custom DNS resolver&lt;/code&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;h4 id="_34"&gt;静态主机表的用法&lt;/h4&gt;
&lt;p&gt;比如，您有一个测试服务器，您希望使用名称来访问，该名称尚未在您的DNS服务器中设置。在我们的例子中，服务器名称是&lt;code&gt;www.example.com&lt;/code&gt;，您希望通过服务器的IP地址&lt;code&gt;a123.another.example.org&lt;/code&gt;来访问。&lt;/p&gt;
&lt;p&gt;您可以更改工作站并在&lt;code&gt;/etc/hosts&lt;/code&gt;文件中添加条目- 或者等效于在您的操作系统中，在DNS缓存管理器的静态主机表中添加条目。&lt;/p&gt;
&lt;p&gt;您可以在第一列（&lt;code&gt;Host&lt;/code&gt;）中键入&lt;code&gt;www.example.com&lt;/code&gt;， 在第二列（&lt;code&gt;Hostname or IP address&lt;/code&gt;）中键入&lt;code&gt;a123.another.example.org&lt;/code&gt;。正如第二列的名称所暗示的那样，您甚至可以使用测试服务器的IP地址。 &lt;/p&gt;
&lt;p&gt;将使用自定义DNS解析程序查找测试服务器的IP地址。如果没有给出，将使用系统DNS解析器。&lt;/p&gt;
&lt;p&gt;现在，您可以在HTTPClient4取样器中使用&lt;code&gt;www.example.com&lt;/code&gt;，并且对于&lt;code&gt;a123.another.example.org&lt;/code&gt;的所有请求，使用&lt;code&gt;www.example.com&lt;/code&gt;设置的信息头。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img alt="Screenshot for Control-Panel of DNS Cache Manager" src="http://jmeter.apache.org/images/screenshots/dns-cache-manager.png"&gt;&lt;br&gt;
&lt;em&gt;DNS缓存管理器控制面板的截图&lt;/em&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;DNS缓存管理器设计用于在线程组或测试计划的根节点中使用。不要将其作为特定HTTP取样器的子元件&lt;/p&gt;
&lt;p&gt;DNS缓存管理器仅适用于使用HTTPClient4实现的HTTP请求。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;参数&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th align="left"&gt;是否必须&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;名称&lt;/td&gt;
&lt;td&gt;树中显示的此元件的描述性名称。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;在每次迭代中清除缓存&lt;/td&gt;
&lt;td&gt;如果选中，则每次启动新迭代时都会清除每个线程的DNS缓存。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Use system DNS resolver&lt;/td&gt;
&lt;td&gt;将使用系统DNS解析程序。要使它能正确工作，需要编辑&lt;code&gt;$JAVA_HOME/jre/lib/security/java.security&lt;/code&gt;并添加&lt;code&gt;networkaddress.cache.ttl=0&lt;/code&gt;&lt;/td&gt;
&lt;td align="left"&gt;N/A&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Use custom DNS resolver&lt;/td&gt;
&lt;td&gt;将使用自定义DNS解析器（来自dnsjava库）。&lt;/td&gt;
&lt;td align="left"&gt;N/A&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Hostname or IP address&lt;/td&gt;
&lt;td&gt;要使用的DNS服务器列表。如果为空，将使用网络配置DNS。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;添加按钮&lt;/td&gt;
&lt;td&gt;将条目添加到DNS服务器表。&lt;/td&gt;
&lt;td align="left"&gt;N/A&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;删除按钮&lt;/td&gt;
&lt;td&gt;删除当前选定的表条目。&lt;/td&gt;
&lt;td align="left"&gt;N/A&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Host and Hostname or IP address&lt;/td&gt;
&lt;td&gt;将主机名映射到静态主机条目，该条目将使用自定义DNS解析程序解析。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;添加静态主机按钮&lt;/td&gt;
&lt;td&gt;将条目添加到静态主机表。&lt;/td&gt;
&lt;td align="left"&gt;N/A&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;删除静态主机按钮&lt;/td&gt;
&lt;td&gt;删除表中当前选定的静态主机。&lt;/td&gt;
&lt;td align="left"&gt;N/A&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;a href="#toc"&gt;【返回目录】&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="http"&gt;HTTP授权管理器&lt;/h3&gt;
&lt;p&gt;授权管理器允许您为使用服务器身份认证限制的网页指定一个或多个用户登录。当您使用浏览器访问受限页面时，您会看到此类型的身份认证，并且浏览器会显示登录对话框。JMeter在遇到此类页面时会传输登录信息。&lt;/p&gt;
&lt;p&gt;授权信息头可能不会显示在树视图监听器“&lt;code&gt;请求&lt;/code&gt;”选项卡中。Java实现会执行抢先认证，但在JMeter获取信息头时它不会返回授权信息头。HttpComponents（HC 4.5.X）实现从3.2版本之后默认执行抢先认证，并且显示信息头。要禁用此功能，请按下面方式设置值，在这种情况下，只有响应质询时会执行身份认证。&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;jmeter.properties&lt;/code&gt;文件中设置&lt;code&gt;httpclient4.auth.preemptive=false&lt;/code&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注意：以上设置仅适用于HttpClient取样器。&lt;/p&gt;
&lt;p&gt;在查找URL匹配时，JMeter依次检查每个条目，并在找到第一个匹配时停止。因此，最明确的URL应首先出现在列表中，然后是不太明确的URL。重复的网址将被忽略。如果要为不同的线程使用不同的用户名/密码，可以使用变量。这些可以通过&lt;a href="http://jmeter.apache.org/usermanual/component_reference.html#CSV_Data_Set_Config"&gt;CSV数据文件设置&lt;/a&gt;元件（举例）进行设置。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img alt="Screenshot for Control-Panel of HTTP Authorization Manager" src="http://jmeter.apache.org/images/screenshots/http-config/http-auth-manager.png"&gt;&lt;br&gt;
&lt;em&gt;HTTP授权管理器控制面板的截图&lt;/em&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如果取样器范围内有多个授权管理器，目前是无法指定要使用哪个的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;参数&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th align="left"&gt;是否必须&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;名称&lt;/td&gt;
&lt;td&gt;树中显示的此元件的描述性名称。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;在每次迭代中清除认证？&lt;/td&gt;
&lt;td&gt;由Kerberos身份认证使用。如果选中，则将对主线程组循环的每次迭代进行身份认证，即使它已在前一个迭代中完成。要使每个主线程组迭代表示一个虚拟用户的行为时，这通常很有用。&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;基础URL&lt;/td&gt;
&lt;td&gt;与一个或多个HTTP请求URL匹配的部分或完整URL。例如，假设您指定一个基础URL为“&lt;code&gt;http://localhost/restricted/&lt;/code&gt;”，其&lt;code&gt;用户名&lt;/code&gt;为“&lt;code&gt;jmeter&lt;/code&gt;”，&lt;code&gt;密码&lt;/code&gt;为“&lt;code&gt;jmeter&lt;/code&gt;”。如果您向URL“&lt;code&gt;http://localhost/restricted/ant/myPage.html&lt;/code&gt;” 发送HTTP请求，则授权管理器会发送名为“&lt;code&gt;jmeter&lt;/code&gt;” 的用户的登录信息。&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;用户名&lt;/td&gt;
&lt;td&gt;要授权的用户名。&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;密码&lt;/td&gt;
&lt;td&gt;用户的密码。（注意，这在测试计划中没有加密存储）&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;域&lt;/td&gt;
&lt;td&gt;NTLM的域。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Realm&lt;/td&gt;
&lt;td&gt;NTLM的领域。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Mechanism&lt;/td&gt;
&lt;td&gt;要执行的身份认证类型。JMeter可以根据使用的不同Http取样器执行不同类型的身份认证：&lt;ul&gt;&lt;li&gt;Java：&lt;code&gt;BASIC&lt;/code&gt;&lt;/li&gt;&lt;li&gt;HttpClient 4：&lt;code&gt;BASIC&lt;/code&gt;、&lt;code&gt;DIGEST&lt;/code&gt;和&lt;code&gt;Kerberos&lt;/code&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;blockquote&gt;
&lt;p&gt;Realm仅适用于HttpClient取样器。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;Kerberos配置：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;要配置Kerberos，您需要设置至少两个JVM系统属性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-Djava.security.krb5.conf=krb5.conf&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-Djava.security.auth.login.config=jaas.conf&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;您还可以在文件&lt;code&gt;bin/system.properties&lt;/code&gt;中配置这两个属性。查看位于JMeter&lt;code&gt;bin&lt;/code&gt;文件夹中的两个示例配置文件（&lt;code&gt;krb5.conf&lt;/code&gt;和&lt;code&gt;jaas.conf&lt;/code&gt;），以获取对更多文档的引用，并调整它们以匹配您的Kerberos配置。&lt;/p&gt;
&lt;p&gt;SPNEGO默认禁用证书授权。可以通过将属性&lt;code&gt;kerberos.spnego.delegate_cred&lt;/code&gt;设置为&lt;code&gt;true&lt;/code&gt;来启用它。&lt;/p&gt;
&lt;p&gt;为Kerberos SPNEGO授权生成SPN时，IE和Firefox将省略URL中的端口号。如果端口号与标准端口号不同（&lt;code&gt;80&lt;/code&gt;和&lt;code&gt;443&lt;/code&gt;），Chrome有一个选项（&lt;code&gt;--enable-auth-negotiate-port&lt;/code&gt;）可以包含端口号。可以通过设置以下JMeter属性来模拟该行为。&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;jmeter.properties&lt;/code&gt;或&lt;code&gt;user.properties&lt;/code&gt;中，设置：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;kerberos.spnego.strip_port=false&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;控制：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;添加&lt;/code&gt;按钮 - 向授权表添加条目。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;删除&lt;/code&gt;按钮 - 删除当前选定的表条目。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;载入&lt;/code&gt;按钮 - 加载以前保存的授权表，并将条目添加到现有授权表条目中。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;保存测试计划&lt;/code&gt;按钮 - 将当前授权表保存到文件中。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;保存测试计划时，JMeter会自动保存所有授权表条目 - 包括任何未加密的密码。&lt;/p&gt;
&lt;p&gt;授权示例&lt;/p&gt;
&lt;p&gt;&lt;a href="http://jmeter.apache.org/demos/AuthManagerTestPlan.jmx"&gt;下载&lt;/a&gt;此示例。在此示例中，我们在本地服务器上创建了一个测试计划，该服务器发送3个HTTP请求，两个需要登录，另一个对所有人开放。请参见图10，了解我们的测试计划的组成。在我们的服务器上，我们有一个名为“&lt;code&gt;secret&lt;/code&gt;” 的受限目录，其中包含两个文件“&lt;code&gt;index.html&lt;/code&gt;”和“&lt;code&gt;index2.html&lt;/code&gt;”。我们创建了一个名为“&lt;code&gt;kevin&lt;/code&gt;” 的登录ID ，其密码为“&lt;code&gt;spot&lt;/code&gt;”。因此，在我们的授权管理器中，我们为受限目录创建了一个带用户名和密码的条目（参见图11）。名为“&lt;code&gt;SecretPage1&lt;/code&gt;”和“&lt;code&gt;SecretPage2&lt;/code&gt;” 的两个HTTP请求发送到”&lt;code&gt;/secret/index.html&lt;/code&gt;“和”&lt;code&gt;/secret/index2.html&lt;/code&gt;“。另一个名为”&lt;code&gt;NoSecretPage&lt;/code&gt;“的HTTP 请求发送到”&lt;code&gt;/index.html&lt;/code&gt;“ 。&lt;/p&gt;
&lt;p&gt;&lt;img alt="Figure 10 - Test Plan" src="http://jmeter.apache.org/images/screenshots/http-config/auth-manager-example1a.png"&gt;
&lt;em&gt;图10 - 测试计划&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="Figure 11 - Authorization Manager Control Panel" src="http://jmeter.apache.org/images/screenshots/http-config/auth-manager-example1b.png"&gt;
&lt;em&gt;图11 - 授权管理器控制面板&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;当我们运行测试计划时，JMeter在授权表中查找它请求的URL。如果基本URL与URL匹配，则JMeter会将此信息与请求一起传递。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;您可以下载测试计划，但由于它是作为本地服务器的测试而构建的，因此您将无法运行它。但是，您可以将其用作构建自己的测试计划的参考。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href="#toc"&gt;【返回目录】&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="http_1"&gt;HTTP缓存管理器&lt;/h3&gt;
&lt;p&gt;HTTP缓存管理器用于向其范围内的HTTP请求添加缓存功能，以模拟浏览器缓存功能。每个虚拟用户线程都有自己的缓存。默认情况下，缓存管理器将使用LRU算法在每个虚拟用户线程的缓存中存储多达5000个项目。使用属性“&lt;code&gt;maxSize&lt;/code&gt;”修改此值。注意，此值增加越多，HTTP缓存管理器消耗的内存也越多，因此请务必相应地调整&lt;code&gt;-Xmx&lt;/code&gt;JVM选项。&lt;/p&gt;
&lt;p&gt;如果样本成功（即响应代码为&lt;code&gt;2xx&lt;/code&gt;），则会为URL保存&lt;code&gt;Last-Modified&lt;/code&gt;和&lt;code&gt;Etag&lt;/code&gt;（以及相关的&lt;code&gt;Expired&lt;/code&gt;）值。在执行下一个样本之前，取样器会检查缓存中是否有条目，如果是，则为请求设置&lt;code&gt;If-Last-Modified&lt;/code&gt;和&lt;code&gt;If-None-Match&lt;/code&gt;条件信息头。&lt;/p&gt;
&lt;p&gt;此外，如果选择“&lt;code&gt;Use Cache-Control/Expires header&lt;/code&gt;”选项，则会根据当前时间检查&lt;code&gt;Cache-Control/Expires&lt;/code&gt;值。如果请求是&lt;code&gt;GET&lt;/code&gt;请求，并且时间戳是将来的，则取样器会立即返回，而不从远程服务器请求URL。这旨在模拟浏览器行为。请注意，如果&lt;code&gt;Cache-Control&lt;/code&gt;信息头为“&lt;code&gt;no-cache&lt;/code&gt;”，则响应将作为预过期存储在缓存中，因此将生成条件&lt;code&gt;GET&lt;/code&gt;请求。如果&lt;code&gt;Cache-Control&lt;/code&gt;有任何其他值，则“&lt;code&gt;max-age&lt;/code&gt;“到期选项将会执行以计算条目生存期，如果丢失则将使用expire信息，如果还缺失条目将按照&lt;a href="https://tools.ietf.org/html/2616#section-13.2.4"&gt;RFC 2616第13.2.4节&lt;/a&gt;中的规定使用&lt;code&gt;Last-Modified&lt;/code&gt;时间和响应日期进行缓存。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如果请求的文档在缓存后没有更改，则响应正文将为空。同样，如果&lt;code&gt;Expires&lt;/code&gt;日期是将来。这可能会导致断言出现问题。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img alt="Screenshot for Control-Panel of HTTP Cache Manager" src="http://jmeter.apache.org/images/screenshots/http-config/http-cache-manager.png"&gt;&lt;br&gt;
&lt;em&gt;HTTP缓存管理器控制面板的截图&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参数&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th align="left"&gt;是否必须&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;名称&lt;/td&gt;
&lt;td&gt;树中显示的此元件的描述性名称。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;在每次迭代中清除缓存&lt;/td&gt;
&lt;td&gt;如果选中，则在线程开始时清除缓存。&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Use Cache Control/Expires header when processing GET requests&lt;/td&gt;
&lt;td&gt;见上面的描述。&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;缓存中元素的最大数量&lt;/td&gt;
&lt;td&gt;见上面的描述。&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;a href="#toc"&gt;【返回目录】&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="http-cookie"&gt;HTTP Cookie管理器&lt;/h3&gt;
&lt;p&gt;Cookie管理器元件有两个功能：
首先，它像Web浏览器一样存储和发送Cookie。如果您有HTTP请求并且响应包含cookie，则Cookie管理器会自动存储该cookie，并将其用于之后对该特定网站的所有请求。每个JMeter线程都有自己的“cookie存储区”。因此，如果您正在测试使用cookie存储会话信息的网站，则每个JMeter线程都将拥有自己的会话。注意这样的Cookie不会显示在Cookie管理器显示屏上，但可以使用“&lt;a href="http://jmeter.apache.org/usermanual/component_reference.html#View_Results_Tree"&gt;查看结果树&lt;/a&gt;监听器”查看它们。&lt;/p&gt;
&lt;p&gt;JMeter检查收到的cookie是否对URL有效。这意味着不存储跨域cookie。如果您有窃听行为或希望使用跨域cookie，请定义JMeter属性“&lt;code&gt;CookieManager.check.cookies=false&lt;/code&gt;”。&lt;/p&gt;
&lt;p&gt;收到的Cookie可以存储为JMeter线程变量。要将cookie保存为变量，请定义属性“&lt;code&gt;CookieManager.save.cookies=true&lt;/code&gt;”。此外，cookie名称在存储之前以“&lt;code&gt;COOKIE_&lt;/code&gt;” 为前缀（这可以避免意外损坏局部变量）。要恢复原始行为，请定义属性“&lt;code&gt;CookieManager.name.prefix=&lt;/code&gt;”（一个或多个空格）。如果启用，名称为&lt;code&gt;TEST&lt;/code&gt;的cookie的值可以被&lt;code&gt;${COOKIE_TEST}&lt;/code&gt;引用。&lt;/p&gt;
&lt;p&gt;其次，您可以手动将Cookie添加到Cookie管理器。但是，如果这样做，cookie将被所有JMeter线程共享。&lt;/p&gt;
&lt;p&gt;注意，此类Cookie创建时的过期时间过长&lt;/p&gt;
&lt;p&gt;默认情况下，将忽略具值为&lt;code&gt;null&lt;/code&gt;的Cookie 。这可以通过设置JMeter属性来更改：&lt;code&gt;CookieManager.delete_null_cookies=false&lt;/code&gt;。注意这也适用于手动定义的cookie - 任何这样的cookie将在更新时不再显示。另请注意，所有cookie名称必须是唯一的 - 如果第二个cookie使用相同的名称定义，则它将替换第一个cookie。&lt;/p&gt;
&lt;p&gt;&lt;img alt="Screenshot for Control-Panel of HTTP Cookie Manager" src="http://jmeter.apache.org/images/screenshots/http-config/http-cookie-manager.png"&gt;&lt;br&gt;
&lt;em&gt;HTTP Cookie管理器的控制面板的截图&lt;/em&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如果取样器范围内有多个Cookie管理器，目前无法指定要使用哪个Cookie管理器。此外，存储在一个cookie管理器中的cookie不可用于任何其他管理器，因此请谨慎使用多个Cookie管理器。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;参数&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th align="left"&gt;是否必须&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;名称&lt;/td&gt;
&lt;td&gt;树中显示的此元件的描述性名称。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;每次反复清除Cookies&lt;/td&gt;
&lt;td&gt;如果选中，则每次执行主线程组循环时都会清除所有服务器定义的cookie。GUI中定义的任何cookie都不会被清除。&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Cookie 策略&lt;/td&gt;
&lt;td&gt;将用于管理cookie的cookie策略。“&lt;code&gt;standard&lt;/code&gt;”是3.0以来的默认值，在大多数情况下应该都有效。请参阅&lt;a href="https://hc.apache.org/httpcomponents-client-ga/tutorial/html/statemgmt.html#d5e515"&gt;Cookie规范&lt;/a&gt;和&lt;a href="http://hc.apache.org/httpcomponents-client-ga/httpclient/apidocs/org/apache/http/cookie/CookieSpec.html"&gt;CookieSpec实现&lt;/a&gt; [注意：“&lt;code&gt;ignoreCookies&lt;/code&gt;”相当于忽略Cookie管理器。&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;实现&lt;/td&gt;
&lt;td&gt;&lt;code&gt;HC4CookieHandler&lt;/code&gt;（HttpClient 4.5.X API）。自3.0以来默认为&lt;code&gt;HC4CookieHandler&lt;/code&gt;。 &lt;br/&gt;&lt;em&gt;[注意：如果您有要使用IPv6地址进行测试的网站，请选择HC4CookieHandler（兼容IPv6）]&lt;/em&gt;&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;用户定义的Cookie&lt;/td&gt;
&lt;td&gt;这使您有机会使用在测试执行期间将由所有线程共享的硬编码cookie。 &lt;br/&gt;“&lt;code&gt;domain&lt;/code&gt;”是服务器的主机名（不包括&lt;code&gt;http://&lt;/code&gt;）; 端口号目前被忽略。&lt;/td&gt;
&lt;td align="left"&gt;不建议使用（除非你知道你在做什么）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;添加按钮&lt;/td&gt;
&lt;td&gt;在cookie表中添加一个条目。&lt;/td&gt;
&lt;td align="left"&gt;N/A&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;删除按钮&lt;/td&gt;
&lt;td&gt;删除当前选定的表条目。&lt;/td&gt;
&lt;td align="left"&gt;N/A&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;载入按钮&lt;/td&gt;
&lt;td&gt;加载以前保存的cookie表，并将条目添加到现有cookie表条目中。&lt;/td&gt;
&lt;td align="left"&gt;N/A&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;保存测试计划按钮&lt;/td&gt;
&lt;td&gt;将当前cookie表保存到文件中（不保存从HTTP响应中提取的任何cookie）。&lt;/td&gt;
&lt;td align="left"&gt;N/A&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;a href="#toc"&gt;【返回目录】&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="http_2"&gt;HTTP请求默认值&lt;/h3&gt;
&lt;p&gt;此元件允许您设置HTTP请求控制器使用的默认值。例如，如果要创建具有25个HTTP请求控制器的测试计划并且所有请求都发送到同一服务器，则可以添加单个HTTP请求默认值元件，并填写“&lt;code&gt;服务器名称或IP&lt;/code&gt;”字段。然后，当您添加25个HTTP请求控制器时，请将“&lt;code&gt;服务器名称或IP&lt;/code&gt;”字段留空。控制器将从HTTP请求默认值元件继承此字段值。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;所有端口的值也同样处理；未指定端口的取样器将使用HTTP请求默认值里的端口号（如果提供了端口）。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img alt="Screenshot for Control-Panel of HTTP Request Defaults" src="http://jmeter.apache.org/images/screenshots/http-config/http-request-defaults.png"&gt;&lt;br&gt;
&lt;em&gt;HTTP请求默认值控制面板的截图&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="HTTP Request Advanced config fields" src="http://jmeter.apache.org/images/screenshots/http-config/http-request-defaults-advanced-tab.png"&gt;&lt;br&gt;
&lt;em&gt;HTTP请求高级配置字段&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参数&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th align="left"&gt;是否必须&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;名称&lt;/td&gt;
&lt;td&gt;树中显示的此取样器的描述性名称。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;服务器&lt;/td&gt;
&lt;td&gt;web服务器的域名或IP地址，例如&lt;code&gt;www.example.com&lt;/code&gt;。【不包含&lt;code&gt;http://&lt;/code&gt;前缀。】&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;端口&lt;/td&gt;
&lt;td&gt;Web服务器监听的端口。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;连接超时&lt;/td&gt;
&lt;td&gt;连接超时。等待连接打开的毫秒数。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;响应超时&lt;/td&gt;
&lt;td&gt;响应超时。等待响应的毫秒数。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;实现&lt;/td&gt;
&lt;td&gt;&lt;code&gt;Java&lt;/code&gt;，&lt;code&gt;HttpClient4&lt;/code&gt;。如果未指定，则默认值取JMeter属性&lt;code&gt;jmeter.httpsampler&lt;/code&gt;的值。如果仍取不到值，则使用&lt;code&gt;Java&lt;/code&gt;实现。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;协议&lt;/td&gt;
&lt;td&gt;&lt;code&gt;HTTP&lt;/code&gt;或&lt;code&gt;HTTPS&lt;/code&gt; 。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;内容编码&lt;/td&gt;
&lt;td&gt;用于请求的编码。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;路径&lt;/td&gt;
&lt;td&gt;资源的路径（例如，&lt;code&gt;/servlets/myServlet&lt;/code&gt;）。如果资源需要查询字符串参数，请将参数添加到“同请求一起发送参数”部分中。注意，路径是完整路径的默认路径，而不是要应用于HTTP请求屏幕上指定的路径的前缀。&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;同请求一起发送参数&lt;/td&gt;
&lt;td&gt;查询字符串将从您提供的参数列表中生成。每个参数都有一个&lt;code&gt;名称&lt;/code&gt;和 &lt;code&gt;值&lt;/code&gt;。查询字符串将以正确的方式生成，具体取决于您所选择的“&lt;code&gt;方法&lt;/code&gt;”（即，如果您选择&lt;code&gt;GET&lt;/code&gt;，查询字符串将附加到URL上，如果是&lt;code&gt;POST&lt;/code&gt;，则将单独发送）。此外，如果使用multipart form发送文件，则将使用multipart form规范创建查询字符串。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;服务器（代理）&lt;/td&gt;
&lt;td&gt;要执行请求的代理服务器的主机名或IP地址。【不包含&lt;code&gt;http://&lt;/code&gt;前缀。】&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;端口&lt;/td&gt;
&lt;td&gt;代理服务器监听的端口。&lt;/td&gt;
&lt;td align="left"&gt;否，除非指定了代理主机名&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;用户名&lt;/td&gt;
&lt;td&gt;（可选）代理服务器的用户名。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;密码&lt;/td&gt;
&lt;td&gt;（可选）代理服务器的密码。（注意，它在测试计划中没有加密存储）&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;从HTML文件获取所有内含的资源&lt;/td&gt;
&lt;td&gt;告诉JMeter解析HTML文件并发送文件中引用的所有图像，Java小程序，JavaScript文件，CSS等的HTTP/HTTPS请求。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;使用并发池&lt;/td&gt;
&lt;td&gt;使用并发连接来获取内含的资源。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;数量&lt;/td&gt;
&lt;td&gt;用于获取内含的资源的并发连接池大小。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;内含的网址必须匹配：&lt;/td&gt;
&lt;td&gt;如果选中，则必须填入正则表达式，用于与找到的所有内含的URL匹配。因此，如果您只想从&lt;code&gt;http://example.com/&lt;/code&gt;下载内含的资源，请使用以下表达式： &lt;code&gt;http://example\.com/.*&lt;/code&gt;&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;blockquote&gt;
&lt;p&gt;注意：单选按钮只有两种状态 - 开或关。这使得无法一致地覆盖设置 - 关闭意味着关闭，还是意味着使用当前默认设置？JMeter使用后者（否则默认值根本不起作用）。因此，如果按钮关闭，则后面的元件可以将其设置为打开，但如果按钮处于打开状态，则后面的元件无法将其设置为关闭。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href="#toc"&gt;【返回目录】&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="http_3"&gt;HTTP信息头管理器&lt;/h3&gt;
&lt;p&gt;信息头管理器允许您添加或覆盖HTTP请求信息头。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;JMeter现在支持多个信息头管理器&lt;/strong&gt;。合并信息头条目以形成取样器的列表。如果要合并的条目与现有信息头名称匹配，则它将替换先前的条目。这允许您设置一组默认信息头，并对特定取样器应用调整。注意信息头的空值不会删除现有信息头，只是替换其值。&lt;/p&gt;
&lt;p&gt;&lt;img alt="Screenshot for Control-Panel of HTTP Header Manager" src="http://jmeter.apache.org/images/screenshots/http-config/http-header-manager.png"&gt;&lt;br&gt;
&lt;em&gt;HTTP信息头管理器控制面板的截图&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参数&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th align="left"&gt;是否必须&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;名称&lt;/td&gt;
&lt;td&gt;树中显示的此元件的描述性名称。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;名称（信息头）&lt;/td&gt;
&lt;td&gt;请求信息头的名称。您可能想要尝试的两个常见请求信息头是“&lt;code&gt;User-Agent&lt;/code&gt;”和“&lt;code&gt;Referer&lt;/code&gt;”。&lt;/td&gt;
&lt;td align="left"&gt;否（但应该至少有一个）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;值&lt;/td&gt;
&lt;td&gt;请求信息头的值。&lt;/td&gt;
&lt;td align="left"&gt;否（但应该至少有一个）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;添加按钮&lt;/td&gt;
&lt;td&gt;在信息头表中添加一个条目。&lt;/td&gt;
&lt;td align="left"&gt;N/A&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;删除按钮&lt;/td&gt;
&lt;td&gt;删除当前选定的表条目。&lt;/td&gt;
&lt;td align="left"&gt;N/A&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;载入按钮&lt;/td&gt;
&lt;td&gt;加载以前保存的信息头表，并将条目添加到现有信息头表条目中。&lt;/td&gt;
&lt;td align="left"&gt;N/A&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;保存测试计划按钮&lt;/td&gt;
&lt;td&gt;将当前信息头表保存到文件中。&lt;/td&gt;
&lt;td align="left"&gt;N/A&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;blockquote&gt;
&lt;h4 id="_35"&gt;信息头管理器示例&lt;/h4&gt;
&lt;p&gt;&lt;a href="http://jmeter.apache.org/demos/HeaderManagerTestPlan.jmx"&gt;下载&lt;/a&gt;此示例。在此示例中，我们创建了一个测试计划，告诉JMeter覆盖默认的“&lt;code&gt;User-Agent&lt;/code&gt;”请求信息头，并使用特定的Internet Explorer代理字符串。（见图12和13）。&lt;/p&gt;
&lt;p&gt;&lt;img alt="Figure 12 - Test Plan" src="http://jmeter.apache.org/images/screenshots/http-config/header-manager-example1a.png"&gt;
&lt;em&gt;图12 - 测试计划&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="Figure 13 - Header Manager Control Panel" src="http://jmeter.apache.org/images/screenshots/http-config/header-manager-example1b.png"&gt;
&lt;em&gt;图13 - 信息头管理器控制面板&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href="#toc"&gt;【返回目录】&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="java_1"&gt;Java默认请求&lt;/h3&gt;
&lt;p&gt;Java默认请求组件允许您为Java测试设置默认值。请参阅&lt;a href="http://jmeter.apache.org/usermanual/component_reference.html#Java_Request"&gt;Java请求&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img alt="Screenshot for Control-Panel of Java Request Defaults" src="http://jmeter.apache.org/images/screenshots/java_defaults.png"&gt;&lt;br&gt;
&lt;em&gt;Java默认请求控制面板的截图&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="#toc"&gt;【返回目录】&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="jdbc"&gt;JDBC连接配置&lt;/h3&gt;
&lt;p&gt;从支持的JDBC连接设置创建数据库连接（提供给&lt;a href="http://jmeter.apache.org/usermanual/component_reference.html#JDBC_Request"&gt;JDBC请求&lt;/a&gt;取样器使用）。可以在线程之间随意建立连接池连接，也可以让每个线程单独连接。JDBC取样器通过连接配置名称来选择适当的连接。使用的连接池是DBCP，请参阅&lt;a href="https://commons.apache.org/proper/commons-dbcp/configuration.html"&gt;BasicDataSource配置参数&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img alt="Screenshot for Control-Panel of JDBC Connection Configuration" src="http://jmeter.apache.org/images/screenshots/jdbc-config/jdbc-conn-config.png"&gt;&lt;br&gt;
&lt;em&gt;JDBC连接配置控制面板的截图&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参数&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th align="left"&gt;是否必须&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;名称&lt;/td&gt;
&lt;td&gt;树中显示的此元件的描述性名称。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Variable Name for created pool&lt;/td&gt;
&lt;td&gt;连接所绑定的变量的名称。可以使用多个连接，每个连接绑定到不同的变量，允许JDBC取样器选择适当的连接。&lt;blockquote&gt;每个名称必须不同。如果有两个使用相同名称的配置元件，则只保存一个。如果检测到重复的名称，JMeter会在日志中显示。&lt;/blockquote&gt;&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Max Number of Connections&lt;/td&gt;
&lt;td&gt;连接池中允许的最大连接数。在大多数情况下，&lt;strong&gt;将其设置为零（0）&lt;/strong&gt;。这意味着每个线程将获得其自己的连接池，其中包含单个连接，即线程之间不共享连接。 &lt;br/&gt;如果你真的想使用共享池（为什么？），请将最大数量设置为与线程数相同，以确保线程不会互相等待。&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Max Wait (ms)&lt;/td&gt;
&lt;td&gt;如果在尝试检索连接的过程中超出等待时间，则线程池会抛出错误，请参阅&lt;a href="https://commons.apache.org/proper/commons-dbcp/api-2.1.1/org/apache/commons/dbcp2/BasicDataSource.html#getMaxWaitMillis--"&gt;BasicDataSource.html#getMaxWaitMillis&lt;/a&gt;&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Time Between Eviction Runs (ms)&lt;/td&gt;
&lt;td&gt;在空闲对象逐出器线程的运行期间休眠的毫秒数。当非正数时，将不运行空闲对象逐出器线程。（默认为“&lt;code&gt;60000&lt;/code&gt;”，1分钟）。请参阅&lt;a href="https://commons.apache.org/proper/commons-dbcp/api-2.1.1/org/apache/commons/dbcp2/BasicDataSource.html#getTimeBetweenEvictionRunsMillis--"&gt;BasicDataSource.html#getTimeBetweenEvictionRunsMillis&lt;/a&gt;&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Auto Commit&lt;/td&gt;
&lt;td&gt;为连接打开或关闭自动提交。&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Transaction isolation&lt;/td&gt;
&lt;td&gt;事务隔离级别&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Init SQL statements separated by new line&lt;/td&gt;
&lt;td&gt;一组SQL语句，用于在首次创建物理连接时初始化它们。这些语句只执行一次 - 当配置的连接工厂创建连接时。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Test While Idle&lt;/td&gt;
&lt;td&gt;测试连接池的空闲连接，请参阅&lt;a href="https://commons.apache.org/proper/commons-dbcp/api-2.1.1/org/apache/commons/dbcp2/BasicDataSource.html#getTestWhileIdle--"&gt;BasicDataSource.html#getTestWhileIdle&lt;/a&gt;。验证查询将用于测试它。&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Soft Min Evictable Idle Time(ms)&lt;/td&gt;
&lt;td&gt;在保证&lt;code&gt;minIdle&lt;/code&gt;连接保留在连接池的情况下，在达到空闲对象逐出器驱逐条件之前，连接可能在池中空闲的最短时间。请参阅&lt;a href="https://commons.apache.org/proper/commons-dbcp/api-2.1.1/org/apache/commons/dbcp2/BasicDataSource.html#getSoftMinEvictableIdleTimeMillis--"&gt;BasicDataSource.html#getSoftMinEvictableIdleTimeMillis&lt;/a&gt;。默认为5000（5秒）&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Validation Query&lt;/td&gt;
&lt;td&gt;用于确定数据库是否仍在响应的简单查询。这默认为jdbc驱动程序的'&lt;code&gt;isValid()&lt;/code&gt;'方法，适用于许多数据库。但是有些可能需要不同的查询；例如像Oracle'&lt;code&gt;SELECT 1 FROM DUAL&lt;/code&gt;'这样可以使用的。&lt;br /&gt;验证查询列表可以使用&lt;code&gt;jdbc.config.check.query&lt;/code&gt;属性来配置，默认为：&lt;ul&gt;&lt;li&gt;HSQLDB&lt;code&gt;select 1 from INFORMATION_SCHEMA.SYSTEM_USERS&lt;/code&gt;&lt;/li&gt;&lt;li&gt;Oracle&lt;code&gt;select 1 from dual&lt;/code&gt;&lt;/li&gt;&lt;li&gt;DB2&lt;code&gt;select 1 from sysibm.sysdummy1&lt;/code&gt;&lt;/li&gt;&lt;li&gt;MySQL&lt;code&gt;select 1&lt;/code&gt;&lt;/li&gt;&lt;li&gt;Microsoft SQL Server (MS JDBC driver)&lt;code&gt;select 1&lt;/code&gt;&lt;/li&gt;&lt;li&gt;PostgreSQL&lt;code&gt;select 1&lt;/code&gt;&lt;/li&gt;&lt;li&gt;Ingres&lt;code&gt;select 1&lt;/code&gt;&lt;/li&gt;&lt;li&gt;Derby&lt;code&gt;select 1&lt;/code&gt;&lt;/li&gt;&lt;li&gt;H2&lt;code&gt;select 1&lt;/code&gt;&lt;/li&gt;&lt;li&gt;Firebird&lt;code&gt;select 1 from rdb$database&lt;/code&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote&gt;该列表来自&lt;a href="https://stackoverflow.com/questions/10684244/dbcp-validationquery-for-different-databases"&gt;不同数据库验证查询的stackoverflow条目&lt;/a&gt;，它可能不正确&lt;/blockquote&gt;&lt;blockquote&gt;注意此验证查询用于线程池创建以验证它，即使“&lt;code&gt;Test While Idle&lt;/code&gt;”建议查询仅用于空闲连接。这是DBCP行为。&lt;/blockquote&gt;&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Database URL&lt;/td&gt;
&lt;td&gt;数据库的JDBC连接字符串。&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;JDBC Driver class&lt;/td&gt;
&lt;td&gt;驱动程序类的完全限定名称。（必须在JMeter的classpath中 - 很容易将&lt;code&gt;.jar&lt;/code&gt;文件复制到JMeter的&lt;code&gt;/lib&lt;/code&gt;目录中）。&lt;br /&gt;验证查询列表可以使用&lt;code&gt;jdbc.config.jdbc.driver.class&lt;/code&gt;属性来配置，默认为：&lt;ul&gt;&lt;li&gt;hsqldb&lt;code&gt;org.hsqldb.jdbc.JDBCDriver&lt;/code&gt;&lt;/li&gt;&lt;li&gt;Oracle&lt;code&gt;oracle.jdbc.OracleDriver&lt;/code&gt;&lt;/li&gt;&lt;li&gt;DB2&lt;code&gt;com.ibm.db2.jcc.DB2Driver&lt;/code&gt;&lt;/li&gt;&lt;li&gt;MySQL&lt;code&gt;com.mysql.jdbc.Driver&lt;/code&gt;&lt;/li&gt;&lt;li&gt;Microsoft SQL Server (MS JDBC driver)&lt;code&gt;com.microsoft.sqlserver.jdbc.SQLServerDriver&lt;/code&gt;或&lt;code&gt;com.microsoft.jdbc.sqlserver.SQLServerDriver&lt;/code&gt;&lt;/li&gt;&lt;li&gt;PostgreSQL&lt;code&gt;org.postgresql.Driver&lt;/code&gt;&lt;/li&gt;&lt;li&gt;Ingres&lt;code&gt;com.ingres.jdbc.IngresDriver&lt;/code&gt;&lt;/li&gt;&lt;li&gt;Derby&lt;code&gt;org.apache.derby.jdbc.ClientDriver&lt;/code&gt;&lt;/li&gt;&lt;li&gt;H2&lt;code&gt;org.h2.Driver&lt;/code&gt;&lt;/li&gt;&lt;li&gt;Firebird&lt;code&gt;org.firebirdsql.jdbc.FBDriver&lt;/code&gt;&lt;/li&gt;&lt;li&gt;Apache Derby&lt;code&gt;org.apache.derby.jdbc.ClientDriver&lt;/code&gt;&lt;/li&gt;&lt;li&gt;MariaDB&lt;code&gt;org.mariadb.jdbc.Driver&lt;/code&gt;&lt;/li&gt;&lt;li&gt;SQLite&lt;code&gt;org.sqlite.JDBC&lt;/code&gt;&lt;/li&gt;&lt;li&gt;Sybase AES&lt;code&gt;net.sourceforge.jtds.jdbc.Driver&lt;/code&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Username&lt;/td&gt;
&lt;td&gt;要连接的用户的名称。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Password&lt;/td&gt;
&lt;td&gt;要连接的密码。（注意在测试计划中没有加密存储）&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;不同的数据库和JDBC驱动程序需要不同的JDBC设置。数据库URL和JDBC驱动类由JDBC实现的提供程序定义。&lt;/p&gt;
&lt;p&gt;下面是一些可能的设置。请查看JDBC驱动程序文档中的确切详细信息。&lt;/p&gt;
&lt;p&gt;如果JMeter报告&lt;code&gt;No suitable driver&lt;/code&gt;（没有合适的驱动程序），那么这可能意味着：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;找不到驱动程序类。在这种情况下，会有一条日志消息，例如&lt;code&gt;DataSourceElement: Could not load driver: {classname} java.lang.ClassNotFoundException: {classname}&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;找到了驱动程序类，但该类不支持连接字符串。这可能是因为连接字符串中存在语法错误，或者因为使用了错误的类名。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果数据库服务器未运行或无法访问，则JMeter将报告&lt;code&gt;java.net.ConnectException&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;下面给出了数据库及其参数的一些示例。&lt;/p&gt;
&lt;p&gt;MySQL&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Driver class&lt;/p&gt;
&lt;p&gt;&lt;code&gt;com.mysql.jdbc.Driver&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Database URL&lt;/p&gt;
&lt;p&gt;&lt;code&gt;jdbc:mysql://host[:port]/dbname&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;PostgreSQL&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Driver class&lt;/p&gt;
&lt;p&gt;&lt;code&gt;org.postgresql.Driver&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Database URL&lt;/p&gt;
&lt;p&gt;&lt;code&gt;jdbc:postgresql:{dbname}&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Oracle&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Driver class&lt;/p&gt;
&lt;p&gt;&lt;code&gt;oracle.jdbc.OracleDriver&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Database URL&lt;/p&gt;
&lt;p&gt;&lt;code&gt;jdbc:oracle:thin:@//host:port/service&lt;/code&gt;或&lt;code&gt;jdbc:oracle:thin:@(description=(address=(host={mc-name})(protocol=tcp)(port={port-no}))(connect_data=(sid={sid})))&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Ingress (2006)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Driver class&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ingres.jdbc.IngresDriver&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Database URL&lt;/p&gt;
&lt;p&gt;&lt;code&gt;jdbc:ingres://host:port/db[;attr=value]&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Microsoft SQL Server (MS JDBC driver)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Driver class&lt;/p&gt;
&lt;p&gt;&lt;code&gt;com.microsoft.sqlserver.jdbc.SQLServerDriver&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Database URL&lt;/p&gt;
&lt;p&gt;&lt;code&gt;jdbc:sqlserver://host:port;DatabaseName=dbname&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Apache Derby&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Driver class&lt;/p&gt;
&lt;p&gt;&lt;code&gt;org.apache.derby.jdbc.ClientDriver&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Database URL&lt;/p&gt;
&lt;p&gt;&lt;code&gt;jdbc:derby://server[:port]/databaseName[;URLAttributes=value[;…]]&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;以上可能不正确 - 请查看相关的JDBC驱动程序文档。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href="#toc"&gt;【返回目录】&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="_36"&gt;密钥库配置&lt;/h3&gt;
&lt;p&gt;密钥库配置元件允许您配置密钥库的加载方式以及它将使用的密钥。此组件通常用于您不希望在响应时间中考虑密钥库初始化时间的HTTPS方案中。&lt;/p&gt;
&lt;p&gt;要使用此元件，您需要首先使用要测试的客户端证书设置Java密钥库，以执行此操作：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;使用Java&lt;code&gt;keytool&lt;/code&gt;实用程序或通过PKI创建证书&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果由PKI创建，请将密钥转换为JKS可接受的格式再导入Java密钥库&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;然后通过两个JVM属性引用密钥库文件（或在&lt;code&gt;system.properties&lt;/code&gt;中添加它们）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-Djavax.net.ssl.keyStore=path_to_keystore&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-Djavax.net.ssl.keyStorePassword=password_of_keystore&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img alt="Screenshot for Control-Panel of Keystore Configuration" src="http://jmeter.apache.org/images/screenshots/keystore_config.png"&gt;&lt;br&gt;
&lt;em&gt;密钥库配置控制面板的截图&lt;/em&gt;  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参数&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th align="left"&gt;是否必须&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;名称&lt;/td&gt;
&lt;td&gt;树中显示的此元件的描述性名称。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;预加载&lt;/td&gt;
&lt;td&gt;是否预加载密钥库。将其设置为&lt;code&gt;true&lt;/code&gt;通常是最佳选择。&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;指向证书别名的变量名称&lt;/td&gt;
&lt;td&gt;变量名称，包含用于身份验证的客户端证书的别名。以在CSV数据文件填充变量值为例。在屏幕截图中，“&lt;code&gt;certificat_ssl&lt;/code&gt;”也是CSV数据文件的变量。默认为&lt;code&gt;clientCertAliasVarName&lt;/code&gt;&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;别名起始索引&lt;/td&gt;
&lt;td&gt;密钥库中使用的第一个key的索引，从0开始。&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;别名末尾索引&lt;/td&gt;
&lt;td&gt;密钥库中使用的最后一个key的索引，从0开始。使用“&lt;code&gt;指向证书别名的变量名称&lt;/code&gt;”时，请确保它足够大，以便在启动时加载所有密钥。默认为-1表示加载全部。&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;blockquote&gt;
&lt;p&gt;要使JMeter使用多个证书，您需要确保：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在&lt;code&gt;jmeter.properties&lt;/code&gt;或&lt;code&gt;user.properties&lt;/code&gt;中设置了&lt;code&gt;https.use.cached.ssl.context=false&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;您对HTTP请求使用HTTPClient 4实现&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href="#toc"&gt;【返回目录】&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="_37"&gt;登录配置元件&lt;/h3&gt;
&lt;p&gt;登录配置元件允许您在使用用户名和密码作为其设置的一部分的取样器中添加或覆盖用户名和密码设置。&lt;/p&gt;
&lt;p&gt;&lt;img alt="Screenshot for Control-Panel of Login Config Element" src="http://jmeter.apache.org/images/screenshots/login-config.png"&gt;&lt;br&gt;
&lt;em&gt;登录配置元件控制面板的截图&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参数&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th align="left"&gt;是否必须&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;名称&lt;/td&gt;
&lt;td&gt;树中显示的此元件的描述性名称。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;用户名&lt;/td&gt;
&lt;td&gt;默认要使用的用户名。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;密码&lt;/td&gt;
&lt;td&gt;默认要使用的密码。（注意这在测试计划中没有加密存储）&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;a href="#toc"&gt;【返回目录】&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="ldap_2"&gt;LDAP默认请求&lt;/h3&gt;
&lt;p&gt;LDAP默认请求组件允许您为LDAP测试设置默认值。请参阅&lt;a href="http://jmeter.apache.org/usermanual/component_reference.html#LDAP_Request"&gt;LDAP请求&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img alt="Screenshot for Control-Panel of LDAP Request Defaults" src="http://jmeter.apache.org/images/screenshots/ldap_defaults.png"&gt;&lt;br&gt;
&lt;em&gt;LDAP默认请求控制面板的截图&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="#toc"&gt;【返回目录】&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="ldap_3"&gt;LDAP扩展请求默认值&lt;/h3&gt;
&lt;p&gt;LDAP扩展请求默认值组件允许您为LDAP扩展测试设置默认值。请参阅&lt;a href="http://jmeter.apache.org/usermanual/component_reference.html#LDAP_Extended_Request"&gt;LDAP扩展请求&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img alt="Screenshot for Control-Panel of LDAP Extended Request Defaults" src="http://jmeter.apache.org/images/screenshots/ldapext_defaults.png"&gt;&lt;br&gt;
&lt;em&gt;LDAP扩展请求默认值控制面板的截图&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="#toc"&gt;【返回目录】&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="tcp_1"&gt;TCP取样器配置&lt;/h3&gt;
&lt;p&gt;TCP取样器配置为TCP取样器提供默认数据。&lt;/p&gt;
&lt;p&gt;&lt;img alt="Screenshot for Control-Panel of TCP Sampler Config" src="http://jmeter.apache.org/images/screenshots/tcpsamplerconfig.png"&gt;&lt;br&gt;
&lt;em&gt;TCP取样器配置控制面板的截图&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参数&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th align="left"&gt;是否必须&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;名称&lt;/td&gt;
&lt;td&gt;树中显示的此元件的描述性名称。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;TCPClient classname&lt;/td&gt;
&lt;td&gt;TCP客户端类的名称。默认从属性&lt;code&gt;tcp.handler&lt;/code&gt;读取，失败则从&lt;code&gt;TCPClientImpl&lt;/code&gt;取。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;服务器名称或IP&lt;/td&gt;
&lt;td&gt;TCP服务器的名称或IP&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;端口号&lt;/td&gt;
&lt;td&gt;要使用的端口&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Re-use connection&lt;/td&gt;
&lt;td&gt;如果选中，则连接保持打开状态。否则，在读取数据后将关闭连接。&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;关闭连接&lt;/td&gt;
&lt;td&gt;如果选择此选项，则在运行取样器后将关闭连接。&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;SO_LINGER&lt;/td&gt;
&lt;td&gt;创建套接字时启用/禁用指定的延迟时间（以秒为单位）&lt;code&gt;SO_LINGER&lt;/code&gt;。如果将“&lt;code&gt;SO_LINGER&lt;/code&gt;”值设置为&lt;code&gt;0&lt;/code&gt;，则可以防止大量套接字处于&lt;code&gt;TIME_WAIT&lt;/code&gt;状态。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;行尾（EOL）字节值&lt;/td&gt;
&lt;td&gt;行尾的字节值，将其设置为&lt;code&gt;-128&lt;/code&gt;到&lt;code&gt;+127&lt;/code&gt;范围之外的值以跳过EOL检查。您可以在&lt;code&gt;jmeter.properties&lt;/code&gt;文件中设置，也可以设置&lt;code&gt;tcp.eolByte&lt;/code&gt;属性。如果在TCP取样器配置和&lt;code&gt;jmeter.properties&lt;/code&gt;文件中同时设置此项，将使用TCP取样器配置中的设置值。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;连接超时&lt;/td&gt;
&lt;td&gt;连接超时时间（毫秒，0为禁用）。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;响应超时&lt;/td&gt;
&lt;td&gt;响应超时时间（毫秒，0为禁用）。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;设置无延迟&lt;/td&gt;
&lt;td&gt;是否设置无延迟属性？&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;要发送的文本&lt;/td&gt;
&lt;td&gt;要发送的文本&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;a href="#toc"&gt;【返回目录】&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="_38"&gt;用户定义的变量&lt;/h3&gt;
&lt;p&gt;用户定义的变量元件允许您定义一组&lt;strong&gt;初始变量&lt;/strong&gt;，就像在&lt;a href="http://jmeter.apache.org/usermanual/component_reference.html#Test_Plan"&gt;测试计划&lt;/a&gt;中一样。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注意，测试计划中的所有用户定义的变量元件 - 无论它们在何处 - 都会在开始时进行处理。 &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;因此，您无法引用定义为测试运行一部分的变量，例如在后置处理器中。 &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;用户定义的变量不应与每次调用时生成不同结果的函数一起使用。只有第一个函数调用的结果才会保存在变量中。&lt;/strong&gt;但是，用户定义的变量可以与&lt;a href="http://jmeter.apache.org/usermanual/functions.html#__P"&gt;__P()&lt;/a&gt;等函数一起使用，例如： &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;HOST      &lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;__P&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;host&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;localhost&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这将定义变量“&lt;code&gt;HOST&lt;/code&gt;”并赋JMeter属性“&lt;code&gt;host&lt;/code&gt;” 的值，如果未定义则默认为“&lt;code&gt;localhost&lt;/code&gt;”。 &lt;/p&gt;
&lt;p&gt;要在测试运行期间定义变量，请参阅&lt;a href="http://jmeter.apache.org/usermanual/component_reference.html#User_Parameters"&gt;用户参数&lt;/a&gt;。用户定义的变量按照它们在计划中出现的顺序从上到下进行处理。 &lt;/p&gt;
&lt;p&gt;为简单起见，建议将用户定义的变量仅放置在线程组的开头（或者在测试计划本身下）。 &lt;/p&gt;
&lt;p&gt;一旦处理了测试计划和所有用户定义的变量，就会将生成的变量集复制到每个线程以提供初始变量集。 &lt;/p&gt;
&lt;p&gt;如果运行时元件（例如用户参数前置处理器或正则表达式提取器）定义了与其中一个用户定义的变量同名的变量，那么这将替换初始值，并且线程中的所有其他测试元件将看到更新的值。 &lt;/p&gt;
&lt;p&gt;&lt;img alt="Screenshot for Control-Panel of User Defined Variables" src="http://jmeter.apache.org/images/screenshots/user_defined_variables.png"&gt;&lt;br&gt;
&lt;em&gt;用户定义的变量控制面板的截图&lt;/em&gt; &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如果您有多个线程组，请确保为不同的值使用不同的名称，因为户定义的变量在线程组之间共享。此外，在元件被处理之后变量才可用，因此您无法引用在同一元件中定义的变量。您可以引用之前用户定义的变量或测试计划中定义的变量。  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;参数&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th align="left"&gt;是否必须&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;名称&lt;/td&gt;
&lt;td&gt;树中显示的此元件的描述性名称。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;用户定义的变量&lt;/td&gt;
&lt;td&gt;变量名称/值对。“&lt;code&gt;名称&lt;/code&gt;”列下的字符串是您需要放在&lt;code&gt;${...}&lt;/code&gt;构造中的括号内以便稍后使用变量的内容。然后，整个&lt;code&gt;${...}&lt;/code&gt;将被“&lt;code&gt;值&lt;/code&gt;”列中的字符串替换。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;a href="#toc"&gt;【返回目录】&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="_39"&gt;随机变量&lt;/h3&gt;
&lt;p&gt;随机变量配置元件用于生成随机数字符串并将它们存储在变量中以供以后使用。它比使用&lt;a href="http://jmeter.apache.org/usermanual/component_reference.html#User_Defined_Variables"&gt;用户定义的变量&lt;/a&gt;和&lt;a href="http://jmeter.apache.org/usermanual/functions.html#__Random"&gt;__Random()&lt;/a&gt;函数更简单。 &lt;/p&gt;
&lt;p&gt;使用随机数生成器构造输出变量，然后使用格式字符串格式化结果数字。数字的计算使用公式&lt;code&gt;minimum+Random.nextInt(maximum-minimum+1)&lt;/code&gt;。&lt;code&gt;Random.nextInt()&lt;/code&gt;需要一个正整数。这意味着&lt;code&gt;最大值-最小值&lt;/code&gt; - 即范围 - 必须小于&lt;code&gt;2147483647&lt;/code&gt;，但是只要在范围内，&lt;code&gt;最小值&lt;/code&gt;和&lt;code&gt;最大值&lt;/code&gt;可以是任何&lt;code&gt;long&lt;/code&gt;值。 &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;由于在每次迭代开始时评估随机值，因此使用属性以外的变量作为最小值或最大值的值可能不是一个好主意。在第一次迭代时它将为零。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img alt="Screenshot for Control-Panel of Random Variable" src="http://jmeter.apache.org/images/screenshots/random_variable.png"&gt;&lt;br&gt;
&lt;em&gt;随机变量控制面板的截图&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参数&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th align="left"&gt;是否必须&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;名称&lt;/td&gt;
&lt;td&gt;树中显示的此元件的描述性名称。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;变量名称&lt;/td&gt;
&lt;td&gt;用于存储随机字符串的变量的名称&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;输出格式&lt;/td&gt;
&lt;td&gt;要使用的&lt;code&gt;java.text.DecimalFormat&lt;/code&gt;格式字符串。例如，“&lt;code&gt;000&lt;/code&gt;”将生成至少3位数的数字，或“&lt;code&gt;USER_000&lt;/code&gt;”将生成&lt;code&gt;USER_nnn&lt;/code&gt;形式的输出。如果未指定，则默认使用&lt;code&gt;Long.toString()&lt;/code&gt;生成数字&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;最小值&lt;/td&gt;
&lt;td&gt;生成的随机数的最小值（&lt;code&gt;long&lt;/code&gt;）。&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;最大值&lt;/td&gt;
&lt;td&gt;生成的随机数的最大值（&lt;code&gt;long&lt;/code&gt;）。&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;随机种子&lt;/td&gt;
&lt;td&gt;随机数生成器的种子。如果将每线程设置为&lt;code&gt;true&lt;/code&gt;使用相同的种子值，则每个线程将获得与每个&lt;a href="http://docs.oracle.com/javase/8/docs/api/java/util/Random.html"&gt;Random&lt;/a&gt;类相同的值。&lt;br/&gt;如果未设置种子，则将使用Random的默认构造函数。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;每线程（用户）？&lt;/td&gt;
&lt;td&gt;如果为&lt;code&gt;False&lt;/code&gt;，则生成器在线程组中的所有线程之间共享。如果为&lt;code&gt;True&lt;/code&gt;，则每个线程都有自己的随机生成器。&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;a href="#toc"&gt;【返回目录】&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="_40"&gt;计数器&lt;/h3&gt;
&lt;p&gt;允许用户创建可在线程组中的任何位置引用的计数器。计数器配置允许用户配置起始值，最大值和递增值。计数器将从起始循环到最大，然后从起始重新开始，继续这样直到测试结束。  &lt;/p&gt;
&lt;p&gt;计数器使用long类型来存储值，因此范围从&lt;code&gt;-2^63&lt;/code&gt;到&lt;code&gt;2^63-1&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img alt="Screenshot for Control-Panel of Counter" src="http://jmeter.apache.org/images/screenshots/counter.png"&gt;&lt;br&gt;
&lt;em&gt;计数器控制面板的截图&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参数&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th align="left"&gt;是否必须&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;名称&lt;/td&gt;
&lt;td&gt;树中显示的此元件的描述性名称。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Starting value&lt;/td&gt;
&lt;td&gt;计数器的起始值。计数器将在第一次迭代期间等于此值（默认为0）。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;递增&lt;/td&gt;
&lt;td&gt;每次迭代后计数器的增加量（默认为0，表示没有增量）。&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Maximum value&lt;/td&gt;
&lt;td&gt;如果计数器超过最大值，则将其重置为&lt;code&gt;Starting value&lt;/code&gt;。默认值为&lt;code&gt;Long.MAX_VALUE&lt;/code&gt;&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;数字格式&lt;/td&gt;
&lt;td&gt;可选的格式，如&lt;code&gt;000&lt;/code&gt;将格式化为&lt;code&gt;001&lt;/code&gt;，&lt;code&gt;002&lt;/code&gt;这样的。它将传递给&lt;code&gt;DecimalFormat&lt;/code&gt;，所以可以使用任何有效的格式。如果解释格式时出现问题，则忽略该格式。【使用&lt;code&gt;Long.toString()&lt;/code&gt;生成默认格式】&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;引用名称&lt;/td&gt;
&lt;td&gt;这是计数器值可用的变量名称。如果将其命名为&lt;code&gt;counterA&lt;/code&gt;，则可以使用&lt;code&gt;${counterA}&lt;/code&gt;访问它， 如&lt;a href="http://jmeter.apache.org/usermanual/functions.html"&gt;用户定义的值&lt;/a&gt;中所述（默认情况下，它创建一个可以使用&lt;code&gt;${}&lt;/code&gt;访问的空字符串变量，但强烈建议不要这样做）&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;与每用户独立的跟踪计数器&lt;/td&gt;
&lt;td&gt;换句话说，这是一个全局计数器，还是每个用户都使用自己的计数器？如果未选中，则计数器是全局的（即，用户＃1将获得值“&lt;code&gt;1&lt;/code&gt;”，并且用户＃2将在第一次迭代时获得值“&lt;code&gt;2&lt;/code&gt;”）。如果选中，则每个用户都有一个独立的计数器&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;在每个线程组迭代上重置计数器&lt;/td&gt;
&lt;td&gt;此选项仅在每个用户跟踪计数器选中时可用，如果选中，则计数器将在每个线程组迭代时重置为“&lt;code&gt;起始&lt;/code&gt;”值。当计数器在循环控制器中时，这可能很有用。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;a href="#toc"&gt;【返回目录】&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="_41"&gt;简单配置元件&lt;/h3&gt;
&lt;p&gt;简单配置元件允许您在取样器中添加或覆盖任意值。您可以选择值的名称和值本身。虽然一些有冒险精神的用户可能会发现这个元件的用途，但它主要是供开发人员在开发新的JMeter组件时使用的基本GUI。&lt;/p&gt;
&lt;p&gt;&lt;img alt="Screenshot for Control-Panel of Simple Config Element" src="http://jmeter.apache.org/images/screenshots/simple_config_element.png"&gt;&lt;br&gt;
&lt;em&gt;简单配置元件控件面板的截图&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参数&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th align="left"&gt;是否必须&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;名称&lt;/td&gt;
&lt;td&gt;树中显示的此元件的描述性名称。&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;参数名称&lt;/td&gt;
&lt;td&gt;每个参数的名称。这些值是JMeter工作的内部值，通常不会记录。只有熟悉代码的人才会知道这些值。&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;参数值&lt;/td&gt;
&lt;td&gt;要应用于该参数的值。&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;a href="#toc"&gt;【返回目录】&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="mongodb_1"&gt;MongoDB源配置（已弃用）&lt;/h3&gt;
&lt;p&gt;&lt;a href="#toc"&gt;【返回目录】&lt;/a&gt;&lt;/p&gt;
&lt;h2 id="185"&gt;18.5 断言&lt;/h2&gt;
&lt;p&gt;断言用于对取样器执行附加检查，并在同一范围内的&lt;strong&gt;每个取样器&lt;/strong&gt;之后进行处理。要确保仅将断言应用于特定取样器，请将其添加为取样器的子级。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注意：除非另有说明，否则断言不适用于子样本 - 仅适用于父样本。对于JSR223和BeanShell断言，脚本可以使用&lt;code&gt;prev.getSubResults()&lt;/code&gt;方法检索子样本，该方法返回取样结果数组。如果没有结果，则数组将为空。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;断言可以应用于主样本，子样本或两者。默认设置是仅将断言应用于主样本。如果断言支持此选项，则GUI上将显示如下所示的条目：     &lt;/p&gt;
&lt;p&gt;&lt;img alt="Assertion Scope" src="http://jmeter.apache.org/images/screenshots/assertion/assertionscope.png"&gt;
&lt;em&gt;断言范围&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;或如下&lt;/p&gt;
&lt;p&gt;&lt;img alt="Assertion Scope" src="http://jmeter.apache.org/images/screenshots/assertion/assertionscopevar.png"&gt;
&lt;em&gt;断言范围&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;如果子取样器失败且主样本成功，则主样本将设置为失败状态，并将添加断言结果。如果使用JMeter变量选项，则假定它与主样本相关，并且任何失败将仅应用于主样本。     &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在运行了取样器的所有断言之后，变量&lt;code&gt;JMeterThread.last_sample_ok&lt;/code&gt;将更新为“&lt;code&gt;true&lt;/code&gt;”或“&lt;code&gt;false&lt;/code&gt;”。      &lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id="_42"&gt;响应断言&lt;/h3&gt;
&lt;p&gt;响应断言控制面板允许您添加模式字符串来和请求或响应的各个字段进行比较。模式字符串是：     &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;包括&lt;/code&gt;，&lt;code&gt;匹配&lt;/code&gt;：Perl5风格的正则表达式&lt;/li&gt;
&lt;li&gt;&lt;code&gt;相等&lt;/code&gt;，&lt;code&gt;字符串&lt;/code&gt;：纯文本，区分大小写&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;模式匹配字符的摘要可以参阅&lt;a href="http://jakarta.apache.org/oro/api/org/apache/oro/text/regex/package-summary.html"&gt;ORO Perl5正则表达式&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;您还可以选择是否期望字符串与整个响应&lt;strong&gt;匹配&lt;/strong&gt;，或者是否仅期望响应&lt;strong&gt;包括&lt;/strong&gt;该模式。您可以将多个断言附加到任何控制器，以获得额外的灵活性。&lt;/p&gt;
&lt;p&gt;注意模式字符串不应包含封闭分隔符，即使用&lt;code&gt;Price: \d+&lt;/code&gt;而不是&lt;code&gt;/Price: \d+/&lt;/code&gt;。     &lt;/p&gt;
&lt;p&gt;默认情况下，模式处于多行模式，这意味着“&lt;code&gt;.&lt;/code&gt;”元字符与换行符不匹配。在多行模式下，“&lt;code&gt;^&lt;/code&gt;”和“&lt;code&gt;$&lt;/code&gt;”匹配字符串中任何位置的任何行的开头或结尾 - 而不仅仅是整个字符串的开头和结尾。请注意&lt;code&gt;\s&lt;/code&gt;确实匹配换行符。不忽略大小写。要覆盖这些设置，可以使用&lt;em&gt;扩展的正则表达式&lt;/em&gt;语法。例如： &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;(?i)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;忽略大小写&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;(?s)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;将目标视为单行，即“&lt;code&gt;.&lt;/code&gt;”匹配新行&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;(?is)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;以上都是&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这些可以在表达式中的任何位置使用，并在被覆盖之前保持有效。例如 &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;(?i)apple(?-i) Pie&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;匹配“&lt;code&gt;ApPLe Pie&lt;/code&gt;”，但不匹配“&lt;code&gt;ApPLe pIe&lt;/code&gt;”&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;(?s)Apple.+?Pie&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;匹配&lt;code&gt;Apple&lt;/code&gt;，然后是&lt;code&gt;Pie&lt;/code&gt;，后者可能会在后续行中。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Apple(?s).+?Pie&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;与上面相同，但在开始时使用&lt;code&gt;(?s)&lt;/code&gt;可能更清楚。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="Screenshot for Control-Panel of Response Assertion" src="http://jmeter.apache.org/images/screenshots/assertion/assertion.png"&gt;&lt;br&gt;
&lt;em&gt;响应断言控制面板的截图&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参数&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th align="left"&gt;是否必须&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;名称&lt;/td&gt;
&lt;td&gt;树中显示的此元件的描述性名称。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Apply to:&lt;/td&gt;
&lt;td&gt;这适用于可以生成子样本的取样器，例如带有内嵌资源的HTTP取样器，邮件阅读者或事务控制器生成的样本。&lt;ul&gt;&lt;li&gt;&lt;code&gt;Main sample only&lt;/code&gt; - 仅适用于主样本&lt;/li&gt;&lt;li&gt;&lt;code&gt;Sub-samples only&lt;/code&gt; - 仅适用于子样本&lt;/li&gt;&lt;li&gt;&lt;code&gt;Main sample and sub-samples&lt;/code&gt; - 适用于两者。&lt;/li&gt;&lt;li&gt;&lt;code&gt;JMeter Variable Name to use&lt;/code&gt; - 断言将应用于命名变量的内容&lt;/li&gt;&lt;/ul&gt;&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;测试字段&lt;/td&gt;
&lt;td&gt;指示JMeter测试请求或响应的哪个字段。&lt;ul&gt;&lt;li&gt;&lt;code&gt;响应文本&lt;/code&gt; - 来自服务器的响应文本（即消息体），不包括任何HTTP信息头。&lt;/li&gt;&lt;li&gt;&lt;code&gt;请求数据&lt;/code&gt; - 发送到服务器的请求文本（即消息体），不包括任何HTTP信息头。&lt;/li&gt;&lt;li&gt;&lt;code&gt;响应代码&lt;/code&gt; - 例如&lt;code&gt;200&lt;/code&gt;&lt;/li&gt;&lt;li&gt;&lt;code&gt;响应信息&lt;/code&gt; - 例如&lt;code&gt;OK&lt;/code&gt;&lt;/li&gt;&lt;li&gt;&lt;code&gt;响应头&lt;/code&gt;，包括Set-Cookie信息头（如果有）&lt;/li&gt;&lt;li&gt;&lt;code&gt;请求头&lt;/code&gt;&lt;/li&gt;&lt;li&gt;&lt;code&gt;URL样本&lt;/code&gt;&lt;/li&gt;&lt;li&gt;&lt;code&gt;文档（文本）&lt;/code&gt; - 通过Apache Tika从各种类型的文档中提取文本（请参阅&lt;a href="http://jmeter.apache.org/usermanual/component_reference.html#View_Results_Tree"&gt;查看结果树&lt;/a&gt;文档视图部分）。&lt;/li&gt;&lt;/ul&gt;&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;忽略状态&lt;/td&gt;
&lt;td&gt;指示JMeter将状态初始化为成功。&lt;br /&gt;通过将断言的结果与现有的响应状态相结合来确定样本的总体成功。当&lt;code&gt;忽略状态&lt;/code&gt;复选框选中后，在评估断言之前，将强制响应状态为成功。&lt;br /&gt;在&lt;code&gt;4xx&lt;/code&gt;和&lt;code&gt;5xx&lt;/code&gt;范围内状态的HTTP响应通常被视为不成功。在执行进一步检查之前，“&lt;code&gt;忽略状态&lt;/code&gt;”复选框可用于设置状态成功。请注意，这将清除任何先前的断言失败，因此请确保仅在第一个断言上设置此操作。&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;模式匹配规则&lt;/td&gt;
&lt;td&gt;指示如何根据模式检查正在测试的文本。&lt;ul&gt;&lt;li&gt;&lt;code&gt;包括&lt;/code&gt; - 如果文本包含正则表达式模式，则为true&lt;/li&gt;&lt;li&gt;&lt;code&gt;匹配&lt;/code&gt; - 如果整个文本与正则表达式模式匹配，则为true&lt;/li&gt;&lt;li&gt;&lt;code&gt;相等&lt;/code&gt; - 如果整个文本等于模式字符串（区分大小写），则为true&lt;/li&gt;&lt;li&gt;&lt;code&gt;Substring&lt;/code&gt; - 如果文本包含模式字符串，则为true（区分大小写）&lt;/li&gt;&lt;/ul&gt;&lt;code&gt;相等&lt;/code&gt;和&lt;code&gt;Substring&lt;/code&gt;模式是纯字符串，而不是正则表达式。也可以选择&lt;code&gt;NOT&lt;/code&gt;来反转检查结果。或者在&lt;code&gt;OR&lt;/code&gt;组合中应用每个断言（如果1个模式测试中能够匹配，断言就通过）而不是AND（所有模式必须匹配，断言才能通过）。&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;要测试的模式&lt;/td&gt;
&lt;td&gt;要测试的模式列表。每个模式都单独测试。如果一个模式失败，则后续的模式不再检查。使用多个模式设置一个断言和使用一个模式设置多个断言之间没有区别（假设其他选项相同）。&lt;blockquote&gt;但是，当选中“&lt;code&gt;忽略状态&lt;/code&gt;”复选框时，这会取消先前的任何断言失败 - 因此请确保“&lt;code&gt;忽略状态&lt;/code&gt;”复选框仅用于第一个断言。&lt;/blockquote&gt;&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;自定义失败消息&lt;/td&gt;
&lt;td&gt;允许您定义将替换生成的失败消息&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;该模式是Perl5样式的正则表达式，但没有括号。&lt;/p&gt;
&lt;blockquote&gt;
&lt;h4 id="_43"&gt;断言实例&lt;/h4&gt;
&lt;p&gt;&lt;img alt="Figure 14 - Test Plan" src="http://jmeter.apache.org/images/screenshots/assertion/example1a.png"&gt;
&lt;em&gt;图14 - 测试计划&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="Figure 15 - Assertion Control Panel with Pattern" src="http://jmeter.apache.org/images/screenshots/assertion/example1b.png"&gt;
&lt;em&gt;图15 - 带模式的断言控制面板&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="Figure 16 - Assertion Listener Results (Pass)" src="http://jmeter.apache.org/images/screenshots/assertion/example1c-pass.png"&gt;
&lt;em&gt;图16 - 断言监听器结果（通过）&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="Figure 17 - Assertion Listener Results (Fail)" src="http://jmeter.apache.org/images/screenshots/assertion/example1c-fail.png"&gt;
&lt;em&gt;图17 - 断言监听器结果（失败）&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href="#toc"&gt;【返回目录】&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="_44"&gt;断言持续时间&lt;/h3&gt;
&lt;p&gt;断言持续时间测试在给定的时间内收到每个响应。任何花费超过给定毫秒数（由用户指定）的响应都会标记为失败的响应。&lt;/p&gt;
&lt;p&gt;&lt;img alt="Screenshot for Control-Panel of Duration Assertion" src="http://jmeter.apache.org/images/screenshots/duration_assertion.png"&gt;&lt;br&gt;
&lt;em&gt;断言持续时间控制面板的截图&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参数&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th align="left"&gt;是否必须&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;名称&lt;/td&gt;
&lt;td&gt;树中显示的此元件的描述性名称。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;持续时间（毫秒）&lt;/td&gt;
&lt;td&gt;在标记为失败之前允许的每个响应的最大毫秒数。&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;a href="#toc"&gt;【返回目录】&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="_45"&gt;大小断言&lt;/h3&gt;
&lt;p&gt;大小断言测试每个响应中包含正确的字节数。您可以指定大小等于，大于，小于或不等于给定的字节数。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;空响应被视为0字节而不是报告为错误。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img alt="Screenshot for Control-Panel of Size Assertion" src="http://jmeter.apache.org/images/screenshots/size_assertion.png"&gt;&lt;br&gt;
&lt;em&gt;大小断言控制面板的截图&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参数&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th align="left"&gt;是否必须&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;名称&lt;/td&gt;
&lt;td&gt;树中显示的此元件的描述性名称。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Apply to:&lt;/td&gt;
&lt;td&gt;这适用于可以生成子样本的取样器，例如带有内嵌资源的HTTP取样器，邮件阅读者或事务控制器生成的样本。&lt;ul&gt;&lt;li&gt;&lt;code&gt;Main sample only&lt;/code&gt; - 仅适用于主样本&lt;/li&gt;&lt;li&gt;&lt;code&gt;Sub-samples only&lt;/code&gt; - 仅适用于子样本&lt;/li&gt;&lt;li&gt;&lt;code&gt;Main sample and sub-samples&lt;/code&gt; - 适用于两者。&lt;/li&gt;&lt;li&gt;&lt;code&gt;JMeter Variable Name to use&lt;/code&gt; - 断言将应用于命名变量的内容&lt;/li&gt;&lt;/ul&gt;&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;字节大小&lt;/td&gt;
&lt;td&gt;用于测试响应大小（或JMeter变量值）的字节数。&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;比较类型&lt;/td&gt;
&lt;td&gt;是否测试响应是否等于，大于，小于或不等于指定的字节数。&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;a href="#toc"&gt;【返回目录】&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="xml"&gt;XML断言&lt;/h3&gt;
&lt;p&gt;XML断言测试响应数据由正式的XML文档组成。它不会基于DTD或模式来验证XML，也不会进行任何进一步的验证。&lt;/p&gt;
&lt;p&gt;&lt;img alt="Screenshot for Control-Panel of XML Assertion" src="http://jmeter.apache.org/images/screenshots/xml_assertion.png"&gt;&lt;br&gt;
&lt;em&gt;XML断言控件面板的截图&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参数&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th align="left"&gt;是否必须&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;名称&lt;/td&gt;
&lt;td&gt;树中显示的此元件的描述性名称。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;a href="#toc"&gt;【返回目录】&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="beanshell_2"&gt;BeanShell断言&lt;/h3&gt;
&lt;p&gt;BeanShell断言允许用户使用BeanShell脚本执行断言检查。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;有关使用BeanShell的完整详细信息，请参阅&lt;a href="http://www.beanshell.org/"&gt;BeanShell网站&lt;/a&gt;。&lt;/strong&gt;  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;强烈建议迁移到&lt;a href="http://jmeter.apache.org/usermanual/component_reference.html#JSR223_Sampler"&gt;JSR223 Sampler&lt;/a&gt;+Groovy以提高性能，支持新的Java功能并限制BeanShell库的维护。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;请注意，在测试脚本的每个线程中，每个独立出现的断言都使用不同的解释器，但是相同的解释器用于后续调用。这意味着变量会在对断言的调用中持续存在。&lt;/p&gt;
&lt;p&gt;所有断言都是从与取样器相同的线程调用的。&lt;/p&gt;
&lt;p&gt;如果定义了属性“&lt;code&gt;beanshell.assertion.init&lt;/code&gt;”，则将其作为源文件的名称传递给解释器。这可以用于定义常用方法和变量。&lt;code&gt;bin&lt;/code&gt;目录中有一个示例init文件：&lt;code&gt;BeanShellAssertion.bshrc&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;测试元件支持&lt;code&gt;ThreadListener&lt;/code&gt;和&lt;code&gt;TestListener&lt;/code&gt;方法。这些应该在初始化文件中定义。有关示例定义，请参阅文件&lt;code&gt;BeanShellListeners.bshrc&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img alt="Screenshot for Control-Panel of BeanShell Assertion" src="http://jmeter.apache.org/images/screenshots/beanshell_assertion.png"&gt;&lt;br&gt;
&lt;em&gt;BeanShell断言控件面板的截图&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参数&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th align="left"&gt;是否必须&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;名称&lt;/td&gt;
&lt;td&gt;树中显示的此取样器的描述性名称。该名称存储在脚本变量Label中&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;每次调用前重置bsh.Interpreter&lt;/td&gt;
&lt;td&gt;如果选择此选项，则将为每个样本重新创建解释器。对于某些长时间运行的脚本，这可能是必需的。有关详细信息请参阅&lt;a href="http://jmeter.apache.org/usermanual/best-practices#bsh_scripting"&gt;最佳实践 -  BeanShell脚本&lt;/a&gt;。&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;参数&lt;/td&gt;
&lt;td&gt;要传递给BeanShell脚本的参数。参数存储在以下变量中：&lt;ul&gt;&lt;li&gt;&lt;code&gt;Parameters&lt;/code&gt;：包含参数的字符串，作为单个变量&lt;/li&gt;&lt;li&gt;&lt;code&gt;bsh.args&lt;/code&gt;：包含参数的字符串数组，在空格处分割&lt;/li&gt;&lt;/ul&gt;&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;脚本文件&lt;/td&gt;
&lt;td&gt;包含要运行的BeanShell脚本的文件。这会覆盖脚本。文件名存储在脚本变量&lt;code&gt;FileName&lt;/code&gt;中&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;脚本&lt;/td&gt;
&lt;td&gt;要运行的BeanShell脚本。忽略返回值。&lt;/td&gt;
&lt;td align="left"&gt;是（除非提供脚本文件）&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;您可以尝试一个&lt;a href="http://jmeter.apache.org/demos/BeanShellAssertion.bsh"&gt;示例脚本&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;在调用脚本之前，在BeanShell解释器中设置了一些变量。这些没有另外说明，都是字符串：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;log&lt;/code&gt; - &lt;a href="https://www.slf4j.org/api/org/slf4j/Logger.html"&gt;记录器&lt;/a&gt;对象。（例如）&lt;code&gt;log.warn("Message"[,Throwable])&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;SampleResult&lt;/code&gt;，&lt;code&gt;prev&lt;/code&gt; - &lt;a href="http://jmeter.apache.org/api/org/apache/jmeter/samplers/SampleResult.html"&gt;SampleResult&lt;/a&gt;对象; 可读-可写&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Response&lt;/code&gt; - 响应对象; 可读-可写&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Failure&lt;/code&gt; - 布尔值; 可读-可写; 用于设置断言状态&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;FailureMessage&lt;/code&gt; - 字符串; 可读-可写; 用于设置断言消息&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;ResponseData&lt;/code&gt; - 响应消息体（byte[]）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;ResponseCode&lt;/code&gt; - 例如&lt;code&gt;200&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;ResponseMessage&lt;/code&gt; - 例如&lt;code&gt;OK&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;ResponseHeaders&lt;/code&gt; - 包含HTTP信息头&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;RequestHeaders&lt;/code&gt; - 包含发送到服务器的HTTP信息头&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;SampleLabel&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;SamplerData&lt;/code&gt; - 发送到服务器的数据&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;ctx&lt;/code&gt; - &lt;a href="http://jmeter.apache.org/api/org/apache/jmeter/threads/JMeterContext.html"&gt;JMeterContext&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;vars&lt;/code&gt; - &lt;a href="http://jmeter.apache.org/api/org/apache/jmeter/threads/JMeterVariables.html"&gt;JMeterVariables&lt;/a&gt; - 例如&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    vars.get(&amp;quot;VAR1&amp;quot;);
        vars.put(&amp;quot;VAR2&amp;quot;,&amp;quot;value&amp;quot;);
        vars.putObject(&amp;quot;OBJ1&amp;quot;,new Object());
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;props&lt;/code&gt; - JMeterProperties（&lt;code&gt;java.util.Properties&lt;/code&gt;类） - 例如&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    props.get(&amp;quot;START.HMS&amp;quot;);
        props.put(&amp;quot;PROP1&amp;quot;,&amp;quot;1234&amp;quot;);
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;响应对象的下列方法可能很有用：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;setStopThread(boolean)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;setStopTest(boolean)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;String getSampleLabel()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;setSampleLabel(String)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href="#toc"&gt;【返回目录】&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="md5hex"&gt;MD5Hex断言&lt;/h3&gt;
&lt;p&gt;MD5Hex断言允许用户检查响应数据的MD5哈希值。&lt;/p&gt;
&lt;p&gt;&lt;img alt="Screenshot for Control-Panel of MD5Hex Assertion" src="http://jmeter.apache.org/images/screenshots/assertion/MD5HexAssertion.png"&gt;&lt;br&gt;
&lt;em&gt;MD5Hex断言控制面板的截图&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参数&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th align="left"&gt;是否必须&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;名称&lt;/td&gt;
&lt;td&gt;树中显示的此元件的描述性名称。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;MD5Hex&lt;/td&gt;
&lt;td&gt;表示MD5哈希的32位十六进制数字（不区分大小写）&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;a href="#toc"&gt;【返回目录】&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="html"&gt;HTML断言&lt;/h3&gt;
&lt;p&gt;HTML断言允许用户使用JTidy检查响应数据的HTML语法。&lt;/p&gt;
&lt;p&gt;&lt;img alt="Screenshot for Control-Panel of HTML Assertion" src="http://jmeter.apache.org/images/screenshots/assertion/HTMLAssertion.png"&gt;&lt;br&gt;
&lt;em&gt;HTML断言控制面板的截图&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参数&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th align="left"&gt;是否必须&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;名称&lt;/td&gt;
&lt;td&gt;树中显示的此元件的描述性名称。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;doctype&lt;/td&gt;
&lt;td&gt;&lt;code&gt;omit&lt;/code&gt;，&lt;code&gt;auto&lt;/code&gt;，&lt;code&gt;strict&lt;/code&gt;或&lt;code&gt;oose&lt;/code&gt;&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Format&lt;/td&gt;
&lt;td&gt;&lt;code&gt;HTML&lt;/code&gt;，&lt;code&gt;XHTML&lt;/code&gt;或&lt;code&gt;XML&lt;/code&gt;&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Errors only&lt;/td&gt;
&lt;td&gt;只记录错误？&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Error threshold&lt;/td&gt;
&lt;td&gt;在将响应归类为失败之前允许的错误数&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Warning threshold&lt;/td&gt;
&lt;td&gt;在将响应归类为失败之前允许的警告数&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;文件名&lt;/td&gt;
&lt;td&gt;写入报告的文件的名称&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;a href="#toc"&gt;【返回目录】&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="xpath"&gt;XPath断言&lt;/h3&gt;
&lt;p&gt;XPath断言测试文档的格式是否良好，可以选择验证DTD，或者通过JTidy转换文档并测试XPath。如果该XPath存在，则断言为真。使用“&lt;code&gt;/&lt;/code&gt;”将匹配任何格式良好的文档，并且是默认的XPath表达式。断言还支持布尔表达式，例如“&lt;code&gt;count(//*error)=2&lt;/code&gt;”。有关XPath的更多信息，请参见&lt;a href="http://www.w3.org/TR/xpath"&gt;http://www.w3.org/TR/xpath&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;一些示例表达式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;//title[text()='Text to match']&lt;/code&gt; - 匹配响应中任何位置的&lt;code&gt;&amp;lt;title&amp;gt;Text to match&amp;lt;/title&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/title[text()='Text to match']&lt;/code&gt; - 匹配响应的根节点的&lt;code&gt;&amp;lt;title&amp;gt;Text to match&amp;lt;/title&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="Screenshot for Control-Panel of XPath Assertion" src="http://jmeter.apache.org/images/screenshots/xpath_assertion.png"&gt;&lt;br&gt;
&lt;em&gt;XPath断言控制面板的截图&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参数&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th align="left"&gt;是否必须&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;名称&lt;/td&gt;
&lt;td&gt;树中显示的此元件的描述性名称。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Use Tidy (tolerant parser)&lt;/td&gt;
&lt;td&gt;使用Tidy，即容忍XML/HTML错误&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Quiet&lt;/td&gt;
&lt;td&gt;设置Tidy Quiet标志&lt;/td&gt;
&lt;td align="left"&gt;如果选择了Tidy&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Report Errors&lt;/td&gt;
&lt;td&gt;如果发生Tidy错误，则相应地设置断言&lt;/td&gt;
&lt;td align="left"&gt;如果选择了Tidy&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Show warnings&lt;/td&gt;
&lt;td&gt;设置Tidy显示警告选项&lt;/td&gt;
&lt;td align="left"&gt;如果选择了Tidy&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Use Namespaces&lt;/td&gt;
&lt;td&gt;命名空间应该被尊重吗？（见下面关于命名空间的说明）&lt;/td&gt;
&lt;td align="left"&gt;如果未选择Tidy&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Validate XML&lt;/td&gt;
&lt;td&gt;根据其架构检查文档。&lt;/td&gt;
&lt;td align="left"&gt;如果未选择Tidy&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Ignore Whitespace&lt;/td&gt;
&lt;td&gt;忽略元件中空格。&lt;/td&gt;
&lt;td align="left"&gt;如果未选择Tidy&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Fetch External DTDs&lt;/td&gt;
&lt;td&gt;如果选中，则获取外部DTD。&lt;/td&gt;
&lt;td align="left"&gt;如果未选择Tidy&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;XPath Assertion&lt;/td&gt;
&lt;td&gt;要在文档中匹配的XPath。&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;True if nothing matches&lt;/td&gt;
&lt;td&gt;如果XPath表达式不匹配，则为True&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;blockquote&gt;
&lt;p&gt;非容忍解析器可能非常慢，因为它可能需要下载DTD等。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;命名空间&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;作为Xalan XPath解析器（JMeter所基于的实现）限制的命名空间的工作轮，您需要：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;提供一个属性文件（例如，如果您的文件名为namespaces.properties），其中包含名称空间前缀的映射：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    prefix1=http\://foo.apache.org
        prefix2=http\://toto.apache.org
    …
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用如下属性在&lt;code&gt;user.properties&lt;/code&gt;文件中引用此文件：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    xpath.namespace.config=namespaces.properties
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href="#toc"&gt;【返回目录】&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="xml-schema"&gt;XML Schema断言&lt;/h3&gt;
&lt;p&gt;XML Schema断言允许用户验证针对XML Schema的响应。&lt;/p&gt;
&lt;p&gt;&lt;img alt="Screenshot for Control-Panel of XML Schema Assertion" src="http://jmeter.apache.org/images/screenshots/assertion/XMLSchemaAssertion.png"&gt;&lt;br&gt;
&lt;em&gt;XML Schema断言控制面板的截图&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参数&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th align="left"&gt;是否必须&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;名称&lt;/td&gt;
&lt;td&gt;树中显示的此元件的描述性名称。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;文件名&lt;/td&gt;
&lt;td&gt;指定XML Schema的文件名&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;a href="#toc"&gt;【返回目录】&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="jsr223_1"&gt;JSR223断言&lt;/h3&gt;
&lt;p&gt;JSR223断言允许使用JSR223脚本代码来检查上一个样本的状态。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参数&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th align="left"&gt;是否必须&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;名称&lt;/td&gt;
&lt;td&gt;树中显示的此元件的描述性名称。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;语言&lt;/td&gt;
&lt;td&gt;要使用的JSR223语言。&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;参数&lt;/td&gt;
&lt;td&gt;要传递给脚本的参数。参数存储在以下变量中：&lt;ul&gt;&lt;li&gt;&lt;code&gt;Parameters&lt;/code&gt;：包含参数的字符串，作为单个变量&lt;/li&gt;&lt;li&gt;&lt;code&gt;bsh.args&lt;/code&gt;：包含参数的字符串数组，在空格处分割&lt;/li&gt;&lt;/ul&gt;&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;脚本文件&lt;/td&gt;
&lt;td&gt;包含要运行的脚本的文件，如果使用相对文件路径，则它将相对于系统属性“&lt;code&gt;user.dir&lt;/code&gt;” 所引用的目录&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;缓存编译脚本（如果可用）&lt;/td&gt;
&lt;td&gt;测试计划中的唯一字符串，如果使用的语言支持&lt;a href="https://docs.oracle.com/javase/8/docs/api/javax/script/Compilable.html"&gt;Compilable&lt;/a&gt;接口（Groovy是其中之一，java，BeanShell和JavaScript不是），则JMeter将用于缓存脚本编译的结果&lt;blockquote&gt;如果您在不检查此选项的情况下使用Groovy，请参阅JSR223取样器Java系统属性中的注释&lt;/blockquote&gt;&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;脚本&lt;/td&gt;
&lt;td&gt;要运行的脚本。&lt;/td&gt;
&lt;td align="left"&gt;是（除非提供脚本文件）&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;设置以下变量供脚本使用：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;log&lt;/code&gt; - （&lt;a href="https://www.slf4j.org/api/org/slf4j/Logger.html"&gt;Logger&lt;/a&gt;） - 可用于写入日志文件&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Label&lt;/code&gt; - 字符串标签&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Filename&lt;/code&gt; - 脚本文件名（如果有）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Parameters&lt;/code&gt; - 参数（作为字符串）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;args&lt;/code&gt; - 作为String数组的参数（在空格上拆分）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;ctx&lt;/code&gt; - （&lt;a href="http://jmeter.apache.org/api/org/apache/jmeter/threads/JMeterContext.html"&gt;JMeterContext&lt;/a&gt;） - 允许访问上下文&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;vars&lt;/code&gt; - （&lt;a href="http://jmeter.apache.org/api/org/apache/jmeter/threads/JMeterVariables.html"&gt;JMeterVariables&lt;/a&gt;） - 提供对变量的读/写访问：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    vars.get(key);
    vars.put(key,val);
    vars.putObject(&amp;quot;OBJ1&amp;quot;,new Object());
    vars.getObject(&amp;quot;OBJ2&amp;quot;);
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;props&lt;/code&gt; - （JMeterProperties - &lt;a href="https://docs.oracle.com/javase/8/docs/api/java/util/Properties.html"&gt;java.util.Properties&lt;/a&gt;类） - 例如&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    props.get(&amp;quot;START.HMS&amp;quot;);
        props.put(&amp;quot;PROP1&amp;quot;,&amp;quot;1234&amp;quot;);
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;SampleResult&lt;/code&gt;，&lt;code&gt;prev&lt;/code&gt; - （&lt;a href="http://jmeter.apache.org/api/org/apache/jmeter/samplers/SampleResult.html"&gt;SampleResult&lt;/a&gt;） - 提供对前一个取样器结果的访问（如果有的话）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;sampler&lt;/code&gt; - （&lt;a href="http://jmeter.apache.org/api/org/apache/jmeter/samplers/Sampler.html"&gt;Sampler&lt;/a&gt;） - 提供对当前取样器的访问&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;OUT&lt;/code&gt; - &lt;code&gt;System.out&lt;/code&gt; - 例如&lt;code&gt;OUT.println("message")&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;AssertionResult&lt;/code&gt; - （&lt;a href="http://jmeter.apache.org/api/org/apache/jmeter/assertions/AssertionResult.html"&gt;AssertionResult&lt;/a&gt;） - 断言结果&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;该脚本可以检查&lt;a href="http://jmeter.apache.org/api/org/apache/jmeter/samplers/SampleResult.html"&gt;SampleResult&lt;/a&gt;的各个方面。如果检测到错误，脚本应使用&lt;code&gt;AssertionResult.setFailureMessage("message")&lt;/code&gt;和&lt;code&gt;AssertionResult.setFailure(true)&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;有关上述每个变量的所有可用方法的更多详细信息，请查看Javadoc。&lt;/p&gt;
&lt;p&gt;&lt;a href="#toc"&gt;【返回目录】&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="_46"&gt;比较断言&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;在压力测试期间&lt;strong&gt;不得使用&lt;/strong&gt;比较断言，因为它会消耗大量资源（内存和CPU）。仅用于功能测试或测试计划调试和验证期间。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;比较断言可用于比较其范围内的样本结果。可以比较内容或经过的时间，并且可以在比较之前过滤内容。断言比较结果可以在&lt;a href="http://jmeter.apache.org/usermanual/component_reference.html#Comparison_Assertion_Visualizer"&gt;比较断言可视化器&lt;/a&gt;中看到。&lt;/p&gt;
&lt;p&gt;&lt;img alt="Screenshot for Control-Panel of Compare Assertion" src="http://jmeter.apache.org/images/screenshots/assertion/compare.png"&gt;&lt;br&gt;
&lt;em&gt;比较断言控制面板的截图&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参数&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th align="left"&gt;是否必须&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;名称&lt;/td&gt;
&lt;td&gt;树中显示的此元件的描述性名称。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;比较的内容&lt;/td&gt;
&lt;td&gt;是否比较内容（响应数据）&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;比较的时间&lt;/td&gt;
&lt;td&gt;如果该值≥0，则检查响应时间差是否不大于该值。即如果值为&lt;code&gt;0&lt;/code&gt;，则响应时间必须完全相等。&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;比较过滤器&lt;/td&gt;
&lt;td&gt;过滤器可用于从内容比较中删除字符串。例如，如果页面有时间戳，并且与以下内容匹配：“&lt;code&gt;Time: \d\d:\d\d:\d\d&lt;/code&gt;”，它可以被替换为虚拟固定时间“&lt;code&gt;Time: HH:MM:SS&lt;/code&gt;“。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;a href="#toc"&gt;【返回目录】&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="smime"&gt;SMIME断言&lt;/h3&gt;
&lt;p&gt;SMIME断言可用于评估邮件阅读者取样器的样本结果。此断言验证mime消息的正文是否已签名。还可以针对特定签署者证书来验证签名。由于这是大多数用户不一定需要的功能，因此需要下载额外的jar并将其添加到&lt;code&gt;JMETER_HOME/lib&lt;/code&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;bcmail-xxx.jar&lt;/code&gt;（BouncyCastle SMIME/CMS）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;bcprov-xxx.jar&lt;/code&gt;（BouncyCastle Provider）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这些需要&lt;a href="http://www.bouncycastle.org/latest_releases.html"&gt;从BouncyCastle下载&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;如果使用&lt;a href="http://jmeter.apache.org/usermanual/component_reference.html#Mail_Reader_Sampler"&gt;邮件阅读者取样器&lt;/a&gt;，请确保选择“&lt;code&gt;Store the message using MIME (raw)&lt;/code&gt;”，否则断言将无法正确处理消息。&lt;/p&gt;
&lt;p&gt;&lt;img alt="Screenshot for Control-Panel of SMIME Assertion" src="http://jmeter.apache.org/images/screenshots/assertion/smime.png"&gt;&lt;br&gt;
&lt;em&gt;SMIME断言控制面板的屏幕截图&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参数&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th align="left"&gt;是否必须&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;名称&lt;/td&gt;
&lt;td&gt;树中显示的此元件的描述性名称。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Verify Signature&lt;/td&gt;
&lt;td&gt;如果选中，则断言将根据“&lt;code&gt;Signer Certificate&lt;/code&gt;”框中定义的参数验证它是否是有效签名。&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Message not signed&lt;/td&gt;
&lt;td&gt;是否期望在消息中签名&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Signer Certificate&lt;/td&gt;
&lt;td&gt;“&lt;code&gt;No Check&lt;/code&gt;”表示它不会执行签名验证。“&lt;code&gt;Check values&lt;/code&gt;”用于根据提供的输入验证签名。并且“&lt;code&gt;Certificate file&lt;/code&gt;”将针对特定证书文件执行验证。&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Message Position&lt;/td&gt;
&lt;td&gt;Mail取样器可以在单个样本中检索多条消息。使用此字段指定要检查的邮件。消息从&lt;code&gt;0&lt;/code&gt;开始编号，因此&lt;code&gt;0&lt;/code&gt;表示第一条消息。负数从最后的消息开始计算； &lt;code&gt;-1&lt;/code&gt;表示最后，&lt;code&gt;-2&lt;/code&gt;表示倒数第二个等。&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;a href="#toc"&gt;【返回目录】&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="json"&gt;JSON断言&lt;/h3&gt;
&lt;p&gt;此组件允许您执行JSON文档的验证。首先，如果数据不是JSON格式，它将解析失败。其次，它将使用&lt;a href="https://github.com/jayway/JsonPath"&gt;Jayway JsonPath 1.2.0&lt;/a&gt;的语法搜索指定的路径。如果找不到路径，则会失败。第三，如果在文档中找到JSON路径，并且请求了对期望值的验证，则它将执行验证。对于&lt;code&gt;null&lt;/code&gt;值，GUI中有特殊复选框。注意，如果路径返回数组对象，则对其进行迭代；如果找到预期值，则断言将成功。验证空数组使用字符串&lt;code&gt;[]&lt;/code&gt;。此外，如果patch返回字典对象，它将在比较之前转换为字符串。&lt;/p&gt;
&lt;p&gt;&lt;img alt="Screenshot for Control-Panel of JSON Assertion" src="http://jmeter.apache.org/images/screenshots/assertion/json_assertion.png"&gt;&lt;br&gt;
&lt;em&gt;JSON断言控制面板的截图&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参数&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th align="left"&gt;是否必须&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;名称&lt;/td&gt;
&lt;td&gt;树中显示的此元件的描述性名称。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Assert JSON Path exists&lt;/td&gt;
&lt;td&gt;JSON元件路径的断言。&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Additionally assert value&lt;/td&gt;
&lt;td&gt;如果要使断言具有某个值，请选中复选框&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Match as regular expression&lt;/td&gt;
&lt;td&gt;如果要使用正则表达式，请选中复选框&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Expected Value&lt;/td&gt;
&lt;td&gt;匹配的断言或正则表达式的值&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Expect null&lt;/td&gt;
&lt;td&gt;如果希望null，请选中复选框&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Invert assertion (will fail if above conditions met)&lt;/td&gt;
&lt;td&gt;反转断言（如果符合上述条件，将失败）&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;a href="#toc"&gt;【返回目录】&lt;/a&gt;&lt;/p&gt;
&lt;h2 id="186"&gt;18.6 定时器&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;从3.1版本开始，一个新的特性（Beta模式下，从JMeter3.1开始后续可能会有变更）已经被实现，它提供下列特性。&lt;/p&gt;
&lt;p&gt;您可以通过设置属性&lt;code&gt;timer.factor=float number&lt;/code&gt;来对随机定时器计算的睡眠延迟应用乘法因子，其中float number是十进制正数。&lt;/p&gt;
&lt;p&gt;JMeter会将此因子乘以计算的睡眠延迟。此功能可用于：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://jmeter.apache.org/usermanual/component_reference.html#Gaussian_Random_Timer"&gt;高斯随机定时器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://jmeter.apache.org/usermanual/component_reference.html#Poisson_Random_Timer"&gt;泊松随机计时器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://jmeter.apache.org/usermanual/component_reference.html#Uniform_Random_Timer"&gt;统一随机定时器&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;注意，定时器在它们的范围内的所有取样器&lt;strong&gt;之前&lt;/strong&gt;被处理；如果在同一范围内有多个定时器，则&lt;strong&gt;在所有&lt;/strong&gt;取样器&lt;strong&gt;之前&lt;/strong&gt;处理&lt;strong&gt;所有&lt;/strong&gt;定时器。 &lt;/p&gt;
&lt;p&gt;定时器仅与取样器一起处理。与取样器不在同一范围内的定时器不会被处理。 &lt;/p&gt;
&lt;p&gt;要将定时器应用于单个取样器，请将定时器添加为取样器的子元件。定时器将在执行取样器之前应用。要在取样器之后应用计时器，请将其添加到下一个取样器，或将其添加为&lt;a href="http://jmeter.apache.org/usermanual/component_reference.html#Flow_Control_Action"&gt;测试活动&lt;/a&gt;取样器的子级。 &lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id="_47"&gt;固定定时器&lt;/h3&gt;
&lt;p&gt;如果要让每个线程在请求之间暂停相同的时间，请使用此定时器。&lt;/p&gt;
&lt;p&gt;&lt;img alt="Screenshot for Control-Panel of Constant Timer" src="http://jmeter.apache.org/images/screenshots/timers/constant_timer.png"&gt;&lt;br&gt;
&lt;em&gt;固定定时器控制面板的截图&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参数&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th align="left"&gt;是否必须&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;名称&lt;/td&gt;
&lt;td&gt;树中显示的此定时器的描述性名称。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;线程延迟&lt;/td&gt;
&lt;td&gt;暂停的毫秒数。&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;a href="#toc"&gt;【返回目录】&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="_48"&gt;高斯随机定时器&lt;/h3&gt;
&lt;p&gt;该定时器暂停每个线程请求一段随机时间，大部分时间间隔发生在特定值附近。总延迟是高斯分布值（平均值为&lt;code&gt;0.0&lt;/code&gt;，标准差为&lt;code&gt;1.0&lt;/code&gt;）乘以指定偏差值，再加上偏移值之和。另一种解释是，在高斯随机定时器中，固定偏移周围的变化具有高斯曲线分布。&lt;/p&gt;
&lt;p&gt;&lt;img alt="Screenshot for Control-Panel of Gaussian Random Timer" src="http://jmeter.apache.org/images/screenshots/timers/gauss_random_timer.png"&gt;&lt;br&gt;
&lt;em&gt;高斯随机定时器控制面板的截图&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参数&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th align="left"&gt;是否必须&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;名称&lt;/td&gt;
&lt;td&gt;树中显示的此元件的描述性名称。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;偏差&lt;/td&gt;
&lt;td&gt;偏差，以毫秒为单位。&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;固定延迟偏移&lt;/td&gt;
&lt;td&gt;除随机延迟之外暂停的毫秒数。&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;a href="#toc"&gt;【返回目录】&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="_49"&gt;统一随机定时器&lt;/h3&gt;
&lt;p&gt;该定时器暂停每个线程请求一段随机时间，每个时间间隔具有相同的发生概率。总延迟是随机值和偏移值之和。&lt;/p&gt;
&lt;p&gt;&lt;img alt="Screenshot for Control-Panel of Uniform Random Timer" src="http://jmeter.apache.org/images/screenshots/timers/uniform_random_timer.png"&gt;&lt;br&gt;
&lt;em&gt;统一随机定时器控制面板的截图&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参数&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th align="left"&gt;是否必须&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;名称&lt;/td&gt;
&lt;td&gt;树中显示的此元件的描述性名称。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Random Delay Maximum&lt;/td&gt;
&lt;td&gt;暂停的最大随机毫秒数。&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Constant Delay Offset&lt;/td&gt;
&lt;td&gt;除随机延迟之外暂停的毫秒数。&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;a href="#toc"&gt;【返回目录】&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="_50"&gt;常数吞吐量定时器&lt;/h3&gt;
&lt;p&gt;该定时器引入可变暂停，计算以使总吞吐量（以每分钟样本数计）尽可能接近给定数字。当然，如果服务器无法处理它，或者如果其他定时器或耗时的测试元件阻止它，吞吐量将会降低。&lt;/p&gt;
&lt;p&gt;注意虽然定时器被称为常数吞吐量定时器，但吞吐量值不需要是常量。它可以根据变量或函数调用来定义，并且可以在测试期间更改该值。可以通过各种方式更改值：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用计数器变量&lt;/li&gt;
&lt;li&gt;使用&lt;code&gt;__jexl3&lt;/code&gt;，&lt;code&gt;__ groovy&lt;/code&gt;函数来提供更改值&lt;/li&gt;
&lt;li&gt;使用远程BeanShell服务器更改JMeter属性&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;有关详细信息，请参阅&lt;a href="http://jmeter.apache.org/usermanual/best-practices.html"&gt;最佳实践&lt;/a&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注意在测试期间不应经常更改吞吐量值 - 新值需要一段时间才能生效。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img alt="Screenshot for Control-Panel of Constant Throughput Timer" src="http://jmeter.apache.org/images/screenshots/timers/constant_throughput_timer.png"&gt;&lt;br&gt;
&lt;em&gt;常数吞吐量定时器控制面板的截图&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参数&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th align="left"&gt;是否必须&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;名称&lt;/td&gt;
&lt;td&gt;树中显示的此元件的描述性名称。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;目标吞吐量&lt;/td&gt;
&lt;td&gt;我们希望定时器尝试生成的吞吐量。&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;基于计算吞吐量&lt;/td&gt;
&lt;td&gt;&lt;ul&gt;&lt;li&gt;&lt;code&gt;只有此线程&lt;/code&gt; - 每个线程将尝试维护目标吞吐量。总吞吐量将与活动线程数成比例。&lt;/li&gt;&lt;li&gt;&lt;code&gt;当前线程组中的所有活动线程&lt;/code&gt; - 目标吞吐量在当前线程组中的所有活动线程之间划分。每个线程将依据上次运行的时间按需要延迟。&lt;/li&gt;&lt;li&gt;&lt;code&gt;所有活动线程&lt;/code&gt; - 目标吞吐量在所有线程组中的所有活动线程之间划分。每个线程将依据上次运行的时间按需要延迟。在这种情况下，每个其他线程组需要具有相同设置的常量吞吐量定时器。&lt;/li&gt;&lt;li&gt;&lt;code&gt;当前线程组中的所有活动线程（共享）&lt;/code&gt; - 如上所述，但每个线程都会根据组中最近一次运行的线程延迟。&lt;/li&gt;&lt;li&gt;&lt;code&gt;所有活动线程（共享）&lt;/code&gt; - 如上所述，每个线程都会根据最近一次运行的线程延迟。&lt;/li&gt;&lt;/ul&gt;&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;blockquote&gt;
&lt;p&gt;共享和非共享算法都旨在生成所需的吞吐量，并将产生类似的结果。
共享算法应该生成更准确的总体事务率。
非共享算法应该跨线程生成更均匀的事务传播。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href="#toc"&gt;【返回目录】&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="_51"&gt;准确的吞吐量定时器&lt;/h3&gt;
&lt;p&gt;该定时器引入可变暂停，计算以保持总吞吐量（例如，以每分钟样本计）尽可能接近给定数字。当然，如果服务器无法处理它，或者其他定时器影响，或者没有足够的线程，或者耗时的测试元件阻止它，吞吐量都会降低。&lt;/p&gt;
&lt;p&gt;虽然定时器被称为准确的吞吐量定时器，但它的目的并不是在测试期间以每秒的间隔产生相同数量精确的样本。&lt;/p&gt;
&lt;p&gt;定时器最适合工作在36000请求/小时以下的频率，但您的总请求可能会有所不同（如果您的目标差别很大，请参阅下面的监控部分）。&lt;/p&gt;
&lt;h4 id="_52"&gt;测试计划中准确的吞吐量定时器的最佳位置&lt;/h4&gt;
&lt;p&gt;您可能知道，定时器是被所有兄弟姐妹及其子元件继承的。这就是为什么&lt;code&gt;准确的吞吐量定时器&lt;/code&gt;的最佳位置之一是在测试循环中的第一个元件之下。例如，您可以在开头添加一个虚拟取样器，并将定时器放在该虚拟取样器下。&lt;/p&gt;
&lt;h4 id="_53"&gt;生成调度&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;准确的吞吐量定时器&lt;/code&gt;模拟&lt;a href="https://en.wikipedia.org/wiki/Poisson_point_process"&gt;泊松到达&lt;/a&gt;调度。该调度通常发生在现实生活中，因此将其用于压力测试是有意义的。例如，它自然可能生成靠近的样本，因此能够会揭示并发问题。即使您设法使用&lt;a href="http://jmeter.apache.org/usermanual/component_reference.html#Poisson_Random_Timer"&gt;泊松随机定时器&lt;/a&gt;生成泊松到达，它也会受到下面列出的问题的影响。例如，真正的泊松到达可能会无限期地暂停，这对于压力测试是不实际的。例如，速率为每秒1个的“常规”泊松到达可能在60秒长测试中结束50个样本。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://jmeter.apache.org/usermanual/component_reference.html#Constant_Throughput_Timer"&gt;常数吞吐量定时器&lt;/a&gt;收敛到指定的速率，但它倾向于以均匀的间隔产生采样。&lt;/p&gt;
&lt;h4 id="_54"&gt;加速和启动峰值&lt;/h4&gt;
&lt;p&gt;您可以使用“加速”或类似方法来避免测试开始时出现尖峰。例如，如果将&lt;a href="http://jmeter.apache.org/usermanual/component_reference.html#Thread_Group"&gt;线程组&lt;/a&gt;配置为具有100个线程，并将&lt;code&gt;Ramp-up时间&lt;/code&gt;设置为0（或者设置为较小的数字），那么所有线程将同时启动，并且会产生不必要的负载峰值。最重要的是，如果将&lt;code&gt;Ramp-up时间&lt;/code&gt;设置得太高，可能会导致“太少”线程在一开始可用，达不到所需的负载。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;准确的吞吐量定时器&lt;/code&gt;以随机方式调度执行，因此可用于生成恒定负载，建议将&lt;code&gt;Ramp-up时间&lt;/code&gt;和&lt;code&gt;延迟&lt;/code&gt;设置为&lt;code&gt;0&lt;/code&gt;。&lt;/p&gt;
&lt;h4 id="_55"&gt;多个线程组同时启动&lt;/h4&gt;
&lt;p&gt;当&lt;a href="http://jmeter.apache.org/usermanual/component_reference.html#Test_Plan"&gt;测试计划&lt;/a&gt;包含多个&lt;a href="http://jmeter.apache.org/usermanual/component_reference.html#Thead_Group"&gt;线程组&lt;/a&gt;时，可能会出现&lt;code&gt;Ramp-up&lt;/code&gt;问题的变体。为了缓解该问题，通常会向每个&lt;a href="http://jmeter.apache.org/usermanual/component_reference.html#Thead_Group"&gt;线程组&lt;/a&gt;添加“随机”延迟，以便线程在不同时间启动。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;准确的吞吐量定时器&lt;/code&gt;避免了这个问题，因为它以随机方式安排执行。您无需添加额外的随机延迟来缓解启动峰值。&lt;/p&gt;
&lt;h4 id="_56"&gt;每小时的迭代次数&lt;/h4&gt;
&lt;p&gt;其中一个基本要求是每M分钟发出N个样本。让它每小时执行60次迭代。如果您使用57次执行（仅因为次数是随机的）报告负载测试结果，会使业务客户无法理解。为了每小时生成60次迭代，您需要配置如下（其他参数可以保留其默认值）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;目标吞吐量（样本）&lt;/code&gt;：60&lt;/li&gt;
&lt;li&gt;&lt;code&gt;吞吐量周期（秒）&lt;/code&gt;：3600&lt;/li&gt;
&lt;li&gt;&lt;code&gt;测试持续时间（秒）&lt;/code&gt;：3600&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;前两个选项设置吞吐量。尽管60/3600,30/1800和120/7200表示完全相同的负载水平，但请选择能够更好地表示业务需求的负载水平。例如，如果要求测试“每小时60个样本”，则设置60/3600。如果要求测试“每分钟1个样本”，则设置1/60。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;测试持续时间（秒）&lt;/code&gt;确保定时器在给定测试持续时间执行确切样本数。&lt;code&gt;准确的吞吐量定时器&lt;/code&gt;在测试启动时为样本创建调度。例如，如果您希望以每小时60个吞吐量执行5分钟测试，则可以将&lt;code&gt;测试持续时间（秒）&lt;/code&gt;设置为300。这样可以以业务友好的方式配置吞吐量。注：&lt;code&gt;测试持续时间（秒&lt;/code&gt;）并&lt;strong&gt;没有&lt;/strong&gt;限制测试时间。这只是定时器的一个提示。&lt;/p&gt;
&lt;h4 id="_57"&gt;线程数和思考时间&lt;/h4&gt;
&lt;p&gt;其中一个常见的误区是调整线程数和思考时间，以便最终获得所需的吞吐量。即使它可能有效，但这种方法会导致在测试运行上花费大量时间。当测试新的应用程序版本时，可能需要再次调整线程和延迟。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;准确的吞吐量定时器&lt;/code&gt;可以设置吞吐量目标，无论应用程序执行得多好，都可以使用它。为了做到这一点，&lt;code&gt;准确的吞吐量定时器&lt;/code&gt;在测试启动时创建一个调度，然后它使用该调度来释放线程。思考时间和线程数的主要驱动因素应该是业务需求，而不是以某种方式匹配吞吐量的愿望。&lt;/p&gt;
&lt;p&gt;例如，如果您的应用程序由呼叫中心的支持工程师使用。假设呼叫中心有2名工程师，目标吞吐量为每分钟1。假设工程师需要4分钟才能阅读和查看网页。在这种情况下，您应该在组中设置2个线程，使用4分钟进行思考时间延迟，并在&lt;code&gt;准确的吞吐量定时器&lt;/code&gt;指定每分钟1个。当然，它会生成大约2个样本/4分钟=每分钟0.5个这样的结果，这样的测试结果意味着“您需要更多支持工程师在呼叫中心”或“您需要减少工程师完成任务所需的时间”。&lt;/p&gt;
&lt;h4 id="_58"&gt;测试低速率和可重复测试&lt;/h4&gt;
&lt;p&gt;低速率测试（例如每小时60次）需要知道所需的测试配置。例如，如果您需要以均匀间隔（例如介于60秒之间）注入负载，那么您最好使用&lt;a href="http://jmeter.apache.org/usermanual/component_reference.html#Constant_Throughput_Timer"&gt;常数吞吐量定时器&lt;/a&gt;。但是，如果您需要随机调度（例如，为执行报告的真实用户建模），那么&lt;code&gt;准确的吞吐量定时器&lt;/code&gt;就是您的朋友。&lt;/p&gt;
&lt;p&gt;在比较多个压力测试的结果时，能够重复完全相同的测试配置文件非常有用。例如，如果在测试开始5分钟后调用操作X（例如“利润报告”），那么为后续测试执行复制该模式会很好。复制相同的负载模式简化了测试结果的分析（例如CPU％图表）。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;随机种子（从0变为随机）&lt;/code&gt;可以控制&lt;code&gt;准确的吞吐量定时器&lt;/code&gt;使用的种子值。默认情况下，它初始化为&lt;code&gt;0&lt;/code&gt;，这意味着使用随机种子用于每次测试执行。如果您需要具有可重复的加载模式，则将&lt;code&gt;随机种子&lt;/code&gt;更改为 一些随机值。一般建议是使用非零种子，“0默认情况下”是实现限制。&lt;/p&gt;
&lt;p&gt;注意：当使用具有相同吞吐率和相同非零种子的多个线程组时，可能会导致不必要的同时触发样本。&lt;/p&gt;
&lt;h4 id="_59"&gt;测试高速率和/或长持续时间测试&lt;/h4&gt;
&lt;p&gt;当样本数量很大（例如，它超过10,000）时，由于&lt;code&gt;准确的吞吐量定时器&lt;/code&gt;试图产生确切数量的样本，因此调度生成可能需要花费显著的时间（例如，数秒）。还有内存消耗，但是它应该不太重要，因为调度中的每个项目只消耗8个字节。为了减少调度生成开销，&lt;code&gt;准确的吞吐量定时器&lt;/code&gt;在生成长调度时允许一些松弛。它由&lt;code&gt;生成延迟的准确性&lt;/code&gt;属性控制 。默认情况下，当样本数超过10,000时，允许不精确的调度。&lt;/p&gt;
&lt;p&gt;如果您想以每小时5'000的速度进行为期2周的测试，则无需为该2周创建调度。您可以将计时器的&lt;code&gt;测试持续时间（秒）&lt;/code&gt;属性设置为1小时。计时器将创建一个小时的5'000个样本的调度，并且当调度用尽时，计时器将生成下一个小时的调度。&lt;/p&gt;
&lt;h4 id="_60"&gt;突发负载&lt;/h4&gt;
&lt;p&gt;可能存在所有样本成对，成三等出现的的情况。某些情况可能通过&lt;a href="http://jmeter.apache.org/usermanual/component_reference.html#Synchronizing_Timer"&gt;同步定时器&lt;/a&gt;来解决，但&lt;code&gt;准确的吞吐量定时器&lt;/code&gt;具有本地方式来以包的形式发出请求。默认情况下禁用此行为，并使用“批处理离开”设置进行控制&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;批处理中的线程数（线程）&lt;/code&gt;。指定批次中的样本数。注意样本的总数仍将与&lt;code&gt;目标吞吐量&lt;/code&gt;一致&lt;/li&gt;
&lt;li&gt;&lt;code&gt;批处理中的线程之间的延迟（ms）&lt;/code&gt;。例如，如果设置为42，批量大小为3，则线程将在x，x + 42ms，x + 84ms处离开&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="_61"&gt;可变负载率&lt;/h4&gt;
&lt;p&gt;尽管可以通过表达式定义属性值（例如吞吐量），但建议通过测试使值或多或少保持相同，因为重新计算新计划以适应新值需要时间。&lt;/p&gt;
&lt;h4 id="_62"&gt;监控&lt;/h4&gt;
&lt;p&gt;当生成下一个调度时，&lt;code&gt;准确的吞吐量定时器&lt;/code&gt;将消息记录到&lt;code&gt;jmeter.log&lt;/code&gt;：&lt;code&gt;2018-01-04 17:34:03,635 INFO o.a.j.t.ConstantPoissonProcessGenerator: Generated 21 timings (... 20 required, rate 1.0, duration 20, exact lim 20000, i21) in 0 ms, restart was issued 3 times. First 15 events will be fired at: 1.1869653574244292 (+1.1869653574244292), 1.4691340403043207 (+0.2821686828798915), 3.638151706179226 (+2.169017665874905), 3.836357090410566 (+0.19820538423134026), 4.709330071408575 (+0.8729729809980085), 5.61330076999953 (+0.903970698590955), ...&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;这表明调度生成花了0毫秒，它显示了以秒为单位的绝对时间戳。在上面的情况中，速率设置为每秒1，实际时间戳变为1.2秒，1.5秒，3.6秒，3.8秒，4.7秒，依此类推。&lt;/p&gt;
&lt;p&gt;&lt;img alt="Screenshot for Control-Panel of Precise Throughput Timer" src="http://jmeter.apache.org/images/screenshots/timers/precise_throughput_timer.png"&gt;&lt;br&gt;
&lt;em&gt;准确的吞吐量定时器控制面板的截图&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参数&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th align="left"&gt;是否必须&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;名称&lt;/td&gt;
&lt;td&gt;树中显示的此元件的描述性名称。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;目标吞吐量（每个“吞吐期”的样本）&lt;/td&gt;
&lt;td&gt;每个“吞吐量周期”要获得的最大样本数，包括所有受影响的取样器中的组中的所有线程。&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;吞吐量周期（秒）&lt;/td&gt;
&lt;td&gt;吞吐量周期。例如，如果“吞吐量”设置为42并且“吞吐量周期”设置为21秒，那么您将获得每秒2个样本。&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;测试持续时间（秒）&lt;/td&gt;
&lt;td&gt;这用于确保您在“测试持续时间”时间范围内获得吞吐量*持续时间样本数。&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;批处理中的线程数（线程）&lt;/td&gt;
&lt;td&gt;如果该值超过1，则多个线程同时离开定时器。平均吞吐量仍然符合“吞吐量”值。&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;批处理中的线程之间的延迟（ms）&lt;/td&gt;
&lt;td&gt;例如，如果设置为42，批量大小为3，则线程将在x，x + 42ms，x + 84ms处离开。&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;当序列长度超过（样本）时使用近似吞吐量&lt;/td&gt;
&lt;td&gt;当所需的样本数小于此限制时，定时器将生成确切数量的样本。&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;允许吞吐量过剩（百分比）&lt;/td&gt;
&lt;td&gt;当需要超过“最大精确样本”样本时，定时器可能会生成比吞吐量指定的事件稍多的事件。&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;随机种子（从0变为随机）&lt;/td&gt;
&lt;td&gt;注意：不同的定时器最好使用不同的种子值。常量种子确保计时器在每次测试开始时产生相同的延迟。值“0”表示计时器是真正随机的（从一次执行到另一次执行不可重复）。&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;a href="#toc"&gt;【返回目录】&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="_63"&gt;同步定时器&lt;/h3&gt;
&lt;p&gt;同步定时器的目的是阻塞线程，直到X个线程被阻塞，然后它们全部被同时释放。因此，同步定时器可以在测试计划的各个点创建大的即时负载。&lt;/p&gt;
&lt;p&gt;&lt;img alt="Screenshot for Control-Panel of Synchronizing Timer" src="http://jmeter.apache.org/images/screenshots/timers/sync_timer.png"&gt;&lt;br&gt;
&lt;em&gt;同步定时器控制面板的截图&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参数&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th align="left"&gt;是否必须&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;名称&lt;/td&gt;
&lt;td&gt;树中显示的此定时器的描述性名称。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;模拟用户组的数量&lt;/td&gt;
&lt;td&gt;一次释放的线程数。将其设置为&lt;code&gt;0&lt;/code&gt;相当于将其设置为线程组中配置的线程数。&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;超时时间（以毫秒为单位）&lt;/td&gt;
&lt;td&gt;如果设置为&lt;code&gt;0&lt;/code&gt;，则定时器将等待线程数达到“&lt;code&gt;模拟用户组的数量&lt;/code&gt;”中的值。如果大于&lt;code&gt;0&lt;/code&gt;，则计时器将以最大“&lt;code&gt;超时时间（以毫秒为单位）&lt;/code&gt;” 等待线程数。如果在超时时间之后未达到等待的用户数，则定时器将停止等待。默认为&lt;code&gt;0&lt;/code&gt;&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;blockquote&gt;
&lt;p&gt;如果以毫秒为单位的超时时间设置为&lt;code&gt;0&lt;/code&gt;并且线程数永远不会达到“&lt;code&gt;模拟用户组的数量&lt;/code&gt;”，则测试将无限暂停。只有强制停止才能阻止它。在这种情况下，可以考虑设置超时时间。&lt;/p&gt;
&lt;p&gt;同步定时器阻塞仅在一个JVM内，因此如果使用分布式测试，请确保永远不要将“&lt;code&gt;模拟用户组的数量&lt;/code&gt;”设置为大于其包含的线程组（仅考虑1个注入器）的用户数的值。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href="#toc"&gt;【返回目录】&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="beanshell_3"&gt;BeanShell定时器&lt;/h3&gt;
&lt;p&gt;BeanShell定时器可用于生成延迟。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;有关使用BeanShell的完整详细信息，请参阅&lt;a href="http://www.beanshell.org/"&gt;BeanShell网站&lt;/a&gt;。&lt;/strong&gt;  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;强烈建议迁移到&lt;a href="http://jmeter.apache.org/usermanual/component_reference.html#JSR223_Sampler"&gt;JSR223 Sampler&lt;/a&gt;+Groovy以提高性能，支持新的Java功能并限制BeanShell库的维护。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;测试元件支持&lt;code&gt;ThreadListener&lt;/code&gt;和&lt;code&gt;TestListener&lt;/code&gt;接口方法。这些必须在初始化文件中定义。有关定义的示例，请参阅文件&lt;code&gt;BeanShellListeners.bshrc&lt;/code&gt;。 &lt;/p&gt;
&lt;p&gt;&lt;img alt="Screenshot for Control-Panel of BeanShell Timer" src="http://jmeter.apache.org/images/screenshots/timers/beanshell_timer.png"&gt;&lt;br&gt;
&lt;em&gt;BeanShell定时器控制面板的截图&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参数&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th align="left"&gt;是否必须&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;名称&lt;/td&gt;
&lt;td&gt;树中显示的此元件的描述性名称。该名称存储在脚本变量&lt;code&gt;Label&lt;/code&gt;中&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;每次调用前重置bsh.Interpreter&lt;/td&gt;
&lt;td&gt;如果选择此选项，则将为每个样本重新创建解释器。对于某些长时间运行的脚本，这可能是必需的。有关详细信息，请参阅&lt;a href="http://jmeter.apache.org/usermanual/best-practices#bsh_scripting"&gt;最佳实践 - BeanShell脚本&lt;/a&gt;。&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;参数&lt;/td&gt;
&lt;td&gt;要传递给BeanShell脚本的参数。参数存储在以下变量中：&lt;ul&gt;&lt;li&gt;&lt;code&gt;Parameters&lt;/code&gt;包含参数作为单个变量的字符串&lt;/li&gt;&lt;li&gt;&lt;code&gt;bsh.args&lt;/code&gt;包含参数的字符串数组，在空格处分割&lt;/li&gt;&lt;/ul&gt;&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;脚本文件&lt;/td&gt;
&lt;td&gt;包含要运行的BeanShell脚本的文件。文件名存储在脚本变量&lt;code&gt;FileName&lt;/code&gt;中。返回值用作等待的毫秒数。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;脚本&lt;/td&gt;
&lt;td&gt;要运行的BeanShell脚本。返回值用作等待的毫秒数。&lt;/td&gt;
&lt;td align="left"&gt;是（除非提供脚本文件）&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;在调用脚本之前，在BeanShell解释器中设置了一些变量：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;log&lt;/code&gt; - （&lt;a href="https://www.slf4j.org/api/org/slf4j/Logger.html"&gt;Logger&lt;/a&gt;） - 可用于写入日志文件&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;ctx&lt;/code&gt; - （&lt;a href="http://jmeter.apache.org/api/org/apache/jmeter/threads/JMeterContext.html"&gt;JMeterContext&lt;/a&gt;） - 允许访问上下文&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;vars&lt;/code&gt; - (&lt;a href="http://jmeter.apache.org/api/org/apache/jmeter/threads/JMeterVariables.html"&gt;JMeterVariables&lt;/a&gt;) - 提供对变量的读/写访问：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    vars.get(key);
    vars.put(key,val);
    vars.putObject(&amp;quot;OBJ1&amp;quot;,new Object());
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;props&lt;/code&gt; - （JMeterProperties - &lt;a href="https://docs.oracle.com/javase/8/docs/api/java/util/Properties.html"&gt;java.util.Properties&lt;/a&gt;类） - 例如&lt;code&gt;props.get("START.HMS");&lt;/code&gt; &lt;code&gt;props.put("PROP1","1234");&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;prev&lt;/code&gt; - （&lt;a href="http://jmeter.apache.org/api/org/apache/jmeter/samplers/SampleResult.html"&gt;SampleResult&lt;/a&gt;） - 提供对前一个&lt;a href="http://jmeter.apache.org/api/org/apache/jmeter/samplers/SampleResult.html"&gt;SampleResult&lt;/a&gt;的访问（如果有的话）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;有关上述每个变量的所有可用方法的详细信息，请查看Javadoc。&lt;/p&gt;
&lt;p&gt;如果定义了属性&lt;code&gt;beanshell.listener.init&lt;/code&gt;，则用于加载初始化文件，该文件可用于定义在BeanShell脚本中使用的方法等。&lt;/p&gt;
&lt;p&gt;&lt;a href="#toc"&gt;【返回目录】&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="jsr223_2"&gt;JSR223定时器&lt;/h3&gt;
&lt;p&gt;JSR223定时器可使用JSR223脚本语言生成延迟。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参数&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th align="left"&gt;是否必须&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;名称&lt;/td&gt;
&lt;td&gt;树中显示的此元件的描述性名称。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;语言&lt;/td&gt;
&lt;td&gt;要使用的脚本语言&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;参数&lt;/td&gt;
&lt;td&gt;要传递给脚本的参数。参数存储在以下变量中：&lt;ul&gt;&lt;li&gt;&lt;code&gt;Parameters&lt;/code&gt;包含参数作为单个变量的字符串&lt;/li&gt;&lt;li&gt;&lt;code&gt;args&lt;/code&gt;包含参数的字符串数组，在空格处分割&lt;/li&gt;&lt;/ul&gt;&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;脚本文件&lt;/td&gt;
&lt;td&gt;包含要运行的脚本的文件，如果使用相对文件路径，则它将相对于系统属性“&lt;code&gt;user.dir&lt;/code&gt;”引用的目录。返回值转换为长整数并用作等待的毫秒数。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;脚本编译缓存&lt;/td&gt;
&lt;td&gt;测试计划中的唯一字符串，如果使用的语言支持&lt;a href="https://docs.oracle.com/javase/8/docs/api/javax/script/Compilable.html"&gt;Compilable&lt;/a&gt;接口（Groovy是其中之一，java，beanshell和javascript不是），则JMeter将用于缓存脚本编译的结果。&lt;blockquote&gt;如果您在不检查此选项的情况下使用Groovy，请参阅JSR223取样器Java系统属性中的注释&lt;/blockquote&gt;&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;脚本&lt;/td&gt;
&lt;td&gt;脚本。返回值用作等待的毫秒数。&lt;/td&gt;
&lt;td align="left"&gt;是（除非提供脚本文件）&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;在调用脚本之前，脚本解释器中设置了一些变量：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;log&lt;/code&gt; - （&lt;a href="https://www.slf4j.org/api/org/slf4j/Logger.html"&gt;Logger&lt;/a&gt;） - 可用于写入日志文件&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;CTX&lt;/code&gt; - （&lt;a href="http://jmeter.apache.org/api/org/apache/jmeter/threads/JMeterContext.html"&gt;JMeterContext&lt;/a&gt;） - 允许访问上下文&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;vars&lt;/code&gt; - （&lt;a href="http://jmeter.apache.org/api/org/apache/jmeter/threads/JMeterVariables.html"&gt;JMeterVariables&lt;/a&gt;） - 提供对变量的读/写访问权限：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    vars.get(key);
    vars.put(key,val);
    vars.putObject(&amp;quot;OBJ1&amp;quot;,new Object());
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;props&lt;/code&gt;（JMeterProperties - &lt;a href="https://docs.oracle.com/javase/8/docs/api/java/util/Properties.html"&gt;java.util.Properties&lt;/a&gt;类） - 例如&lt;code&gt;props.get("START.HMS");&lt;/code&gt; &lt;code&gt;props.put("PROP1","1234");&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;sampler&lt;/code&gt;（&lt;a href="http://jmeter.apache.org/api/org/apache/jmeter/samplers/Sampler.html"&gt;取样器&lt;/a&gt;） - 当前的取样器&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Label&lt;/code&gt; - 定时器的名称&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;FileName&lt;/code&gt; - 文件名（如果有）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;OUT&lt;/code&gt; - &lt;code&gt;System.out&lt;/code&gt; &lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;有关上述每个变量的所有可用方法的详细信息，请查看Javadoc。&lt;/p&gt;
&lt;p&gt;&lt;a href="#toc"&gt;【返回目录】&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="_64"&gt;泊松随机定时器&lt;/h3&gt;
&lt;p&gt;该定时器暂停每个线程请求一段随机时间，大部分时间间隔发生在特定值附近。总延迟是泊松分布值和偏移值之和。&lt;/p&gt;
&lt;p&gt;注意：如果要对泊松到达进行建模，请考虑使用&lt;a href="http://jmeter.apache.org/usermanual/component_reference.html#Precise_Throughput_Timer"&gt;准确的吞吐量定时器&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img alt="Screenshot for Control-Panel of Poisson Random Timer" src="http://jmeter.apache.org/images/screenshots/timers/poisson_random_timer.png"&gt;&lt;br&gt;
&lt;em&gt;泊松随机定时器控制面板的截图&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参数&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th align="left"&gt;是否必须&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;名称&lt;/td&gt;
&lt;td&gt;树中显示的此定时器的描述性名称。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;LAMBDA&lt;/td&gt;
&lt;td&gt;Lambda值，以毫秒为单位。&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Constant Delay Offset&lt;/td&gt;
&lt;td&gt;除随机延迟之外暂停的毫秒数。&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;a href="#toc"&gt;【返回目录】&lt;/a&gt;&lt;/p&gt;
&lt;h2 id="187"&gt;18.7 前置处理器&lt;/h2&gt;
&lt;p&gt;前置处理器用于修饰其范围内的取样器。 &lt;/p&gt;
&lt;h3 id="html_1"&gt;HTML链接解析器&lt;/h3&gt;
&lt;p&gt;此修饰器解析来自服务器的HTML响应并提取链接和表单。将检查通过此修饰器的URL测试样本，以查看它是否“匹配”从前一个响应中提取的任何链接或表单。然后，它将使用匹配的链接或表单中的适当值替换URL测试样本中的值。Perl类型的正则表达式可用于查找匹配项。&lt;/p&gt;
&lt;p&gt;&lt;img alt="Screenshot for Control-Panel of HTML Link Parser" src="http://jmeter.apache.org/images/screenshots/html_link_parser.png"&gt;&lt;br&gt;
&lt;em&gt;HTML链接解析器控制面板的截图&lt;/em&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;使用&lt;code&gt;协议&lt;/code&gt;，&lt;code&gt;主机&lt;/code&gt;，&lt;code&gt;路径&lt;/code&gt;和&lt;code&gt;参数名称&lt;/code&gt;执行匹配。目标取样器不能包含不在响应链接中的参数。&lt;/p&gt;
&lt;p&gt;如果使用分布式测试，请切换模式（请参阅&lt;code&gt;jmeter.properties&lt;/code&gt;）以确保其不在剥离模式下，请参阅&lt;a href="https://bz.apache.org/bugzilla/show_bug.cgi?id=56376"&gt;Bug 56376&lt;/a&gt;。&lt;/p&gt;
&lt;h4 id="_65"&gt;爬虫示例&lt;/h4&gt;
&lt;p&gt;考虑一个简单的例子：假设您希望JMeter爬取您的站点，在从服务器返回的HTML解析链接后点击链接（这实际上不是最有用的事情，但它是一个很好的例子） 。您将创建一个&lt;a href="http://jmeter.apache.org/usermanual/component_reference.html#Simple_Controller"&gt;简单控制器&lt;/a&gt;，并对其添加“HTML链接解析器”。然后，创建一个HTTP请求，将域设置为“&lt;code&gt;.*&lt;/code&gt;”，并将路径设置为同样。这将使您的测试样本与返回页面上找到的任何链接相匹配。如果要将抓取内容限制为特定域，请将域值更改为所需的域值。然后，将仅遵循指向该域的链接。&lt;/p&gt;
&lt;h4 id="_66"&gt;轮询示例&lt;/h4&gt;
&lt;p&gt;一个更有用的示例：给定一个Web轮询应用程序，您可能会有一个页面包含多个轮询选项的单选按钮供用户选择。假设轮询选项的值非常动态 - 可能是用户生成的。如果您希望JMeter测试轮询，您可以创建选择了硬编码值的测试样本，也可以让HTML链接解析器解析表单，并在URL测试样本中插入随机轮询选项。为此，请按照上面的示例进行操作，但在配置Web测试控制器的URL选项时，请务必选择“&lt;code&gt;POST&lt;/code&gt;”方法。为&lt;code&gt;域&lt;/code&gt;，&lt;code&gt;路径&lt;/code&gt;和任何其他表单参数输入硬编码值。然后，对于实际的单选按钮参数，输入名称（让我们假设它为"&lt;code&gt;poll_choice&lt;/code&gt;“），然后”&lt;code&gt;.*&lt;/code&gt;“表示该参数的值。当修饰器检查此URL测试样本时，它会发现它”匹配“轮询表单（并且它不应该匹配任何其他表单，因为您已经指定了URL测试示例的所有其他方面），它将使用表单中的匹配参数替换您的表单参数。由于正则表达式“&lt;code&gt;.*&lt;/code&gt;”将与任何内容匹配，因此修饰符可能会有一个单选按钮列表可供选择。它将随机选择，并替换URL测试样本中的值。每次通过测试，将选择一个新的随机值。&lt;/p&gt;
&lt;p&gt;&lt;img alt="Figure 18 - Online Poll Example" src="http://jmeter.apache.org/images/screenshots/modification.png"&gt;
&lt;em&gt;图18 - 在线轮询示例&lt;/em&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;需要记住的一件重要事情是，您必须在返回HTML页面之前立即创建一个测试样本，其中包含与动态测试样本相关的链接和表单。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;h3 id="http-url"&gt;HTTP URL 重写修饰符&lt;/h3&gt;
&lt;p&gt;此修饰器与HTML链接分析器的工作方式类似，不同之处在于它具有比HTML链接分析器更易于使用的特定目的，并且效率更高。对于使用URL重写来存储会话ID而不是cookie的Web应用程序，可以在线程组级别附加此元件，就像&lt;a href="http://jmeter.apache.org/usermanual/component_reference.html#HTTP_Cookie_Manager"&gt;HTTP Cookie管理器&lt;/a&gt;一样。只需为其指定会话ID参数的名称，它就会在页面上找到它并将参数添加到该线程组的每个请求中。&lt;/p&gt;
&lt;p&gt;或者，此修饰器可以附加到选择请求，它只会修改它们。聪明的用户甚至可以使用此修饰器获取&lt;a href="http://jmeter.apache.org/usermanual/component_reference.html#HTML_Link_Parser"&gt;HTML链接解析器&lt;/a&gt;没有获取到的值。&lt;/p&gt;
&lt;p&gt;&lt;img alt="Screenshot for Control-Panel of HTTP URL Re-writing Modifier" src="http://jmeter.apache.org/images/screenshots/url_rewriter.png"&gt;&lt;br&gt;
&lt;em&gt;HTTP URL重写修饰符的控制面板的截图&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参数&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th align="left"&gt;是否必须&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;名称&lt;/td&gt;
&lt;td&gt;树中显示的此元件的描述性名称。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;会话参数名称&lt;/td&gt;
&lt;td&gt;要从先前响应中获取的参数的名称。此修饰器将在页面上的任何位置找到参数，并获取分配给它的值，无论它是在HREF还是表单中。&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;路径扩展&lt;/td&gt;
&lt;td&gt;某些Web应用程序通过附加分号和会话ID参数来重写URL。如果是这样，请选中此框。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Do not use equals in path extension&lt;/td&gt;
&lt;td&gt;某些网络应用程序在参数名称和值之间不使用“&lt;code&gt;=&lt;/code&gt;”的情况下重写URL（例如Intershop Enfinity）。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Do not use questionmark in path extension&lt;/td&gt;
&lt;td&gt;阻止查询字符串以路径扩展结尾（例如Intershop Enfinity）。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;缓存会话ID？&lt;/td&gt;
&lt;td&gt;是否应保存会话ID的值以供以后使用？&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;URL编码&lt;/td&gt;
&lt;td&gt;URL写参数时的编码值&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;blockquote&gt;
&lt;p&gt;如果使用分布式测试，请切换模式（请参阅&lt;code&gt;jmeter.properties&lt;/code&gt;）以确保其不在剥离模式下，请参阅&lt;a href="https://bz.apache.org/bugzilla/show_bug.cgi?id=56376"&gt;Bug 56376&lt;/a&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href="#toc"&gt;【返回目录】&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="_67"&gt;用户参数&lt;/h3&gt;
&lt;p&gt;允许用户指定特定于各个线程的用户变量的值。&lt;/p&gt;
&lt;p&gt;用户变量也可以在测试计划中指定，但不是特定于各个线程。此面板允许您为任何用户变量指定一系列值。对于每个线程，将根据序列中的一个值为变量分配一个值。如果线程数多于值，则重新使用这些值。例如，这可以用于分配每个线程使用的不同用户ID。用户变量可以在任何JMeter组件的任何字段中引用。&lt;/p&gt;
&lt;p&gt;通过单击面板底部的“&lt;code&gt;添加变量&lt;/code&gt;”按钮并在“&lt;code&gt;名称：&lt;/code&gt;”列中填写变量名称来指定变量。要向系列添加新值，请单击“&lt;code&gt;添加用户&lt;/code&gt;”按钮，然后在新添加的列中填写所需的值。&lt;/p&gt;
&lt;p&gt;可以使用&lt;a href="http://jmeter.apache.org/usermanual/functions.html"&gt;函数语法&lt;/a&gt;在同一个线程组中的任何测试组件中访问值：&lt;code&gt;${variable}&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;另请参见&lt;a href="http://jmeter.apache.org/usermanual/component_reference.html#CSV_Data_Set_Config"&gt;CSV 数据文件设置&lt;/a&gt;元件，它更适合于大量参数&lt;/p&gt;
&lt;p&gt;&lt;img alt="Screenshot for Control-Panel of User Parameters" src="http://jmeter.apache.org/images/screenshots/user_params.png"&gt;&lt;br&gt;
&lt;em&gt;用户参数控制面板的截图&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参数&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th align="left"&gt;是否必须&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;名称&lt;/td&gt;
&lt;td&gt;树中显示的此元件的描述性名称。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;每次迭代更新一次&lt;/td&gt;
&lt;td&gt;一个标志，指示用户参数元件是否在每次迭代时更新其变量一次。如果将函数嵌入到用户参数中，则可能需要更好地控制变量值的更新频率。选中此框以确保每次通过用户参数的父控制器更新值。取消选中该框，用户参数将更新其&lt;a href="http://jmeter.apache.org/usermanual/test_plan.html#scoping_rules"&gt;范围&lt;/a&gt;内的每个样本请求的参数。&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;a href="#toc"&gt;【返回目录】&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="beanshell_4"&gt;BeanShell预处理程序&lt;/h3&gt;
&lt;p&gt;BeanShell预处理程序允许在采样之前应用任意代码。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;有关使用BeanShell的完整详细信息，请参阅&lt;a href="http://www.beanshell.org/"&gt;BeanShell网站&lt;/a&gt;。&lt;/strong&gt;  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;强烈建议迁移到&lt;a href="http://jmeter.apache.org/usermanual/component_reference.html#JSR223_Sampler"&gt;JSR223 Sampler&lt;/a&gt;+Groovy以提高性能，支持新的Java功能并限制BeanShell库的维护。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;测试元件支持&lt;code&gt;ThreadListener&lt;/code&gt;和&lt;code&gt;TestListener&lt;/code&gt;接口方法。这些必须在初始化文件中定义。有关定义的示例，请参阅文件&lt;code&gt;BeanShellListeners.bshrc&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img alt="Screenshot for Control-Panel of BeanShell PreProcessor" src="http://jmeter.apache.org/images/screenshots/beanshell_preprocessor.png"&gt;&lt;br&gt;
&lt;em&gt;BeanShell预处理程序控制面板的截图&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参数&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th align="left"&gt;是否必须&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;名称&lt;/td&gt;
&lt;td&gt;树中显示的此取样器的描述性名称。该名称存储在脚本变量&lt;code&gt;Label&lt;/code&gt;中&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;每次调用前重置bsh.Interpreter&lt;/td&gt;
&lt;td&gt;如果选择此选项，则将为每个样本重新创建解释器。对于某些长时间运行的脚本，这可能是必需的。有关详细信息请参阅&lt;a href="http://jmeter.apache.org/usermanual/best-practices#bsh_scripting"&gt;最佳实践 -  BeanShell脚本&lt;/a&gt;。&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;参数&lt;/td&gt;
&lt;td&gt;要传递给BeanShell脚本的参数。参数存储在以下变量中：&lt;br /&gt;&lt;code&gt;Parameters&lt;/code&gt;：包含参数的字符串，作为单个变量&lt;br /&gt;&lt;code&gt;bsh.args&lt;/code&gt;：包含参数的字符串数组，在空格处分割&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;脚本文件&lt;/td&gt;
&lt;td&gt;包含要运行的BeanShell脚本的文件。文件名存储在脚本变量&lt;code&gt;FileName&lt;/code&gt;中&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;脚本&lt;/td&gt;
&lt;td&gt;BeanShell脚本。返回值被忽略。&lt;/td&gt;
&lt;td align="left"&gt;是（除非提供脚本文件）&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;在调用脚本之前，在BeanShell解释器中设置了一些变量：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;log&lt;/code&gt; - （&lt;a href="https://www.slf4j.org/api/org/slf4j/Logger.html"&gt;Logger&lt;/a&gt;） - 可用于写入日志文件&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;ctx&lt;/code&gt; - （&lt;a href="http://jmeter.apache.org/api/org/apache/jmeter/threads/JMeterContext.html"&gt;JMeterContext&lt;/a&gt;） - 允许访问上下文&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;vars&lt;/code&gt; - (&lt;a href="http://jmeter.apache.org/api/org/apache/jmeter/threads/JMeterVariables.html"&gt;JMeterVariables&lt;/a&gt;) - 提供对变量的读/写访问：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    vars.get(key);
    vars.put(key,val);
    vars.putObject(&amp;quot;OBJ1&amp;quot;,new Object());
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;props&lt;/code&gt; - （JMeterProperties - 类&lt;a href="https://docs.oracle.com/javase/8/docs/api/java/util/Properties.html"&gt;&lt;strong&gt;java.util.Properties&lt;/strong&gt;&lt;/a&gt;） - 例如&lt;code&gt;props.get("START.HMS");&lt;/code&gt; &lt;code&gt;props.put("PROP1","1234");&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;prev&lt;/code&gt; - （&lt;a href="http://jmeter.apache.org/api/org/apache/jmeter/samplers/SampleResult.html"&gt;SampleResult&lt;/a&gt;） - 允许访问前一个&lt;a href="http://jmeter.apache.org/api/org/apache/jmeter/samplers/SampleResult.html"&gt;SampleResult&lt;/a&gt;（如果有的话）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;sampler&lt;/code&gt;（&lt;a href="http://jmeter.apache.org/api/org/apache/jmeter/samplers/SampleEvent.html"&gt;SampleEvent&lt;/a&gt;）提供对当前取样器的访问&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;有关上述每个变量的所有可用方法的详细信息，请查看Javadoc。&lt;/p&gt;
&lt;p&gt;如果定义了属性&lt;code&gt;beanshell.listener.init&lt;/code&gt;，则用于加载初始化文件，该文件可用于定义在BeanShell脚本中使用的方法等。&lt;/p&gt;
&lt;p&gt;&lt;a href="#toc"&gt;【返回目录】&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="jsr223_3"&gt;JSR223预处理程序&lt;/h3&gt;
&lt;p&gt;JSR223预处理程序允许在采样之前应用JSR223脚本代码。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参数&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th align="left"&gt;是否必须&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;名称&lt;/td&gt;
&lt;td&gt;树中显示的此元件的描述性名称。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;语言&lt;/td&gt;
&lt;td&gt;要使用的JSR223脚本语言&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;参数&lt;/td&gt;
&lt;td&gt;要传递给脚本的参数。参数存储在以下变量中：&lt;ul&gt;&lt;li&gt;&lt;code&gt;Parameters&lt;/code&gt;包含参数作为单个变量的字符串&lt;/li&gt;&lt;li&gt;&lt;code&gt;args&lt;/code&gt;包含参数的字符串数组，在空格处分割&lt;/li&gt;&lt;/ul&gt;&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;脚本文件&lt;/td&gt;
&lt;td&gt;包含要运行的脚本的文件，如果使用相对文件路径，则它将相对于系统属性“&lt;code&gt;user.dir&lt;/code&gt;”引用的目录。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;脚本编译缓存&lt;/td&gt;
&lt;td&gt;测试计划中的唯一字符串，如果使用的语言支持&lt;a href="https://docs.oracle.com/javase/8/docs/api/javax/script/Compilable.html"&gt;Compilable&lt;/a&gt;接口（Groovy是其中之一，java，beanshell和javascript不是），则JMeter将用于缓存脚本编译的结果。&lt;blockquote&gt;如果您在不检查此选项的情况下使用Groovy，请参阅JSR223取样器Java系统属性中的注释&lt;/blockquote&gt;&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;脚本&lt;/td&gt;
&lt;td&gt;要运行的脚本。&lt;/td&gt;
&lt;td align="left"&gt;是（除非提供脚本文件）&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;在调用脚本之前，会设置一些变量。请注意，这些是JSR223变量 - 即它们可以直接在脚本中使用。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;log&lt;/code&gt; - （&lt;a href="https://www.slf4j.org/api/org/slf4j/Logger.html"&gt;Logger&lt;/a&gt;） - 可用于写入日志文件&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Label&lt;/code&gt; - 标签字符串&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;FileName&lt;/code&gt; - 脚本文件名（如果有）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Parameters&lt;/code&gt; - 参数（作为字符串）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;ARGS&lt;/code&gt; - 作为字符串数组的参数（在空格上拆分）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;CTX&lt;/code&gt; - （&lt;a href="http://jmeter.apache.org/api/org/apache/jmeter/threads/JMeterContext.html"&gt;JMeterContext&lt;/a&gt;） - 允许访问上下文&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;vars&lt;/code&gt; - （&lt;a href="http://jmeter.apache.org/api/org/apache/jmeter/threads/JMeterVariables.html"&gt;JMeterVariables&lt;/a&gt;） - 提供对变量的读/写访问权限：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;vars.get(key);
vars.put(key,val);
vars.putObject(&amp;quot;OBJ1&amp;quot;,new Object());
vars.getObject(&amp;quot;OBJ2&amp;quot;);
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;props&lt;/code&gt; - （JMeterProperties - 类&lt;a href="https://docs.oracle.com/javase/8/docs/api/java/util/Properties.html"&gt;&lt;strong&gt;java.util.Properties&lt;/strong&gt;&lt;/a&gt;） - 例如&lt;code&gt;props.get("START.HMS");&lt;/code&gt; &lt;code&gt;props.put("PROP1","1234");&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;sampler&lt;/code&gt; - （&lt;a href="http://jmeter.apache.org/api/org/apache/jmeter/samplers/Sampler.html"&gt;取样器&lt;/a&gt;） - 允许访问最后一个取样器&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;OUT&lt;/code&gt; - &lt;code&gt;System.out&lt;/code&gt; - 例如&lt;code&gt;OUT.println("message")&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;有关上述每个变量的所有可用方法的详细信息，请查看Javadoc&lt;/p&gt;
&lt;p&gt;&lt;a href="#toc"&gt;【返回目录】&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="jdbc_1"&gt;JDBC预处理程序&lt;/h3&gt;
&lt;p&gt;JDBC预处理程序使您可以在样本运行之前运行一些SQL语句。如果JDBC样本需要某些数据位于数据库中，并且无法在初始化线程组中计算此数据，则此选项非常有用。有关详细信息，请参阅&lt;a href="http://jmeter.apache.org/usermanual/component_reference.html#JDBC_Request"&gt;JDBC请求&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;请参阅以下测试计划：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;另请参阅：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://jmeter.apache.org/demos/JDBC-Pre-Post-Processor.jmx"&gt;使用JDBC前置/后置处理器的测试计划&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在链接的测试计划中，“&lt;code&gt;Create Price Cut-Off&lt;/code&gt;”JDBC预处理程序调用存储过程在数据库中创建Price Cut-Off，这个将由“&lt;code&gt;Calculate Price cut off&lt;/code&gt;”使用。&lt;/p&gt;
&lt;p&gt;&lt;img alt="Create Price Cut-Off Preprocessor" src="http://jmeter.apache.org/images/screenshots/jdbc-pre-processor.png"&gt;
&lt;em&gt;Create Price Cut-Off预处理程序&lt;/em&gt; &lt;/p&gt;
&lt;p&gt;&lt;a href="#toc"&gt;【返回目录】&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="_68"&gt;正则表达式用户参数&lt;/h3&gt;
&lt;p&gt;允许使用正则表达式从一个HTTP请求中提取指定动态值并传递到另一个HTTP参数。正则表达式用户参数特定于各个线程。&lt;/p&gt;
&lt;p&gt;此组件允许您指定提取HTTP请求参数的名称和值的正则表达式的引用名称。必须为参数名称和参数值指定正则表达式组编号。仅对使用此名称匹配的正则表达式用户参数的取样器中的参数进行替换。&lt;/p&gt;
&lt;p&gt;&lt;img alt="Screenshot for Control-Panel of RegEx User Parameters" src="http://jmeter.apache.org/images/screenshots/regex_user_params.png"&gt;&lt;br&gt;
&lt;em&gt;正则表达式用户参数控制面板的截图&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参数&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th align="left"&gt;是否必须&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;名称&lt;/td&gt;
&lt;td&gt;树中显示的此元件的描述性名称。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Regular Expression Reference Name&lt;/td&gt;
&lt;td&gt;正则表达式的引用名称&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Parameter names regexp group number&lt;/td&gt;
&lt;td&gt;用于提取参数名称的正则表达式的组编号&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Parameter values regex group number&lt;/td&gt;
&lt;td&gt;用于提取参数值的正则表达式的组编号&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;blockquote&gt;
&lt;h4 id="_69"&gt;正则表达式示例&lt;/h4&gt;
&lt;p&gt;假设我们有一个返回带有3个输入参数的表单的请求，我们想要提取其中2个的值，以便在下一个请求中注入它们&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;为第一个HTTP请求创建正则表达式后置处理器&lt;ul&gt;
&lt;li&gt;&lt;code&gt;引用名称&lt;/code&gt; - 设置正则表达式的名称（&lt;code&gt;listParams&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;正则表达式&lt;/code&gt; - 将提取输入名称和输入值属性的表达式 
    正则表达式：&lt;code&gt;input name="([^"]+?)" value="([^"]+?)"&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;模板&lt;/code&gt; - 将是空的&lt;/li&gt;
&lt;li&gt;&lt;code&gt;匹配数字&lt;/code&gt; - &lt;code&gt;-1&lt;/code&gt;（为了遍历所有可能的匹配）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;为第二个HTTP请求创建预处理程序正则表达式用户参数&lt;ul&gt;
&lt;li&gt;&lt;code&gt;引用名称&lt;/code&gt; - 设置正则表达式的相同引用名称，在我们的示例中是&lt;code&gt;listParams&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Parameter names group number&lt;/code&gt; - 参数名称的正则表达式的组编号，在我们的示例中为&lt;code&gt;1&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Parameter values group number&lt;/code&gt; - 参数值的正则表达式的组编号，在我们的示例中为&lt;code&gt;2&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;另请参阅&lt;a href="http://jmeter.apache.org/usermanual/component_reference.html#Regular_Expression_Extractor"&gt;正则表达式提取器&lt;/a&gt;元件，该元件用于提取参数名称和值。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;另请参阅：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://jmeter.apache.org/demos/RegEx-User-Parameters.jmx"&gt;展示如何使用正则表达式用户参数的测试计划&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href="#toc"&gt;【返回目录】&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="_70"&gt;取样器超时&lt;/h3&gt;
&lt;p&gt;如果完成时间过长，此前置处理器会调度计时器任务以中断样本。如果超时为零或为负，则忽略超时。为此，取样器必须实现可中断。已知以下取样器可实现：
AJP，BeanShell，FTP，HTTP，Soap，AccessLog，邮件阅读者，JMS订阅，TCP取样器，测试活动，Java取样器&lt;/p&gt;
&lt;p&gt;此测试元件适用于连接超时或响应超时等单个超时不足或取样器不支持超时的情况。超时应设置得足够长，以使在正常测试中不会被触发，同时要足够短以使它会能中断被卡住的样本。&lt;/p&gt;
&lt;p&gt;【默认情况下，JMeter使用Callable来中断取样器。这与定时器在同一个线程中执行，因此如果中断需要很长时间，则可能会延迟后续超时的处理。这不是一个问题，但如果有必要， 可以将属性&lt;code&gt;InterruptTimer.useRunnable&lt;/code&gt;设置为&lt;code&gt;true&lt;/code&gt;以使用单独的Runnable线程而不是Callable。】&lt;/p&gt;
&lt;p&gt;&lt;img alt="Screenshot for Control-Panel of Sample Timeout" src="http://jmeter.apache.org/images/screenshots/sample_timeout.png"&gt;&lt;br&gt;
&lt;em&gt;取样器超时控制面板的截图&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参数&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th align="left"&gt;是否必须&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;名称&lt;/td&gt;
&lt;td&gt;树中显示的此定时器的描述性名称。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Sample Timeout&lt;/td&gt;
&lt;td&gt;样本执行超出时间后，将被中断。&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;a href="#toc"&gt;【返回目录】&lt;/a&gt;&lt;/p&gt;
&lt;h2 id="188"&gt;18.8 后置处理器&lt;/h2&gt;
&lt;p&gt;顾名思义，后置处理器适用于取样器之后。请注意，它们适用于同一范围内的&lt;strong&gt;所有&lt;/strong&gt;取样器，因此要确保后置处理器仅应用于特定取样器，请将其添加为取样器的子级。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注意：除非另有说明，否则后置处理器不适用于子样本 - 仅适用于父样本。对于JSR223和BeanShell后置处理器，脚本可以使用&lt;code&gt;prev.getSubResults()&lt;/code&gt;方法检索子样本，该方法返回SampleResults数组。如果没有，则数组将为空。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;后置处理器在断言之前运行，因此它们无法访问任何断言结果，样本状态也不会反映任何断言的结果。如果您需要访问断言结果，请尝试使用监听器。另请注意，在运行所有断言后，变量&lt;code&gt;JMeterThread.last_sample_ok&lt;/code&gt;设置为“&lt;code&gt;true&lt;/code&gt;”或“&lt;code&gt;false&lt;/code&gt;”。&lt;/p&gt;
&lt;h3 id="_71"&gt;正则表达式提取器&lt;/h3&gt;
&lt;p&gt;允许用户使用Perl类型的正则表达式从服务器响应中提取值。作为后置处理器，此元件将在其范围内的每个样本请求之后执行，应用正则表达式，提取请求的值，生成模板字符串，并将结果存储到给定的变量名称中。&lt;/p&gt;
&lt;p&gt;&lt;img alt="Screenshot for Control-Panel of Regular Expression Extractor" src="http://jmeter.apache.org/images/screenshots/regex_extractor.png"&gt;&lt;br&gt;
&lt;em&gt;正则表达式提取器控制面板的截图&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参数&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th align="left"&gt;是否必须&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;名称&lt;/td&gt;
&lt;td&gt;树中显示的此元件的描述性名称。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Apply to:&lt;/td&gt;
&lt;td&gt;这适用于可以生成子样本的取样器，例如带有内嵌资源的HTTP取样器，邮件阅读者或事务控制器生成的样本。&lt;ul&gt;&lt;li&gt;&lt;code&gt;Main sample only&lt;/code&gt; - 仅适用于主样本&lt;/li&gt;&lt;li&gt;&lt;code&gt;Sub-samples only&lt;/code&gt; - 仅适用于子样本&lt;/li&gt;&lt;li&gt;&lt;code&gt;Main sample and sub-samples&lt;/code&gt; - 适用于两者。&lt;/li&gt;&lt;li&gt;&lt;code&gt;JMeter Variable Name to use&lt;/code&gt; - 断言将应用于命名变量的内容&lt;/li&gt;&lt;/ul&gt;匹配依次应用于所有符合条件的样本。例如，如果存在主样本和3个子样本，每个子样本包含正则表达式的单个匹配（即总共4个匹配）。对于匹配数字=&lt;code&gt;3&lt;/code&gt;，仅适用于子样本，提取器将匹配第3个子样本。对于匹配数=&lt;code&gt;3&lt;/code&gt;，匹配主样本和子样本，提取器将匹配第2个子样本（第1个匹配是主样本）。对于匹配数字=&lt;code&gt;0&lt;/code&gt;或负数，将处理所有符合条件的样本。对于匹配数字&amp;gt;&lt;code&gt;0&lt;/code&gt;，匹配将在找到足够的匹配后立即停止。&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;要检查的响应字段&lt;/td&gt;
&lt;td&gt;可以检查以下字段：&lt;ul&gt;&lt;li&gt;&lt;code&gt;主体&lt;/code&gt; - 响应的消息体，例如网页的内容（不包括信息头）&lt;/li&gt;&lt;li&gt;&lt;code&gt;Body (unescaped)&lt;/code&gt; - 响应的消息体，替换了所有Html转义码。注意处理Html转义时不考虑上下文，因此可能会进行一些不正确的替换。&lt;blockquote&gt;注意此选项会严重影响性能，因此仅在绝对必要并了解其影响时才使用它&lt;/blockquote&gt;&lt;/li&gt;&lt;li&gt;&lt;code&gt;Body as a Document&lt;/code&gt; - 通过Apache Tika从各种类型的文档中提取文本（请参阅&lt;a href="http://jmeter.apache.org/usermanual/component_reference.html#View_Results_Tree"&gt;查看结果树&lt;/a&gt;文档视图部分）。&lt;blockquote&gt;注意Body as a Document选项可能会影响性能，因此请确保这样测试没问题&lt;/blockquote&gt;&lt;/li&gt;&lt;li&gt;&lt;code&gt;Request Headers&lt;/code&gt; - 非HTTP样本可能不存在&lt;/li&gt;&lt;li&gt;&lt;code&gt;信息头&lt;/code&gt; - 非HTTP样本可能不存在&lt;/li&gt;&lt;li&gt;&lt;code&gt;URL&lt;/code&gt;&lt;/li&gt;&lt;li&gt;&lt;code&gt;响应代码&lt;/code&gt; - 例如&lt;code&gt;200&lt;/code&gt;&lt;/li&gt;&lt;li&gt;&lt;code&gt;响应信息&lt;/code&gt; - 例如&lt;code&gt;OK&lt;/code&gt;&lt;/li&gt;&lt;/ul&gt;信息头对HTTP样本很有用；它可能不适用于其他样本类型。&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;引用名称&lt;/td&gt;
&lt;td&gt;用于存储结果的JMeter变量的名称。另请注意，每个组都存储为形如&lt;code&gt;[refname]_g#&lt;/code&gt;，其中&lt;code&gt;[refname]&lt;/code&gt;是您输入的作为引用名称的字符串，&lt;code&gt;＃&lt;/code&gt;是组号，其中组&lt;code&gt;0&lt;/code&gt;是整个匹配，组&lt;code&gt;1&lt;/code&gt;是第一组括号的匹配等&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;正则表达式&lt;/td&gt;
&lt;td&gt;用于解析响应数据的正则表达式。除非使用组&lt;code&gt;$0$&lt;/code&gt;，否则必须包含至少一组括号“&lt;code&gt;()&lt;/code&gt;”来捕获字符串的一部分。不要将表达式括在&lt;code&gt;/ /&lt;/code&gt;中 - 除非你确实想要匹配这些字符。&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;模板&lt;/td&gt;
&lt;td&gt;用于从找到的匹配项创建字符串的模板。这是一个包含特殊元素的任意字符串，用于引用正则表达式中的组。引用组的语法是：'&lt;code&gt;$1$&lt;/code&gt;'表示组&lt;code&gt;1&lt;/code&gt;，'&lt;code&gt;$2$&lt;/code&gt;'表示组&lt;code&gt;2&lt;/code&gt;，等等。&lt;code&gt;$0$&lt;/code&gt;表示整个表达式匹配的内容。&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;匹配数字（0代表随机）&lt;/td&gt;
&lt;td&gt;指示要使用的匹配项。正则表达式可以多次匹配。&lt;ul&gt;&lt;li&gt;用零值表示JMeter随机选择匹配&lt;/li&gt;&lt;li&gt;正数N表示选择第n个匹配。&lt;/li&gt;&lt;li&gt;负数与&lt;a href="http://jmeter.apache.org/usermanual/component_reference.html#ForEach_Controller"&gt;ForEach控制器&lt;/a&gt;一起使用- 见下文。&lt;/li&gt;&lt;/ul&gt;&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;缺省值&lt;/td&gt;
&lt;td&gt;如果正则表达式没有匹配，则引用变量将设置为默认值。这对于调试测试特别有用。如果没有提供默认值，则很难判断是正则表达式没有匹配，还是正则表达式元件未处理或者使用了错误的变量。&lt;br /&gt;然而，如果您有多个设置相同变量的测试元件，如果表达式没有匹配，您可能希望保持变量不变。在这种情况下，请在调试完成后删除默认值。&lt;/td&gt;
&lt;td align="left"&gt;否，但推荐&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;使用空默认值&lt;/td&gt;
&lt;td&gt;如果选中该复选框并且&lt;code&gt;缺省值&lt;/code&gt;为空，则JMeter会将变量设置为空字符串而不是不设置它。因此，当您在测试计划中使用&lt;code&gt;${var}&lt;/code&gt;（假设&lt;code&gt;引用名称&lt;/code&gt;为var）时，如果未找到提取的值，则&lt;code&gt;${var}&lt;/code&gt;的值将等于空字符串而不是&lt;code&gt;${var}&lt;/code&gt;，如果提取的值是可选的，这可能非常有用。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;如果匹配号设置为非负数，并且匹配到内容，则变量设置如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;refName&lt;/code&gt; - 模板的值&lt;/li&gt;
&lt;li&gt;&lt;code&gt;refName_gn&lt;/code&gt;，其中&lt;code&gt;n&lt;/code&gt; = &lt;code&gt;0&lt;/code&gt;，&lt;code&gt;1&lt;/code&gt;，&lt;code&gt;2&lt;/code&gt; - 匹配的组&lt;/li&gt;
&lt;li&gt;&lt;code&gt;refName_g&lt;/code&gt; - 正则表达式中的组数（不包括&lt;code&gt;0&lt;/code&gt;）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果没有匹配，则将&lt;code&gt;refName&lt;/code&gt;变量设置为默认值（除非不存在）。此外，删除以下变量：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;refName_g0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;refName_g1&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;refName_g&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果匹配号设置为负数，则处理取样器数据中的所有可能匹配。变量设置如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;refName_matchNr&lt;/code&gt; - 找到的匹配数；可能是&lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;refName_n&lt;/code&gt;，其中&lt;code&gt;n&lt;/code&gt; = &lt;code&gt;0&lt;/code&gt;，&lt;code&gt;1&lt;/code&gt;，&lt;code&gt;2&lt;/code&gt; 等 - 由模板生成的字符串&lt;/li&gt;
&lt;li&gt;&lt;code&gt;refName_n_gm&lt;/code&gt;，其中&lt;code&gt;m&lt;/code&gt; = &lt;code&gt;0&lt;/code&gt;，&lt;code&gt;1&lt;/code&gt;，&lt;code&gt;2&lt;/code&gt; - 匹配&lt;code&gt;n&lt;/code&gt;的组&lt;/li&gt;
&lt;li&gt;&lt;code&gt;refName&lt;/code&gt; - 始终设置为默认值&lt;/li&gt;
&lt;li&gt;&lt;code&gt;refName_gn&lt;/code&gt; - 未设置&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;注意在这种情况下，&lt;code&gt;refName&lt;/code&gt;变量始终设置为默认值，并且未设置关联的组变量。&lt;/p&gt;
&lt;p&gt;有关如何指定修饰符及&lt;a href="http://jmeter.apache.org/usermanual/regular_expressions.html"&gt;关于JMeter正则表达式的更多信息&lt;/a&gt;，请参阅&lt;a href="http://jmeter.apache.org/usermanual/component_reference.html#Response_Assertion"&gt;响应断言&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;a href="#toc"&gt;【返回目录】&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="csscssjquery"&gt;CSS选择器提取器（即：CSS/JQuery提取器）&lt;/h3&gt;
&lt;p&gt;允许用户使用CSS选择器语法从服务器HTML响应中提取值。作为后置处理器，此元件将在其范围内的每个样本请求之后执行，应用CSS/JQuery表达式，提取所请求的节点，将节点提取为文本或属性值并将结果存储到给定的变量名称中。&lt;/p&gt;
&lt;p&gt;&lt;img alt="Screenshot for Control-Panel of CSS Selector Extractor" src="http://jmeter.apache.org/images/screenshots/css_extractor_attr.png"&gt;&lt;br&gt;
&lt;em&gt;CSS选择器提取器控制面板的截图&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参数&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th align="left"&gt;是否必须&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;名称&lt;/td&gt;
&lt;td&gt;树中显示的此元件的描述性名称。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Apply to:&lt;/td&gt;
&lt;td&gt;这适用于可以生成子样本的取样器，例如带有内嵌资源的HTTP取样器，邮件阅读者或事务控制器生成的样本。&lt;ul&gt;&lt;li&gt;&lt;code&gt;Main sample only&lt;/code&gt; - 仅适用于主样本&lt;/li&gt;&lt;li&gt;&lt;code&gt;Sub-samples only&lt;/code&gt; - 仅适用于子样本&lt;/li&gt;&lt;li&gt;&lt;code&gt;Main sample and sub-samples&lt;/code&gt; - 适用于两者。&lt;/li&gt;&lt;li&gt;&lt;code&gt;JMeter Variable Name to use&lt;/code&gt; - 断言将应用于命名变量的内容&lt;/li&gt;&lt;/ul&gt;匹配依次应用于所有符合条件的样本。例如，如果存在主样本和3个子样本，每个子样本包含正则表达式的单个匹配（即总共4个匹配）。对于匹配数字=&lt;code&gt;3&lt;/code&gt;，仅适用于子样本，提取器将匹配第3个子样本。对于匹配数=&lt;code&gt;3&lt;/code&gt;，匹配主样本和子样本，提取器将匹配第2个子样本（第1个匹配是主样本）。对于匹配数字=&lt;code&gt;0&lt;/code&gt;或负数，将处理所有符合条件的样本。对于匹配数字&amp;gt;&lt;code&gt;0&lt;/code&gt;，匹配将在找到足够的匹配后立即停止。&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;CSS选择器实现&lt;/td&gt;
&lt;td&gt;支持基于CSS/JQuery语法的2种实现：&lt;ul&gt;&lt;li&gt;&lt;a href="http://jsoup.org/"&gt;JSoup&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href="http://jodd.org/doc/lagarto/index.html"&gt;Jodd-Lagarto（CSSelly）&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;如果选择器设置为空，则将使用默认实现（JSoup）。&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;引用名称&lt;/td&gt;
&lt;td&gt;用于存储结果的JMeter变量的名称。&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;CSS/JQuery表达式&lt;/td&gt;
&lt;td&gt;CSS / JQuery选择器用于从响应数据中选择节点。支持选择器，选择器组合和伪选择器，示例：&lt;ul&gt;&lt;li&gt;&lt;code&gt;E[foo]&lt;/code&gt; - 具有“&lt;code&gt;foo&lt;/code&gt;”属性的&lt;code&gt;E&lt;/code&gt;元素&lt;/li&gt;&lt;li&gt;&lt;code&gt;ancestor child&lt;/code&gt; - 祖先节点下的子元素，例如&lt;code&gt;.body p&lt;/code&gt;在具有&lt;code&gt;class="intro"&lt;/code&gt;块下的任意位置找到&lt;code&gt;p&lt;/code&gt;元素&lt;/li&gt;&lt;li&gt;&lt;code&gt;:lt(n)&lt;/code&gt; - 查找其兄弟索引（即它在DOM树中相对于其父节点的位置）小于&lt;code&gt;n&lt;/code&gt;的元素；例如：&lt;code&gt;td:lt(3)&lt;/code&gt;&lt;/li&gt;&lt;li&gt;&lt;code&gt;:contains(text)&lt;/code&gt; - 查找包含给定&lt;code&gt;text&lt;/code&gt;的元素。搜索不区分大小写；例如&lt;code&gt;p:contains(jsoup)&lt;/code&gt;&lt;/li&gt;&lt;li&gt;...&lt;/li&gt;&lt;/ul&gt;有关语法的更多详细信息，请参阅：&lt;ul&gt;&lt;li&gt;&lt;a href="http://jsoup.org/"&gt;JSoup&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href="http://jodd.org/doc/lagarto/index.html"&gt;Jodd-Lagarto（CSSelly）&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;属性&lt;/td&gt;
&lt;td&gt;从与选择器匹配的节点中提取的属性名称（根据HTML语法）。如果为空，则返回此元素及其所有子元素的组合文本。&lt;br /&gt;如果设置了属性，这是JSoup的等效&lt;a href="http://jsoup.org/apidocs/org/jsoup/nodes/Node.html#attr(java.lang.String)"&gt;Element#attr(name)&lt;/a&gt;函数。&lt;br /&gt;&lt;img alt="CSS Extractor with attribute value set" src="http://jmeter.apache.org/images/screenshots/css_extractor_attr.png"&gt;&lt;br /&gt;&lt;em&gt;设置属性值的CSS选择器&lt;/em&gt;&lt;br /&gt;如果为空，这相当于JSoup 的&lt;a href="http://jsoup.org/apidocs/org/jsoup/nodes/Element.html#text()"&gt;Element＃text（）&lt;/a&gt;函数，如果没有为属性设置值。&lt;br /&gt;&lt;img alt="CSS Extractor with no attribute set" src="http://jmeter.apache.org/images/screenshots/css_extractor_noattr.png"&gt;&lt;br /&gt;&lt;em&gt;没有设置属性的CSS选择器&lt;/em&gt;&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;匹配数字（0代表随机）&lt;/td&gt;
&lt;td&gt;指示要使用的匹配项。CSS/JQuery选择器可能会多次匹配。&lt;ul&gt;&lt;li&gt;用零值表示JMeter随机选择匹配&lt;/li&gt;&lt;li&gt;正数N表示选择第n个匹配。&lt;/li&gt;&lt;li&gt;负数与&lt;a href="http://jmeter.apache.org/usermanual/component_reference.html#ForEach_Controller"&gt;ForEach控制器&lt;/a&gt;一起使用- 见下文。&lt;/li&gt;&lt;/ul&gt;&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;缺省值&lt;/td&gt;
&lt;td&gt;如果表达式没有匹配，则引用变量将设置为默认值。这对于调试测试特别有用。如果没有提供默认值，则很难判断是表达式没有匹配，还是CSS/JQuery元件未处理或者使用了错误的变量。&lt;br /&gt;然而，如果您有多个设置相同变量的测试元件，如果表达式没有匹配，您可能希望保持变量不变。在这种情况下，请在调试完成后删除默认值。&lt;/td&gt;
&lt;td align="left"&gt;否，但推荐&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;使用空默认值&lt;/td&gt;
&lt;td&gt;如果选中该复选框并且&lt;code&gt;缺省值&lt;/code&gt;为空，则JMeter会将变量设置为空字符串而不是不设置它。因此，当您在测试计划中使用&lt;code&gt;${var}&lt;/code&gt;（假设&lt;code&gt;引用名称&lt;/code&gt;为var）时，如果未找到提取的值，则&lt;code&gt;${var}&lt;/code&gt;的值将等于空字符串而不是&lt;code&gt;${var}&lt;/code&gt;，如果提取的值是可选的，这可能非常有用。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;如果匹配号设置为非负数，并且匹配发生，则变量设置如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;refName&lt;/code&gt; - 模板的值&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果不匹配，则将&lt;code&gt;refName&lt;/code&gt;变量设置为默认值（除非不存在）。&lt;/p&gt;
&lt;p&gt;如果匹配号设置为负数，则处理取样器数据中的所有可能匹配。变量设置如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;refName_matchNr&lt;/code&gt; - 找到的匹配数；可能是&lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;refName_n&lt;/code&gt;，其中&lt;code&gt;n&lt;/code&gt; = &lt;code&gt;0&lt;/code&gt;，&lt;code&gt;1&lt;/code&gt;，&lt;code&gt;2&lt;/code&gt; 等 - 由模板生成的字符串&lt;/li&gt;
&lt;li&gt;&lt;code&gt;refName&lt;/code&gt; - 始终设置为默认值&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;请注意，在这种情况下，&lt;code&gt;refName&lt;/code&gt;变量始终设置为默认值。&lt;/p&gt;
&lt;p&gt;&lt;a href="#toc"&gt;【返回目录】&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="xpath2-extractor"&gt;XPath2 Extractor&lt;/h3&gt;
&lt;p&gt;此测试元件允许用户使用XPath2查询语言从结构化响应（XML或(X)HTML）中提取值。&lt;/p&gt;
&lt;p&gt;&lt;img alt="Screenshot for Control-Panel of XPath2 Extractor" src="http://jmeter.apache.org/images/screenshots/xpath2_extractor.png"&gt;&lt;br&gt;
&lt;em&gt;XPath2 Extractor控制面板的截图&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参数&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th align="left"&gt;是否必须&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;名称&lt;/td&gt;
&lt;td&gt;树中显示的此元件的描述性名称。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Apply to:&lt;/td&gt;
&lt;td&gt;这适用于可以生成子样本的取样器，例如带有内嵌资源的HTTP取样器，邮件阅读者或事务控制器生成的样本。&lt;ul&gt;&lt;li&gt;&lt;code&gt;Main sample only&lt;/code&gt; - 仅适用于主样本&lt;/li&gt;&lt;li&gt;&lt;code&gt;Sub-samples only&lt;/code&gt; - 仅适用于子样本&lt;/li&gt;&lt;li&gt;&lt;code&gt;Main sample and sub-samples&lt;/code&gt; - 适用于两者。&lt;/li&gt;&lt;li&gt;&lt;code&gt;JMeter Variable Name to use&lt;/code&gt; - 断言将应用于命名变量的内容&lt;/li&gt;&lt;/ul&gt;XPath匹配依次应用于所有符合条件的样本，并返回所有匹配的结果。&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Return entire XPath fragment instead of text content?&lt;/td&gt;
&lt;td&gt;如果选中，将返回片段而不是文本内容。&lt;br/&gt;例如&lt;code&gt;//title&lt;/code&gt;将返回“&lt;code&gt;&amp;lt;title&amp;gt;Apache JMeter&amp;lt;/title&amp;gt;&lt;/code&gt;”而不是“&lt;code&gt;Apache JMeter&lt;/code&gt;”。&lt;br/&gt;在这种情况下，&lt;code&gt;//title/text()&lt;/code&gt;将返回“&lt;code&gt;Apache JMeter&lt;/code&gt;”。&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;引用名称&lt;/td&gt;
&lt;td&gt;用于存储结果的JMeter变量的名称。&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;XPath Query&lt;/td&gt;
&lt;td&gt;XPath 2.0语言的元素查询。可以返回多个匹配项。&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;匹配数字（0代表随机）&lt;/td&gt;
&lt;td&gt;如果XPath路径查询导致许多结果，您可以选择要提取哪个（些）作为变量：&lt;ul&gt;&lt;li&gt;&lt;code&gt;0&lt;/code&gt;：表示随机（默认值）&lt;/li&gt;&lt;li&gt;&lt;code&gt;1&lt;/code&gt;：表示提取所有结果，它们将命名为形如&lt;code&gt;&amp;lt;variable name&amp;gt;_N&lt;/code&gt;（其中&lt;code&gt;N&lt;/code&gt;从1到结果数）&lt;/li&gt;&lt;li&gt;&lt;code&gt;X&lt;/code&gt;：表示提取第X个结果。如果此X大于匹配数，则不返回任何内容。将使用默认值&lt;/li&gt;&lt;/ul&gt;&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;缺省值&lt;/td&gt;
&lt;td&gt;找不到匹配项时返回默认值。如果节点没有值并且未选择片段选项，也会返回它。&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Namespaces aliases list&lt;/td&gt;
&lt;td&gt;用于解析文档的命名空间别名列表，每个声明一行。您必须将它们指定为：&lt;code&gt;prefix=namespace&lt;/code&gt;这样的。此实现使得使用命名空间比使用旧版本的XPath提取器更容易。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;要允许在&lt;a href="http://jmeter.apache.org/usermanual/component_reference.html#ForEach_Controller"&gt;ForEach控制器&lt;/a&gt;中使用，它的工作方式与上面的XPath提取器完全相同。&lt;/p&gt;
&lt;p&gt;XPath2 Extractor提供了一些有趣的工具，例如改进的语法和比它的第一个版本更多的功能。&lt;/p&gt;
&lt;p&gt;以下是一些例子：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;abs(/book/page[2])&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;从book中提取第2个page的绝对值&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;avg(/librarie/book/page)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;从librarie中的所有book中提取平均page数&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;compare(/book[1]/page[2],/book[2]/page[2])&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;如果第1个book的第2个page等于第2个book的第2个page，返回整数值0，否则返回-1。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;要查看有关函数的更多信息，请参阅&lt;a href="http://saxon.sourceforge.net/saxon7.9.1/functions.html"&gt;xPath2函数&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;a href="#toc"&gt;【返回目录】&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="xpath_1"&gt;XPath提取器&lt;/h3&gt;
&lt;p&gt;此测试元件允许用户使用XPath查询语言从结构化响应（XML或(X)HTML）中提取值。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;从JMeter 5.0开始，您应该使用&lt;a href="http://jmeter.apache.org/usermanual/component_reference.html#XPath2_Extractor"&gt;XPath2 Extractor&lt;/a&gt;，因为它提供了更好，更简单的命名空间管理，更好的性能和对XPath 2.0的支持&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img alt="Screenshot for Control-Panel of XPath Extractor" src="http://jmeter.apache.org/images/screenshots/xpath_extractor.png"&gt;&lt;br&gt;
&lt;em&gt;XPath提取器控制面板的截图&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参数&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th align="left"&gt;是否必须&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;名称&lt;/td&gt;
&lt;td&gt;树中显示的此元件的描述性名称。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Apply to:&lt;/td&gt;
&lt;td&gt;这适用于可以生成子样本的取样器，例如带有内嵌资源的HTTP取样器，邮件阅读者或事务控制器生成的样本。&lt;ul&gt;&lt;li&gt;&lt;code&gt;Main sample only&lt;/code&gt; - 仅适用于主样本&lt;/li&gt;&lt;li&gt;&lt;code&gt;Sub-samples only&lt;/code&gt; - 仅适用于子样本&lt;/li&gt;&lt;li&gt;&lt;code&gt;Main sample and sub-samples&lt;/code&gt; - 适用于两者。&lt;/li&gt;&lt;li&gt;&lt;code&gt;JMeter Variable Name to use&lt;/code&gt; - 断言将应用于命名变量的内容&lt;/li&gt;&lt;/ul&gt;XPath匹配依次应用于所有符合条件的样本，并返回所有匹配的结果。&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Use Tidy (tolerant parser)&lt;/td&gt;
&lt;td&gt;如果选中则使用Tidy将HTML响应解析为XHTML。&lt;ul&gt;&lt;li&gt;对于HTML响应，“&lt;code&gt;Use Tidy&lt;/code&gt;”应选中。使用Tidy将此类响应转换为有效的XHTML（XML兼容HTML）&lt;/li&gt;&lt;li&gt;对于XHTML或XML响应（例如RSS），应该取消选中“&lt;code&gt;Use Tidy&lt;/code&gt;”&lt;/li&gt;&lt;/ul&gt;&lt;blockquote&gt;对于HTML，CSS选择器提取器是正确且有效的方案。不要将XPath用于HTML提取。&lt;/blockquote&gt;&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Quiet&lt;/td&gt;
&lt;td&gt;设置Tidy Quiet标志&lt;/td&gt;
&lt;td align="left"&gt;如果选择了Tidy&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;报告异常&lt;/td&gt;
&lt;td&gt;如果发生Tidy异常，则相应地设置断言&lt;/td&gt;
&lt;td align="left"&gt;如果选择了Tidy&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;显示警告&lt;/td&gt;
&lt;td&gt;设置Tidy显示警告选项&lt;/td&gt;
&lt;td align="left"&gt;如果选择了Tidy&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Use Namespaces&lt;/td&gt;
&lt;td&gt;如果选中，则XML解析器将使用命名空间解析。（请参阅下面关于命名空间的注释）注意目前只能识别在根元素上声明的命名空间。有关用户定义的其他工作区名称的，请参见下文。&lt;/td&gt;
&lt;td align="left"&gt;如果未选择Tidy&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Validate XML&lt;/td&gt;
&lt;td&gt;根据其架构检查文档。&lt;/td&gt;
&lt;td align="left"&gt;如果未选择Tidy&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Ignore Whitespace&lt;/td&gt;
&lt;td&gt;忽略空白元素。&lt;/td&gt;
&lt;td align="left"&gt;如果未选择Tidy&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Fetch External DTDs&lt;/td&gt;
&lt;td&gt;如果选中，则获取外部DTD。&lt;/td&gt;
&lt;td align="left"&gt;如果未选择Tidy&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Return entire XPath fragment instead of text content?&lt;/td&gt;
&lt;td&gt;如果选中，将返回片段而不是文本内容。&lt;br/&gt;例如&lt;code&gt;//title&lt;/code&gt;将返回“&lt;code&gt;&amp;lt;title&amp;gt;Apache JMeter&amp;lt;/title&amp;gt;&lt;/code&gt;”而不是“&lt;code&gt;Apache JMeter&lt;/code&gt;”。&lt;br/&gt;在这种情况下，&lt;code&gt;//title/text()&lt;/code&gt;将返回“&lt;code&gt;Apache JMeter&lt;/code&gt;”。&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;引用名称&lt;/td&gt;
&lt;td&gt;用于存储结果的JMeter变量的名称。&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;XPath Query&lt;/td&gt;
&lt;td&gt;XPath语言的元素查询。可以返回多个匹配项。&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;匹配数字（0代表随机）&lt;/td&gt;
&lt;td&gt;如果XPath路径查询导致许多结果，您可以选择要提取哪个（些）作为变量：&lt;ul&gt;&lt;li&gt;&lt;code&gt;0&lt;/code&gt;：表示随机（默认值）&lt;/li&gt;&lt;li&gt;&lt;code&gt;1&lt;/code&gt;：表示提取所有结果，它们将命名为形如&lt;code&gt;&amp;lt;variable name&amp;gt;_N&lt;/code&gt;（其中&lt;code&gt;N&lt;/code&gt;从1到结果数）&lt;/li&gt;&lt;li&gt;&lt;code&gt;X&lt;/code&gt;：表示提取第X个结果。如果此X大于匹配数，则不返回任何内容。将使用默认值&lt;/li&gt;&lt;/ul&gt;&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;缺省值&lt;/td&gt;
&lt;td&gt;找不到匹配项时返回默认值。如果节点没有值并且未选择片段选项，也会返回它。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;要允许在&lt;a href="http://jmeter.apache.org/usermanual/component_reference.html#ForEach_Controller"&gt;ForEach控制器&lt;/a&gt;中使用，请在返回时设置以下变量：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;refName&lt;/code&gt; - 设置为第一个（或唯一）匹配；如果没有匹配，则设置为默认值&lt;/li&gt;
&lt;li&gt;&lt;code&gt;refName_matchNr&lt;/code&gt; - 设置为匹配数字（可能为&lt;code&gt;0&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;refName_n&lt;/code&gt;，&lt;code&gt;n&lt;/code&gt; = &lt;code&gt;0&lt;/code&gt;，&lt;code&gt;1&lt;/code&gt;，&lt;code&gt;2&lt;/code&gt; 等。设置为第1，第2，第3个匹配等&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;注意：下一个&lt;code&gt;refName_n&lt;/code&gt;变量设置为&lt;code&gt;null&lt;/code&gt; - 例如，如果有2个匹配项，则&lt;code&gt;refName_3&lt;/code&gt;设置为&lt;code&gt;null&lt;/code&gt;，如果没有匹配项，则&lt;code&gt;refName_1&lt;/code&gt;设置为&lt;code&gt;null&lt;/code&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;XPath是主要针对XSLT转换的查询语言。然而，它也可用作结构化数据的通用查询语言。有关更多信息，请参阅 &lt;a href="http://www.topxml.com/xsl/xpathref.asp"&gt;XPath参考&lt;/a&gt;或&lt;a href="http://www.w3.org/TR/xpath"&gt;XPath规范&lt;/a&gt;。以下是一些例子：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;/html/head/title&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;从HTML响应中提取title元素&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;/book/page[2]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;提取book中的第2个page&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;/book/page&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;提取book中的所有page&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;//form[@name='countryForm']//select[@name='country']/option[text()='Czech Republic'])/@value&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;提取name属性为&lt;code&gt;countryForm&lt;/code&gt;的form下name属性为&lt;code&gt;country&lt;/code&gt;的select元素下包含&lt;code&gt;Czech Republic&lt;/code&gt;文本的option元素的value属性&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;选中“&lt;code&gt;Use Tidy&lt;/code&gt;"时 - 生成的XML文档可能与原始HTML响应略有不同：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;所有元素和属性名称都转换为小写&lt;/li&gt;
&lt;li&gt;Tidy尝试纠正不正确的嵌套元素。例如 - 原始（不正确）&lt;code&gt;ul/font/li&lt;/code&gt;变为正确的&lt;code&gt;ul/li/font&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;有关更多信息，请参阅&lt;a href="http://jtidy.sf.net/"&gt;Tidy主页&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;命名空间&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;作为Xalan XPath解析器（JMeter所基于的实现）的命名空间限制的工作轮，您需要：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;提供一个属性文件（例如，如果您的文件名为namespaces.properties），其中包含名称空间前缀的映射：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt; prefix1=http\://foo.apache.org
 prefix2=http\://toto.apache.org
 …
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;通过在&lt;code&gt;user.properties&lt;/code&gt;文件中引用此文件来使用属性：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt; xpath.namespace.config=namespaces.properties
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;//mynamespace:tagname

//*[local-name()=&amp;#39;tagname&amp;#39; and namespace-uri()=&amp;#39;uri-for-namespace&amp;#39;]
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;uri-for-namespace&lt;/code&gt; &lt;code&gt;mynamespace&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="#toc"&gt;【返回目录】&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="_72"&gt;结果状态处理器&lt;/h3&gt;
&lt;p&gt;此测试元件允许用户在相关取样器发生故障后停止线程或整个测试。&lt;/p&gt;
&lt;p&gt;&lt;img alt="Screenshot for Control-Panel of Result Status Action Handler" src="http://jmeter.apache.org/images/screenshots/resultstatusactionhandler.png"&gt;&lt;br&gt;
&lt;em&gt;结果状态处理器控制面板的截图&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参数&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th align="left"&gt;是否必须&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;名称&lt;/td&gt;
&lt;td&gt;树中显示的此元件的描述性名称。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;在取样器错误后要执行的动作&lt;/td&gt;
&lt;td&gt;决定取样器发生错误（包括样本本身失败或断言失败）时发生什么。可能的选择是：&lt;ul&gt;&lt;li&gt;&lt;code&gt;继续&lt;/code&gt; - 忽略错误并继续测试&lt;/li&gt;&lt;li&gt;&lt;code&gt;启动下一进程循环&lt;/code&gt;- 不执行当前迭代的错误取样器之后的取样器，并重新启动循环进入下一次迭代&lt;/li&gt;&lt;li&gt;&lt;code&gt;停止线程&lt;/code&gt; - 退出当前线程&lt;/li&gt;&lt;li&gt;&lt;code&gt;停止测试&lt;/code&gt; - 在任何当前样本结束时停止整个测试。&lt;/li&gt;&lt;li&gt;&lt;code&gt;立即停止测试&lt;/code&gt; - 整个测试突然停止。可能的话，任何当前运行的取样器都会停止。&lt;/li&gt;&lt;/ul&gt;&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;a href="#toc"&gt;【返回目录】&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="beanshell_5"&gt;BeanShell后置处理程序&lt;/h3&gt;
&lt;p&gt;BeanShell预处理程器允许在采集样本后应用任意代码。&lt;/p&gt;
&lt;p&gt;BeanShell后置处理程器不再忽略具有零长度结果数据的样本。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;有关使用BeanShell的完整详细信息，请参阅&lt;a href="http://www.beanshell.org/"&gt;BeanShell网站&lt;/a&gt;。&lt;/strong&gt;  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;强烈建议迁移到&lt;a href="http://jmeter.apache.org/usermanual/component_reference.html#JSR223_Sampler"&gt;JSR223 Sampler&lt;/a&gt;+Groovy以提高性能，支持新的Java功能并限制BeanShell库的维护。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;测试元件支持&lt;code&gt;ThreadListener&lt;/code&gt;和&lt;code&gt;TestListener&lt;/code&gt;接口方法。这些必须在初始化文件中定义。有关定义的示例，请参阅文件&lt;code&gt;BeanShellListeners.bshrc&lt;/code&gt;。 &lt;/p&gt;
&lt;p&gt;&lt;img alt="Screenshot for Control-Panel of BeanShell PostProcessor" src="http://jmeter.apache.org/images/screenshots/beanshell_postprocessor.png"&gt;&lt;br&gt;
&lt;em&gt;BeanShell后置处理程序控制面板的截图&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参数&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th align="left"&gt;是否必须&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;名称&lt;/td&gt;
&lt;td&gt;树中显示的此元件的描述性名称。该名称存储在脚本变量&lt;code&gt;Label&lt;/code&gt;中&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;每次调用前重置bsh.Interpreter&lt;/td&gt;
&lt;td&gt;如果选择此选项，则将为每个样本重新创建解释器。对于某些长时间运行的脚本，这可能是必需的。有关详细信息请参阅&lt;a href="http://jmeter.apache.org/usermanual/best-practices#bsh_scripting"&gt;最佳实践 -  BeanShell脚本&lt;/a&gt;。&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;参数&lt;/td&gt;
&lt;td&gt;要传递给BeanShell脚本的参数。参数存储在以下变量中：&lt;br /&gt;&lt;code&gt;Parameters&lt;/code&gt;：包含参数的字符串，作为单个变量&lt;br /&gt;&lt;code&gt;bsh.args&lt;/code&gt;：包含参数的字符串数组，在空格处分割&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;脚本文件&lt;/td&gt;
&lt;td&gt;包含要运行的BeanShell脚本的文件。文件名存储在脚本变量&lt;code&gt;FileName&lt;/code&gt;中&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;脚本&lt;/td&gt;
&lt;td&gt;要运行的BeanShell脚本。返回值被忽略。&lt;/td&gt;
&lt;td align="left"&gt;是（除非提供脚本文件）&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;设置以下BeanShell变量供脚本使用：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;log&lt;/code&gt; - （&lt;a href="https://www.slf4j.org/api/org/slf4j/Logger.html"&gt;Logger&lt;/a&gt;） - 可用于写入日志文件&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;ctx&lt;/code&gt; - （&lt;a href="http://jmeter.apache.org/api/org/apache/jmeter/threads/JMeterContext.html"&gt;JMeterContext&lt;/a&gt;） - 允许访问上下文&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;vars&lt;/code&gt; - (&lt;a href="http://jmeter.apache.org/api/org/apache/jmeter/threads/JMeterVariables.html"&gt;JMeterVariables&lt;/a&gt;) - 提供对变量的读/写访问：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    vars.get(key);
    vars.put(key,val);
    vars.putObject(&amp;quot;OBJ1&amp;quot;,new Object());
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;props&lt;/code&gt; - （JMeterProperties - 类&lt;a href="https://docs.oracle.com/javase/8/docs/api/java/util/Properties.html"&gt;&lt;strong&gt;java.util.Properties&lt;/strong&gt;&lt;/a&gt;） - 例如&lt;code&gt;props.get("START.HMS");&lt;/code&gt; &lt;code&gt;props.put("PROP1","1234");&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;prev&lt;/code&gt; - （&lt;a href="http://jmeter.apache.org/api/org/apache/jmeter/samplers/SampleResult.html"&gt;SampleResult&lt;/a&gt;） - 提供对前一个&lt;a href="http://jmeter.apache.org/api/org/apache/jmeter/samplers/SampleResult.html"&gt;SampleResult&lt;/a&gt;的访问&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;data&lt;/code&gt;（byte []）提供对当前样本数据的访问&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;有关上述每个变量的所有可用方法的详细信息，请查看Javadoc。&lt;/p&gt;
&lt;p&gt;如果定义了属性&lt;code&gt;beanshell.listener.init&lt;/code&gt;，则用于加载初始化文件，该文件可用于定义在BeanShell脚本中使用的方法等。&lt;/p&gt;
&lt;p&gt;&lt;a href="#toc"&gt;【返回目录】&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="jsr223_4"&gt;JSR223后置处理程序&lt;/h3&gt;
&lt;p&gt;JSR223后置处理程序允许在获取样本后应用JSR223脚本代码。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参数&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th align="left"&gt;是否必须&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;名称&lt;/td&gt;
&lt;td&gt;树中显示的此元件的描述性名称。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;语言&lt;/td&gt;
&lt;td&gt;要使用的JSR223语言&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;参数&lt;/td&gt;
&lt;td&gt;要传递给脚本的参数。参数存储在以下变量中：&lt;ul&gt;&lt;li&gt;&lt;code&gt;Parameters&lt;/code&gt;包含参数作为单个变量的字符串&lt;/li&gt;&lt;li&gt;&lt;code&gt;args&lt;/code&gt;包含参数的字符串数组，在空格处分割&lt;/li&gt;&lt;/ul&gt;&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;脚本文件&lt;/td&gt;
&lt;td&gt;包含要运行的脚本的文件，如果使用相对文件路径，则它将相对于系统属性“&lt;code&gt;user.dir&lt;/code&gt;”引用的目录&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;脚本编译缓存&lt;/td&gt;
&lt;td&gt;测试计划中的唯一字符串，如果使用的语言支持&lt;a href="https://docs.oracle.com/javase/8/docs/api/javax/script/Compilable.html"&gt;Compilable&lt;/a&gt;接口（Groovy是其中之一，java，beanshell和javascript不是），则JMeter将用于缓存脚本编译的结果。&lt;blockquote&gt;如果您在不检查此选项的情况下使用Groovy，请参阅JSR223取样器Java系统属性中的注释&lt;/blockquote&gt;&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;脚本&lt;/td&gt;
&lt;td&gt;要运行的脚本。&lt;/td&gt;
&lt;td align="left"&gt;是（除非提供脚本文件）&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;在调用脚本之前，会设置一些变量。请注意，这些是JSR223变量 - 即它们可以直接在脚本中使用。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;log&lt;/code&gt; - （&lt;a href="https://www.slf4j.org/api/org/slf4j/Logger.html"&gt;Logger&lt;/a&gt;） - 可用于写入日志文件&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Label&lt;/code&gt; - 标签字符串&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;FileName&lt;/code&gt; - 脚本文件名（如果有）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Parameters&lt;/code&gt; - 参数（作为字符串）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;ARGS&lt;/code&gt; - 作为字符串数组的参数（在空格上拆分）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;CTX&lt;/code&gt; - （&lt;a href="http://jmeter.apache.org/api/org/apache/jmeter/threads/JMeterContext.html"&gt;JMeterContext&lt;/a&gt;） - 允许访问上下文&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;vars&lt;/code&gt; - （&lt;a href="http://jmeter.apache.org/api/org/apache/jmeter/threads/JMeterVariables.html"&gt;JMeterVariables&lt;/a&gt;） - 提供对变量的读/写访问权限：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;vars.get(key);
vars.put(key,val);
vars.putObject(&amp;quot;OBJ1&amp;quot;,new Object());
vars.getObject(&amp;quot;OBJ2&amp;quot;);
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;props&lt;/code&gt; - （JMeterProperties - 类&lt;a href="https://docs.oracle.com/javase/8/docs/api/java/util/Properties.html"&gt;java.util.Properties&lt;/a&gt;） - 例如&lt;code&gt;props.get("START.HMS");&lt;/code&gt; &lt;code&gt;props.put("PROP1","1234");&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;prev&lt;/code&gt; - （&lt;a href="http://jmeter.apache.org/api/org/apache/jmeter/samplers/SampleResult.html"&gt;SampleResult&lt;/a&gt;） - 允许访问上一个SampleResult（如果有的话）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;sampler&lt;/code&gt; - （&lt;a href="http://jmeter.apache.org/api/org/apache/jmeter/samplers/Sampler.html"&gt;取样器&lt;/a&gt;） - 提供对当前取样器的访问&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;OUT&lt;/code&gt; - &lt;code&gt;System.out&lt;/code&gt; - 例如&lt;code&gt;OUT.println("message")&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;有关上述每个变量的所有可用方法的详细信息，请查看Javadoc&lt;/p&gt;
&lt;p&gt;&lt;a href="#toc"&gt;【返回目录】&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="jdbc_2"&gt;JDBC后置处理程序&lt;/h3&gt;
&lt;p&gt;JDBC后置处理程序使您可以在样本运行后立即运行一些SQL语句。如果JDBC样本更改了某些数据，并且您希望将状态重置为JDBC样本运行之前的状态，那么这将非常有用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;另请参阅：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://jmeter.apache.org/demos/JDBC-Pre-Post-Processor.jmx"&gt;使用JDBC前置/后置处理器的测试计划&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在链接的测试计划中，JDBC后置处理程序“&lt;code&gt;JDBC PostProcessor&lt;/code&gt;”调用存储过程从数据库中删除由前置处理器创建的Price Cut-Off。&lt;/p&gt;
&lt;p&gt;&lt;img alt="JDBC PostProcessor" src="http://jmeter.apache.org/images/screenshots/jdbc-post-processor.png"&gt;
&lt;em&gt;JDBC后置处理程序&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="#toc"&gt;【返回目录】&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="json_1"&gt;JSON提取器&lt;/h3&gt;
&lt;p&gt;JSON后置处理程序使您可以使用JSON-PATH语法从JSON响应中提取数据。此后处理器与正则表达式提取器非常相似。它必须作为HTTP取样器或具有响应的其他任何取样器的子项放置。它将允许您以非常简单的方式提取文本内容，请参阅&lt;a href="http://goessner.net/articles/JsonPath/"&gt;JSON Path语法&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参数&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th align="left"&gt;是否必须&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;名称&lt;/td&gt;
&lt;td&gt;树中显示的此元件的描述性名称。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Names of created variables&lt;/td&gt;
&lt;td&gt;以分号分隔的变量名称，用于包含JSON-PATH表达式的结果（必须与JSON-PATH表达式的数量匹配）&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;JSON Path Expressions&lt;/td&gt;
&lt;td&gt;分号分隔的JSON-PATH表达式（必须匹配变量数量）&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Default Values&lt;/td&gt;
&lt;td&gt;以分号分隔的默认值，如果JSON-PATH表达式不返回任何结果则取默认值（必须匹配变量数量）&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Match No. (0 for Random)&lt;/td&gt;
&lt;td&gt;如果JSON Path查询导致许多结果，您可以选择要提取哪个（些）作为变量：&lt;ul&gt;&lt;li&gt;&lt;code&gt;0&lt;/code&gt;：表示随机（默认值）&lt;/li&gt;&lt;li&gt;&lt;code&gt;-1&lt;/code&gt;：表示提取所有结果，它们将命名为形如&lt;code&gt;&amp;lt;variable name&amp;gt;_N&lt;/code&gt;（其中&lt;code&gt;N&lt;/code&gt;从1到结果数）&lt;/li&gt;&lt;li&gt;&lt;code&gt;X&lt;/code&gt;：表示提取第X个结果。如果此X大于匹配数，则不返回任何内容。将使用默认值&lt;/li&gt;&lt;/ul&gt;&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Compute concatenation var&lt;/td&gt;
&lt;td&gt;如果找到很多结果，插件将使用'&lt;code&gt;,&lt;/code&gt;'分隔符将它们连接起来并存储在名为&lt;code&gt;&amp;lt;variable name&amp;gt;_ALL&lt;/code&gt;的变量中&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;img alt="JSON PostProcessor" src="http://jmeter.apache.org/images/screenshots/json-post-processor.png"&gt;
&lt;em&gt;JSON后置处理程序&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="#toc"&gt;【返回目录】&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="_73"&gt;边界提取器&lt;/h3&gt;
&lt;p&gt;允许用户使用左右边界从服务器响应中提取值。作为后置处理器，此元件将在其范围内的每个样本请求之后执行，测试边界，提取请求的值，生成模板字符串，并将结果存储到给定的变量名称中。&lt;/p&gt;
&lt;p&gt;&lt;img alt="Screenshot for Control-Panel of Boundary Extractor" src="http://jmeter.apache.org/images/screenshots/extractor/boundary_extractor.png"&gt;&lt;br&gt;
&lt;em&gt;边界提取器控制面板的截图&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参数&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th align="left"&gt;是否必须&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;名称&lt;/td&gt;
&lt;td&gt;树中显示的此元件的描述性名称。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Apply to:&lt;/td&gt;
&lt;td&gt;这适用于可以生成子样本的取样器，例如带有内嵌资源的HTTP取样器，邮件阅读者或事务控制器生成的样本。&lt;ul&gt;&lt;li&gt;&lt;code&gt;Main sample only&lt;/code&gt; - 仅适用于主样本&lt;/li&gt;&lt;li&gt;&lt;code&gt;Sub-samples only&lt;/code&gt; - 仅适用于子样本&lt;/li&gt;&lt;li&gt;&lt;code&gt;Main sample and sub-samples&lt;/code&gt; - 适用于两者。&lt;/li&gt;&lt;li&gt;&lt;code&gt;JMeter Variable Name to use&lt;/code&gt; - 断言将应用于命名变量的内容&lt;/li&gt;&lt;/ul&gt;匹配依次应用于所有符合条件的样本。例如，如果存在主样本和3个子样本，每个子样本包含正则表达式的单个匹配（即总共4个匹配）。对于匹配数字=&lt;code&gt;3&lt;/code&gt;，仅适用于子样本，提取器将匹配第3个子样本。对于匹配数=&lt;code&gt;3&lt;/code&gt;，匹配主样本和子样本，提取器将匹配第2个子样本（第1个匹配是主样本）。对于匹配数字=&lt;code&gt;0&lt;/code&gt;或负数，将处理所有符合条件的样本。对于匹配数字&amp;gt;&lt;code&gt;0&lt;/code&gt;，匹配将在找到足够的匹配后立即停止。&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;要检查的响应字段&lt;/td&gt;
&lt;td&gt;可以检查以下字段：&lt;ul&gt;&lt;li&gt;&lt;code&gt;主体&lt;/code&gt; - 响应的消息体，例如网页的内容（不包括信息头）&lt;/li&gt;&lt;li&gt;&lt;code&gt;Body (unescaped)&lt;/code&gt; - 响应的消息体，替换了所有Html转义码。注意处理Html转义时不考虑上下文，因此可能会进行一些不正确的替换。&lt;blockquote&gt;注意此选项会严重影响性能，因此仅在绝对必要并了解其影响时才使用它&lt;/blockquote&gt;&lt;/li&gt;&lt;li&gt;&lt;code&gt;Body as a Document&lt;/code&gt; - 通过Apache Tika从各种类型的文档中提取文本（请参阅&lt;a href="http://jmeter.apache.org/usermanual/component_reference.html#View_Results_Tree"&gt;查看结果树&lt;/a&gt;文档视图部分）。&lt;blockquote&gt;注意Body as a Document选项可能会影响性能，因此请确保这样测试没问题&lt;/blockquote&gt;&lt;/li&gt;&lt;li&gt;&lt;code&gt;Request Headers&lt;/code&gt; - 非HTTP样本可能不存在&lt;/li&gt;&lt;li&gt;&lt;code&gt;信息头&lt;/code&gt; - 非HTTP样本可能不存在&lt;/li&gt;&lt;li&gt;&lt;code&gt;URL&lt;/code&gt;&lt;/li&gt;&lt;li&gt;&lt;code&gt;响应代码&lt;/code&gt; - 例如&lt;code&gt;200&lt;/code&gt;&lt;/li&gt;&lt;li&gt;&lt;code&gt;响应信息&lt;/code&gt; - 例如&lt;code&gt;OK&lt;/code&gt;&lt;/li&gt;&lt;/ul&gt;信息头对HTTP样本很有用；它可能不适用于其他样本类型。&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;引用名称&lt;/td&gt;
&lt;td&gt;用于存储结果的JMeter变量的名称。另请注意，每个组都存储为形如&lt;code&gt;[refname]_g#&lt;/code&gt;，其中&lt;code&gt;[refname]&lt;/code&gt;是您输入的作为引用名称的字符串，&lt;code&gt;＃&lt;/code&gt;是组号，其中组&lt;code&gt;0&lt;/code&gt;是整个匹配，组&lt;code&gt;1&lt;/code&gt;是第一组括号的匹配等&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;左边界&lt;/td&gt;
&lt;td&gt;寻找值的左边界&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;右边界&lt;/td&gt;
&lt;td&gt;寻找值的右边界&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;匹配数字（0代表随机）&lt;/td&gt;
&lt;td&gt;指示要使用的匹配项。正则表达式可以多次匹配。&lt;ul&gt;&lt;li&gt;用零值表示JMeter随机选择匹配&lt;/li&gt;&lt;li&gt;正数N表示选择第n个匹配。&lt;/li&gt;&lt;li&gt;负数与&lt;a href="http://jmeter.apache.org/usermanual/component_reference.html#ForEach_Controller"&gt;ForEach控制器&lt;/a&gt;一起使用- 见下文。&lt;/li&gt;&lt;/ul&gt;&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;缺省值&lt;/td&gt;
&lt;td&gt;如果边界没有匹配，则引用变量将设置为默认值。这对于调试测试特别有用。如果没有提供默认值，则很难判断是边界没有匹配，还是使用了错误的变量。&lt;br /&gt;然而，如果您有多个设置相同变量的测试元件，如果表达式没有匹配，您可能希望保持变量不变。在这种情况下，请在调试完成后删除默认值。&lt;/td&gt;
&lt;td align="left"&gt;否，但推荐&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;如果匹配号设置为非负数，并且匹配到内容，则变量设置如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;refName&lt;/code&gt; - 提取的值&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果没有匹配，则将&lt;code&gt;refName&lt;/code&gt;变量设置为默认值（除非不存在）。&lt;/p&gt;
&lt;p&gt;如果匹配号设置为负数，则处理取样器数据中的所有可能匹配。变量设置如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;refName_matchNr&lt;/code&gt; - 找到的匹配数；可能是&lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;refName_n&lt;/code&gt;，其中&lt;code&gt;n&lt;/code&gt; = &lt;code&gt;0&lt;/code&gt;，&lt;code&gt;1&lt;/code&gt;，&lt;code&gt;2&lt;/code&gt; 等 - 由模板生成的字符串&lt;/li&gt;
&lt;li&gt;&lt;code&gt;refName_n_gm&lt;/code&gt;，其中&lt;code&gt;m&lt;/code&gt; = &lt;code&gt;0&lt;/code&gt;，&lt;code&gt;1&lt;/code&gt;，&lt;code&gt;2&lt;/code&gt; - 匹配&lt;code&gt;n&lt;/code&gt;的组&lt;/li&gt;
&lt;li&gt;&lt;code&gt;refName&lt;/code&gt; - 始终设置为默认值&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;注意在这种情况下，&lt;code&gt;refName&lt;/code&gt;变量始终设置为默认值，并且未设置关联的组变量。&lt;/p&gt;
&lt;p&gt;&lt;a href="#toc"&gt;【返回目录】&lt;/a&gt;&lt;/p&gt;
&lt;h2 id="189"&gt;18.9 其他功能&lt;/h2&gt;
&lt;h3 id="_74"&gt;测试计划&lt;/h3&gt;
&lt;p&gt;测试计划是指定测试总体设置的位置。&lt;/p&gt;
&lt;p&gt;可以为整个测试中重复的值定义静态变量，例如服务器名称。例如，变量&lt;code&gt;SERVER&lt;/code&gt;可以定义为&lt;code&gt;www.example.com&lt;/code&gt;，测试计划的其余部分可以使用&lt;code&gt;${SERVER}&lt;/code&gt;来引用它。这简化了以后改名的过程。&lt;/p&gt;
&lt;p&gt;如果在一个或多个&lt;a href="http://jmeter.apache.org/usermanual/component_reference.html#User_Defined_Variables"&gt;用户定义的变量&lt;/a&gt;配置元件上重用相同的变量名称 ，则该值将被测试计划中最后一个定义（从上到下读取）所设置。此类变量应用于可能在测试运行之间更改但在测试运行期间保持不变的项目。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注意测试计划不能引用它自身定义的变量。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果需要从“测试计划”变量构造其他变量，请使用“&lt;a href="http://jmeter.apache.org/usermanual/component_reference.html#User_Defined_Variables"&gt;用户定义的变量”&lt;/a&gt;测试元件。&lt;/p&gt;
&lt;p&gt;选择函数测试会使JMeter将额外的样本信息（响应数据和取样器数据）保存到所有结果文件。这增加了运行测试所需的资源，并可能对JMeter性能产生负面影响。如果仅是特定取样器需要更多数据，则向其添加监听器，并根据需要配置字段。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;该选项不会影响当前无法存储此类信息的CSV结果文件。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;此外，此处还存在一个选项，指示JMeter以串行方式而不是并行方式运行&lt;a href="http://jmeter.apache.org/usermanual/component_reference.html#Thread_Group"&gt;线程组&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;主线程结束后运行tearDown线程组：如果选中，则在正常结束主线程后运行tearDown线程组（如果有）。如果强制停止测试，则不会运行tearDown线程。&lt;/p&gt;
&lt;p&gt;测试计划现在提供了一种将classpath设置添加到特定测试计划的简便方法。该功能是附加的，这意味着您可以添加jar文件或目录，但删除条目需要重新启动JMeter。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注意这不能用于添加JMeter GUI插件，因为它们是前置处理的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;但是，它对于诸如JDBC驱动程序之类的实用程序jar可能很有用。jar只会添加到JMeter加载器的搜索路径中，而不会添加到系统类加载器中。&lt;/p&gt;
&lt;p&gt;JMeter属性还提供了一个用于加载其他classpath的条目。在&lt;code&gt;jmeter.properties&lt;/code&gt;中，编辑“&lt;code&gt;user.classpath&lt;/code&gt;”或“&lt;code&gt;plugin_dependency_paths&lt;/code&gt;”以包含其他库。有关详细信息，请参阅&lt;a href="http://jmeter.apache.org/usermanual/get-started.html#classpath"&gt;JMeter的classpath&lt;/a&gt;和 &lt;a href="http://jmeter.apache.org/usermanual/get-started.html#configuring_jmeter"&gt;配置JMeter&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img alt="Screenshot for Control-Panel of Test Plan" src="http://jmeter.apache.org/images/screenshots/testplan.png"&gt;&lt;br&gt;
&lt;em&gt;测试计划控制面板的截图&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="#toc"&gt;【返回目录】&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="_75"&gt;线程组&lt;/h3&gt;
&lt;p&gt;线程组定义了一个用户池，它将针对您的服务器执行特定的测试用例。在线程组GUI中，您可以控制模拟的用户数（线程数），ramp-up时间（启动所有线程所需的时间），执行测试的次数以及可选的启动和停止测试的时间。&lt;/p&gt;
&lt;p&gt;另请参见&lt;a href="http://jmeter.apache.org/usermanual/component_reference.html#tearDown_Thread_Group"&gt;tearDown线程组&lt;/a&gt;和&lt;a href="http://jmeter.apache.org/usermanual/component_reference.html#setUp_Thread_Group"&gt;setUp线程组&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;使用调度器时，JMeter会运行线程组，直到达到循环次数或达到持续时间/结束时间 - 以先发生者为准。请注意，仅在样本之间检查条件；当达到结束条件时，该线程将停止。JMeter不会中断等待响应的取样器，因此结束时间可能会被任意延迟。&lt;/p&gt;
&lt;p&gt;&lt;img alt="Screenshot for Control-Panel of Thread Group" src="http://jmeter.apache.org/images/screenshots/threadgroup.png"&gt;&lt;br&gt;
&lt;em&gt;线程组控制面板的截图&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;从JMeter 3.0开始，您可以通过选择并右键单击来运行选定的线程组。将出现一个弹出菜单：&lt;/p&gt;
&lt;p&gt;&lt;img alt="Popup menu to start a selection of Thread Groups" src="http://jmeter.apache.org/images/screenshots/threadgroup-popup-menu.png"&gt;
&lt;em&gt;启动选定线程组的弹出菜单&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;注意您有3个选项来运行选定的线程组：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;启动：仅启动选定的线程组&lt;/li&gt;
&lt;li&gt;不停顿启动：仅启动选定的线程组，但不运行定时器&lt;/li&gt;
&lt;li&gt;验证：仅使用验证模式启动选定的线程组。默认情况下，它以验证模式运行线程组（见下文）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;验证模式：&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;此模式通过运行1个线程，1次迭代，不运行定时器并且&lt;code&gt;启动延时&lt;/code&gt;设置为0来启用线程组的快速验证。此行为的某些属性可以通过在user.properties中设置来修改：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;testplan_validation.nb_threads_per_thread_group&lt;/code&gt;：用于验证线程组的线程数，默认为1&lt;/li&gt;
&lt;li&gt;&lt;code&gt;testplan_validation.ignore_timers&lt;/code&gt;：在验证计划的线程组时忽略定时器，默认为1&lt;/li&gt;
&lt;li&gt;&lt;code&gt;testplan_validation.number_iterations&lt;/code&gt;：用于验证线程组的迭代次数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;testplan_validation.tpc_force_100_pct&lt;/code&gt;：是否在百分比模式下以100%强制运行吞吐量控制器。默认为false&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;参数&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th align="left"&gt;是否必须&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;名称&lt;/td&gt;
&lt;td&gt;树中显示的此元件的描述性名称。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;在取样器错误后要执行的动作&lt;/td&gt;
&lt;td&gt;决定取样器发生错误（包括样本本身失败或断言失败）时发生什么。可能的选择是：&lt;ul&gt;&lt;li&gt;&lt;code&gt;继续&lt;/code&gt; - 忽略错误并继续测试&lt;/li&gt;&lt;li&gt;&lt;code&gt;启动下一进程循环&lt;/code&gt;- 忽略错误，启动下一次循环并继续测试&lt;/li&gt;&lt;li&gt;&lt;code&gt;停止线程&lt;/code&gt; - 退出当前线程&lt;/li&gt;&lt;li&gt;&lt;code&gt;停止测试&lt;/code&gt; - 在任何当前样本结束时停止整个测试。&lt;/li&gt;&lt;li&gt;&lt;code&gt;立即停止测试&lt;/code&gt; - 整个测试突然停止。可能的话，任何当前运行的取样器都会停止。&lt;/li&gt;&lt;/ul&gt;&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;线程数&lt;/td&gt;
&lt;td&gt;要模拟的用户数。&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Ramp-up时间&lt;/td&gt;
&lt;td&gt;JMeter启动所有线程花费的时间。如果有10个线程且ramp-up时间为100秒，则每个线程将在前一个线程启动后10秒开始，总时间为100秒，以使测试完全达到速度。&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;循环次数&lt;/td&gt;
&lt;td&gt;执行测试用例的次数。或者，可以选择“&lt;code&gt;永远&lt;/code&gt;”，使测试运行直到手动停止。&lt;/td&gt;
&lt;td align="left"&gt;是，除非选中永远&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;延迟创建线程直到需要&lt;/td&gt;
&lt;td&gt;如果选中，则仅在ramp-up时间的适当比例已经过去时创建线程。这最适合于ramp-up时间明显长于执行单个线程的时间的测试。即新的线程开始晚于之前的线程结束。 &lt;br/&gt;如果未选中，则在测试开始时创建所有线程（然后它们会暂停适当的ramp-up时间比例）。这是最初的默认值，适用于大多数测试中线程处于活动状态的测试。&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;调度器&lt;/td&gt;
&lt;td&gt;如果选中，则启用调度器&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;持续时间（秒）&lt;/td&gt;
&lt;td&gt;如果选择了调度器复选框，则可以选择相对结束时间。JMeter将使用它来计算结束时间。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;启动延迟（秒）&lt;/td&gt;
&lt;td&gt;如果选择了调度器复选框，则可以选择相对启动延迟。JMeter将使用它来计算开始时间。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;a href="#toc"&gt;【返回目录】&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="_76"&gt;工作台&lt;/h3&gt;
&lt;p&gt;&lt;a href="#toc"&gt;【返回目录】&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="ssl"&gt;SSL管理器&lt;/h3&gt;
&lt;p&gt;SSL管理器是一种选择客户端证书的方法，以便您可以测试使用公钥基础结构（PKI）的应用程序。仅在尚未设置相应的系统属性时才需要它。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如果要测试客户端证书身份验证，请参阅&lt;a href="http://jmeter.apache.org/usermanual/component_reference.html#Keystore_Configuration"&gt;密钥库配置&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;选择客户证书&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;您可以使用Java密钥库（JKS）格式密钥库，也可以使用公钥证书标准#12（PKCS12）文件作为客户端证书。JSSE库的一个功能是要求您的密钥至少具有六个字符的密码（至少对于JDK附带的keytool实用程序）。&lt;/p&gt;
&lt;p&gt;要选择客户端证书，请在菜单栏中选择&lt;em&gt;选项&lt;/em&gt;  →  &lt;em&gt;SSL管理器&lt;/em&gt;。您将看到一个文件查找器，默认情况下查找PKCS12文件。您的PKCS12文件必须具有扩展名“&lt;code&gt;.p12&lt;/code&gt;”，以便SSL管理器将其识别为PKCS12文件。任何其他文件将被视为普通的JKS密钥库。如果正确安装了JSSE，系统将提示您输入密码。文本框不会隐藏您此时键入的字符 - 因此请确保没有人偷看。当前实现假定密钥库的密码也是要进行身份验证的客户端的私钥的密码。&lt;/p&gt;
&lt;p&gt;或者，您可以设置适当的系统属性 - 请参阅&lt;code&gt;system.properties&lt;/code&gt;文件。&lt;/p&gt;
&lt;p&gt;下次运行测试时，SSL管理器将检查您的密钥库，以查看它是否至少有一个密钥可用。如果只有一个密钥，SSL管理器将为您选择它。如果有多个密钥，则目前选择第一个密钥。目前无法在密钥库中选择其他条目，因此所需的密钥必须是第一个。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;值得关注的事情&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果没有JDK附带的五个CA证书之一的签名，则必须正确安装证书颁发机构（CA）的证书。安装它的一种方法是将CA证书导入JKS文件，并将JKS文件命名为“&lt;code&gt;jssecacerts&lt;/code&gt;”。将文件放在JRE的&lt;code&gt;lib/security&lt;/code&gt;文件夹下。此文件将在同一目录中的“&lt;code&gt;cacerts&lt;/code&gt;”文件之前读取。请记住，只要存在“&lt;code&gt;jssecacerts&lt;/code&gt;”文件，就不会使用“&lt;code&gt;cacerts&lt;/code&gt;”中安装的证书。这可能会给您带来麻烦。如果您不介意将CA证书导入“&lt;code&gt;cacerts&lt;/code&gt;“文件，您可以对安装的所有CA证书进行身份验证。&lt;/p&gt;
&lt;p&gt;&lt;a href="#toc"&gt;【返回目录】&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="https-http"&gt;HTTP(S)测试脚本录制器 （即：HTTP代理服务器）&lt;/h3&gt;
&lt;p&gt;HTTP(S)测试脚本记录器允许JMeter在您使用普通浏览器浏览Web应用程序时拦截和记录您的操作。JMeter将创建测试样本对象并将其直接存储到您的测试计划中（因此您可以在制作样本时以交互方式查看样本）。&lt;br&gt;
确保您阅读此&lt;a href="https://wiki.apache.org/jmeter/TestRecording210"&gt;Wiki页面&lt;/a&gt;以正确设置JMeter。&lt;/p&gt;
&lt;p&gt;要使用记录器，请&lt;em&gt;添加&lt;/em&gt; HTTP(S)测试脚本记录器元件。右键单击测试计划元件以获取添加菜单：( &lt;em&gt;添加&lt;/em&gt;  →  &lt;em&gt;非测试元件&lt;/em&gt;  →  &lt;em&gt;HTTP代理服务器&lt;/em&gt; ）。&lt;/p&gt;
&lt;p&gt;记录器实现为HTTP(S)代理服务器。您需要设置浏览器使用代理来处理所有HTTP和HTTPS请求。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;不要将JMeter用作任何其他请求类型的代理 - FTP等 - 因为JMeter无法处理它们。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;理想情况下，在录制会话时使用隐私浏览模式。这将确保浏览器在没有存储cookie的情况下启动，并防止保存某些更改。例如，Firefox不允许永久保存证书覆盖。&lt;/p&gt;
&lt;h4 id="https"&gt;HTTPS录制和证书&lt;/h4&gt;
&lt;p&gt;HTTPS连接使用证书来验证浏览器和Web服务器之间的连接。通过HTTPS连接时，服务器会将证书提供给浏览器。为了验证证书，浏览器检查服务器证书是否由链接到其内置根CA之一的证书颁发机构（CA）签名。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;浏览器还会检查证书是否适用于正确的主机或域，并且证书有效且未过期。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果任何浏览器检查失败，它将提示用户决定是否允许连接继续。&lt;/p&gt;
&lt;p&gt;JMeter需要使用自己的证书来拦截来自浏览器的HTTPS连接。实际上，JMeter必须伪装成目标服务器。&lt;/p&gt;
&lt;p&gt;JMeter将生成自己的证书。这些是通过属性&lt;code&gt;proxy.cert.validity&lt;/code&gt;生成的，包含一个默认为7天有效期和随机密码。如果JMeter检测到它在Java 8或更高版本下运行，除非定义了以下属性：&lt;code&gt;proxy.cert.dynamic_keys=false&lt;/code&gt;，否则它将根据需要为每个目标服务器生成证书（动态模式）。使用动态模式时，证书将使用正确的主机名，并由JMeter生成的CA证书签名。默认情况下，浏览器不会信任此CA证书，但可以将其安装为受信任的证书。完成此操作后，浏览器将接受生成的服务器证书。这样做的好处是，即使是内含的HTTPS资源也可以被拦截，并且不需要覆盖每个新服务器的浏览器检查。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;浏览器不会提示内含的资源。因此，对于早期版本，只能为已经被浏览器“知道”的服务器下载内含的资源&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;除非提供了密钥库（并且您定义了属性&lt;code&gt;proxy.cert.alias&lt;/code&gt;），否则 JMeter需要使用keytool应用程序来创建密钥库条目。JMeter包含通过查看各种标准位置来检查keytool是否可用的代码。如果JMeter无法找到keytool应用程序，它将报告错误。如有必要，可以使用系统属性&lt;code&gt;keytool.directory&lt;/code&gt;告诉JMeter在哪里找到keytool。这应该在文件&lt;code&gt;system.properties&lt;/code&gt;中定义。&lt;/p&gt;
&lt;p&gt;按下 “&lt;code&gt;启动&lt;/code&gt;”按钮时会生成JMeter证书（如有必要）。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;证书生成可能需要一段时间，在此期间GUI将无响应。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;当这种情况发生时，光标变为沙漏。证书生成完成后，GUI将显示一个弹出对话框，其中包含根CA的证书详细信息。该证书需要由浏览器安装，以便它接受JMeter生成的主机证书；详见&lt;a href="http://jmeter.apache.org/usermanual/component_reference.html#install_cert"&gt;下文&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;如有必要，可以通过从JMeter目录中删除密钥库文件&lt;code&gt;proxyserver.jks&lt;/code&gt;来强制JMeter重新生成密钥库（以及导出的证书 - &lt;code&gt;ApacheJMeterTemporaryRootCA[.usr|.crt]&lt;/code&gt;）。&lt;/p&gt;
&lt;p&gt;此证书不是浏览器和正确的主机通常信任的证书之一。&lt;br&gt;
作为结果：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;浏览器应显示一个对话框，询问您是否要接受证书。例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    1）服务器名称“www.example.com”与证书名称不匹配
       “JMeter Proxy (DO NOT TRUST)”。有人可能会试图窃听你。
    2）“JMeter Proxy (DO NOT TRUST)”的证书由未知证书颁发机构签署
       “JMeter Proxy (DO NOT TRUST)”。无法验证这是否是有效证书。
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;您需要接受证书才能允许JMeter代理拦截SSL流量以进行录制。但是，请勿永久接受此证书；应该只是暂时接受。浏览器仅针对主URL的证书提示此对话，而不是针对页面中加载的资源，例如托管在安全的外部CDN上的图像，CSS或JavaScript文件。如果您有这样的资源（例如gmail），您必须首先手动浏览这些其他域，以便为他们接受JMeter的证书。在&lt;code&gt;jmeter.log&lt;/code&gt;中检查您需要注册证书的安全域。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果浏览器已经为此域注册了经过验证的证书，则浏览器会将JMeter检测为安全漏洞，并拒绝加载该页面。如果是这样，您必须从浏览器的密钥库中删除可信证书。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;从2.10开始的JMeter版本仍然支持此方法，如果您定义了以下属性，它将继续这样做：&lt;code&gt;proxy.cert.alias&lt;/code&gt;。以下属性可用于更改使用的证书：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;proxy.cert.directory&lt;/code&gt; - 查找证书的目录（默认= JMeter &lt;code&gt;bin/&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;proxy.cert.file&lt;/code&gt; - 密钥库文件的名称（默认为“&lt;code&gt;proxyserver.jks&lt;/code&gt;”）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;proxy.cert.keystorepass&lt;/code&gt; - 密钥库密码（默认为“&lt;code&gt;password&lt;/code&gt;”）[如果使用JMeter证书则忽略]&lt;/li&gt;
&lt;li&gt;&lt;code&gt;proxy.cert.keypassword&lt;/code&gt; - 证书密钥密码（默认为“&lt;code&gt;password&lt;/code&gt;”）[如果使用JMeter证书则忽略]&lt;/li&gt;
&lt;li&gt;&lt;code&gt;proxy.cert.type&lt;/code&gt; - 证书类型（默认为“&lt;code&gt;JKS&lt;/code&gt;”）[如果使用JMeter证书则忽略]&lt;/li&gt;
&lt;li&gt;&lt;code&gt;proxy.cert.factory&lt;/code&gt; - 工厂（默认为“&lt;code&gt;SunX509&lt;/code&gt;”）[如果使用JMeter证书则忽略]&lt;/li&gt;
&lt;li&gt;&lt;code&gt;proxy.cert.alias&lt;/code&gt; - 要使用的密钥的别名。如果已定义，则JMeter不会尝试生成自己的证书。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;proxy.ssl.protocol&lt;/code&gt; - 要使用的协议（默认为“&lt;code&gt;SSLv3&lt;/code&gt;”）&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;如果您的浏览器当前使用代理（例如公司内部网可以通过代理路由所有外部请求），那么您需要在启动JMeter之前使用&lt;a href="http://jmeter.apache.org/usermanual/get-started.html#options"&gt;命令行选项&lt;/a&gt;&lt;code&gt;-H&lt;/code&gt;和&lt;code&gt;-P&lt;/code&gt;&lt;a href="http://jmeter.apache.org/usermanual/get-started.html#proxy_server"&gt;告诉JMeter使用此代理&lt;/a&gt;。运行生成的测试计划时也需要此设置。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id="httpsjmeter-ca"&gt;安装用于HTTPS录制的JMeter CA证书&lt;/h4&gt;
&lt;p&gt;如上所述，在Java 8下运行时，JMeter可以为每个服务器生成证书。为了使其顺利运行，JMeter使用的根CA签名证书需要得到浏览器的信任。第一次启动录制器时，它将在必要时生成证书。根CA证书将导出到当前启动目录中名为&lt;code&gt;ApacheJMeterTemporaryRootCA&lt;/code&gt;的文件中。设置证书后，JMeter将显示一个包含当前证书详细信息的对话框。此时，可以按照以下说明将证书导入浏览器。&lt;/p&gt;
&lt;p&gt;请注意，一旦将根CA证书安装为可信CA，浏览器将信任由其签名的任何证书。在证书过期或证书从浏览器中删除之前，它不会警告用户证书正在被依赖。因此，任何能够获取密钥库和密码的人都可以使用证书生成这些将被任何信任JMeter根CA证书的浏览器接受的证书。因此，随机生成密钥库和私钥的密码，并使用短的有效期。密码存储在本地首选项区域中。请确保只有受信任的用户才能访问具有密钥库的主机。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;启动记录器后显示的弹窗是一个信息弹窗：&lt;/p&gt;
&lt;p&gt;&lt;img alt="Recorder Install Certificate Popup" src="http://jmeter.apache.org/images/screenshots/recorder_popup_info.png"&gt;
&lt;em&gt;记录器安装证书弹窗&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;只需单击“OK”然后继续。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id="firefox"&gt;在Firefox中安装证书&lt;/h5&gt;
&lt;p&gt;选择以下选项：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;工具/选项&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;高级/证书&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;查看证书&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;证书颁发机构&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;导入...&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;浏览到JMeter启动目录，然后单击&lt;code&gt;ApacheJMeterTemporaryRootCA.crt&lt;/code&gt;文件，点击&lt;code&gt;打开&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;单击“&lt;code&gt;查看&lt;/code&gt;”并检查证书详细信息是否与JMeter测试脚本记录器显示的一致&lt;/li&gt;
&lt;li&gt;如果正常，请选择“&lt;code&gt;信任此CA以识别网站&lt;/code&gt;”，然后点击&lt;code&gt;确定&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;根据需要点击“&lt;code&gt;确定&lt;/code&gt;”关闭对话框&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id="chromeinternet-explorer"&gt;在Chrome或Internet Explorer中安装证书&lt;/h5&gt;
&lt;p&gt;Chrome和Internet Explorer都使用相同的信任存储区来存储证书。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;浏览到JMeter启动目录，然后单击&lt;code&gt;ApacheJMeterTemporaryRootCA.crt&lt;/code&gt;文件，并将其打开&lt;/li&gt;
&lt;li&gt;单击“&lt;code&gt;详细信息&lt;/code&gt;”选项卡，检查证书详细信息是否与JMeter测试脚本记录器显示的一致&lt;/li&gt;
&lt;li&gt;如果确定，请返回“&lt;code&gt;常规&lt;/code&gt;”选项卡，然后单击“&lt;code&gt;安装证书...&lt;/code&gt;”并按照向导提示进行操作&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id="opera"&gt;在Opera中安装证书&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;工具/偏好/高级/安全&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;管理证书...&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;选择“&lt;code&gt;中级&lt;/code&gt;”选项卡，然后单击“&lt;code&gt;导入...&lt;/code&gt;”&lt;/li&gt;
&lt;li&gt;浏览到JMeter启动目录，然后单击&lt;code&gt;ApacheJMeterTemporaryRootCA.usr&lt;/code&gt;文件，并将其打开&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="Screenshot for Control-Panel of HTTP(S) Test Script Recorder" src="http://jmeter.apache.org/images/screenshots/proxy_control.png"&gt;&lt;br&gt;
&lt;em&gt;HTTP(S)测试脚本录制器控制面板的截图&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参数&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th align="left"&gt;是否必须&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;名称&lt;/td&gt;
&lt;td&gt;树中显示的此元件的描述性名称。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;端口&lt;/td&gt;
&lt;td&gt;HTTP(S)测试脚本记录器监听的端口。 默认值&lt;code&gt;8888&lt;/code&gt;，可变更。&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;HTTPS Domains&lt;/td&gt;
&lt;td&gt;HTTPS的域（或主机）名称列表。使用此选项可为要记录的所有服务器预生成证书。 &lt;br/&gt;例如，&lt;code&gt;*.example.com,*.subdomain.example.com&lt;/code&gt;&lt;br/&gt;注意通配符域仅适用于一级，即&lt;code&gt;abc.subdomain.example.com&lt;/code&gt;匹配&lt;code&gt;*.subdomain.example.com&lt;/code&gt;但不匹配&lt;code&gt;*.example.com&lt;/code&gt;&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;目标控制器&lt;/td&gt;
&lt;td&gt;控制代理存储生成样本的控制器。默认情况下，它会查找录制控制器并将其存储在控制器之下。&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;分组&lt;/td&gt;
&lt;td&gt;是否将样本分组为来自单个“点击”的请求（收到的请求没有明显的时间间隔），以及如何在记录中表示该分组：&lt;ul&gt;&lt;li&gt;&lt;code&gt;不对样本分组&lt;/code&gt; - 按顺序存储所有记录的样本，不进行任何分组。&lt;/li&gt;&lt;li&gt;&lt;code&gt;在组间添加分隔&lt;/code&gt; - 添加名为“&lt;code&gt;--------------&lt;/code&gt;” 的控制器以在组之间创建视觉分隔。否则，样本全部按顺序存储。&lt;/li&gt;&lt;li&gt;&lt;code&gt;每个组放入一个新的控制器&lt;/code&gt; - 为每个组创建一个新的&lt;a href="http://jmeter.apache.org/usermanual/component_reference.html#Simple_Controller"&gt;简单控制器&lt;/a&gt;，并将该组的所有样本存储在其中。&lt;/li&gt;&lt;li&gt;&lt;code&gt;只存储每个组的第一个样本&lt;/code&gt; - 仅记录每组中的第一个请��。将对这些样本打开“&lt;code&gt;自动重定向&lt;/code&gt;”和“&lt;code&gt;从HTML文件获取所有内含的资源&lt;/code&gt;”标志。&lt;/li&gt;&lt;li&gt;&lt;code&gt;将每个组放入一个新的事务控制器中&lt;/code&gt; - 为每个组创建一个新的&lt;a href="http://jmeter.apache.org/usermanual/component_reference.html#Transaction_Controller"&gt;事务控制器&lt;/a&gt;，并将该组的所有样本存储在其中。&lt;/li&gt;&lt;/ul&gt;JMeter将这些请求视为单独的“点击”请求之间的最小差距由属性&lt;code&gt;proxy.pause&lt;/code&gt;决定。默认值为&lt;code&gt;5000&lt;/code&gt;（毫秒），即5秒。如果您在使用分组，请确保在点击之间留出所需的间隔。&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;记录HTTP信息头&lt;/td&gt;
&lt;td&gt;是否应将信息头添加到计划中？如果指定，则会将信息头管理器添加到每个HTTP取样器。代理服务器始终从生成的信息头管理器中删除Cookie和授权信息头。默认情况下，它还会删除&lt;code&gt;If-Modified-Since&lt;/code&gt;和&lt;code&gt;If-None-Match&lt;/code&gt;信息头。这些用于决定浏览器缓存项是否是最新的；录制时通常要下载所有内容。要更改删除的额外信息头，请将JMeter属性&lt;code&gt;proxy.headers.remove&lt;/code&gt;定义为以逗号分隔的信息头列表。&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;添加断言&lt;/td&gt;
&lt;td&gt;为每个取样器添加一个空白断言？&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Regex Matching&lt;/td&gt;
&lt;td&gt;使用正则表达式匹配替换变量？如果选中替换将使用单词边界，即它将仅替换变量的单词匹配值，而不是单词的一部分。字边界遵循Perl5定义，等同于&lt;code&gt;\b&lt;/code&gt;。有关“&lt;code&gt;用户定义的变量替换&lt;/code&gt;” 的更多信息请参阅下面段落。&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Prefix/Transaction name&lt;/td&gt;
&lt;td&gt;在录制期间为样本名称添加前缀（前缀模式）。或者用用户选择的名称替换样本名称（事务名称）&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Create new transaction after request (ms)&lt;/td&gt;
&lt;td&gt;考虑将两个请求分到不同组的请求间的不活动时间。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Type&lt;/td&gt;
&lt;td&gt;要生成的样本的类型（默认HTTPClient或Java）&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;自动重定向&lt;/td&gt;
&lt;td&gt;在生成的样本中设置自动重定向？&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;跟随重定向&lt;/td&gt;
&lt;td&gt;在生成的样本中设置跟随重定向？&lt;blockquote&gt;注意：有关重要信息，请参阅下面的“录制和重定向”部分。&lt;/blockquote&gt;&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;使用Keep-Alive&lt;/td&gt;
&lt;td&gt;在生成的取样器中设置使用Keep-Alive？&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;从HTML文件获取所有内含的资源&lt;/td&gt;
&lt;td&gt;设置从HTML文件获取所有内含的资源？&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Content Type filter&lt;/td&gt;
&lt;td&gt;根据&lt;code&gt;content-type&lt;/code&gt;过滤请求- 例如“&lt;code&gt;text/html [;charset=utf-8 ]&lt;/code&gt;”。这些字段是正则表达式，检查它们是否包含在&lt;code&gt;content-type&lt;/code&gt;中。[不必匹配整个字段]。首先检查包含过滤，然后检查排除过滤。过滤掉的样本将不会被存储。&lt;blockquote&gt;注意：此过滤适用于响应的内容类型&lt;/blockquote&gt;&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;包含模式&lt;/td&gt;
&lt;td&gt;与取样的完整URL匹配的正则表达式。允许过滤记录的请求。所有请求都会通过，但只会&lt;em&gt;记录&lt;/em&gt;符合“&lt;code&gt;Include&lt;/code&gt;/&lt;code&gt;Exclude&lt;/code&gt;”字段要求的请求。如果&lt;code&gt;Include&lt;/code&gt;和&lt;code&gt;Exclude&lt;/code&gt;”都为空，则记录所有内容（这将导致为每个页面记录数十个样本，因为记录了图像，样式表等）。&lt;blockquote&gt;如果“&lt;code&gt;Include&lt;/code&gt;”字段中至少有一个条目，则仅记录与一个或多个“&lt;code&gt;Include&lt;/code&gt;”模式匹配的请求&lt;/blockquote&gt;&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;排除模式&lt;/td&gt;
&lt;td&gt;与取样的URL匹配的正则表达式。&lt;blockquote&gt;&lt;em&gt;不&lt;/em&gt;记录与一个或多个&lt;code&gt;Exclude&lt;/code&gt;模式匹配的任何请求&lt;/blockquote&gt;&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;将过滤过的取样器通知子监听器&lt;/td&gt;
&lt;td&gt;将过滤过的取样器通知子监听器&lt;blockquote&gt;任何与一个或多个&lt;code&gt;Exclude&lt;/code&gt;模式匹配的响应都&lt;em&gt;不会&lt;/em&gt;传递给子监听器（查看结果树）&lt;/blockquote&gt;&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;启动按钮&lt;/td&gt;
&lt;td&gt;启动代理服务器。一旦代理服务器启动并准备接收请求，JMeter就会将以下消息写入控制台：“&lt;code&gt;Proxy up and running!&lt;/code&gt;”。&lt;/td&gt;
&lt;td align="left"&gt;N/A&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;停止按钮&lt;/td&gt;
&lt;td&gt;停止代理服务器。&lt;/td&gt;
&lt;td align="left"&gt;N/A&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;重启按钮&lt;/td&gt;
&lt;td&gt;停止并重新启动代理服务器。当您更改/添加/删除包含/排除过滤表达式时，这非常有用。&lt;/td&gt;
&lt;td align="left"&gt;N/A&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4 id="_77"&gt;录制和重定向&lt;/h4&gt;
&lt;p&gt;在录制过程中，浏览器将遵循重定向响应并生成额外的请求。代理将记录原始请求和重定向请求（取决于配置的任何排除）。生成的样本默认选择“&lt;code&gt;跟随重定向&lt;/code&gt;”，因为这通常更好。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;重定向可能取决于原始请求，因此重复原始记录的样本可能并不总是有效。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;现在，如果JMeter设置为在重放期间跟随重定向，它将发出原始请求，然后重播已记录的重定向请求。为了避免这种重复重放，JMeter尝试检测样本是否是之前重定向的结果。如果当前响应是重定向，JMeter将保存重定向URL。收到下一个请求时，会将其与保存的重定向URL进行比较，如果匹配，JMeter将禁用生成的样本。它还为重定向链添加了注释。这假设重定向链中的所有请求将在没有任何干预请求的情况下相互跟随。要禁用重定向检测，请设置属性&lt;code&gt;proxy.redirect.disabling=false&lt;/code&gt;&lt;/p&gt;
&lt;h4 id="_78"&gt;包含和排除&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;包含和排除模式&lt;/strong&gt;被视为正则表达式（使用Jakarta ORO）。它们将与每个浏览器请求的主机名，端口（实际或隐含），路径和查询（如果有）进行匹配。如果您正在浏览的URL是“&lt;code&gt;http://localhost/jmeter/index.html?username=xxxx&lt;/code&gt;”，那么针对此字符串测试正则表达式：“&lt;code&gt;localhost:80/jmeter/index.html?username=xxxx&lt;/code&gt;”。因此，如果要包含所有&lt;code&gt;.html&lt;/code&gt;文件，如果你知道没有查询字符串或者你只想要不带查询字符串的html页面，正则表达式可以如下所示："&lt;code&gt;.*\.html(\?.*)?&lt;/code&gt;"或者"&lt;code&gt;.*\.html&lt;/code&gt;"。&lt;/p&gt;
&lt;p&gt;如果存在任何包含模式，则URL&lt;strong&gt;必须至少与其中一个&lt;/strong&gt;模式&lt;strong&gt;匹配&lt;/strong&gt;，否则将不会记录。如果存在任何排除模式，则URL&lt;strong&gt;必须与任何&lt;/strong&gt;模式&lt;strong&gt;都不匹配&lt;/strong&gt;，否则将不会记录。使用包含和排除的组合，您应该能够记录您感兴趣的内容并跳过您不感兴趣的内容。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注意，正则表达式匹配的字符串必须与&lt;strong&gt;整个&lt;/strong&gt;主机+路径字符串相同。
因此“&lt;code&gt;\.html&lt;/code&gt;” 与&lt;code&gt;localhost:80/index.html&lt;/code&gt;&lt;strong&gt;不&lt;/strong&gt;匹配&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id="post"&gt;捕获二进制POST数据&lt;/h4&gt;
&lt;p&gt;JMeter能够捕获二进制POST数据。要配置将哪些&lt;code&gt;content-types&lt;/code&gt;视为二进制，请更新JMeter属性&lt;code&gt;proxy.binary.types&lt;/code&gt;。默认设置如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;＃这些content-types将通过将请求保存在文件中来处理：
proxy.binary.types=application/x-amf,application/x-java-serialized-object
＃文件将保存在此目录中：
proxy.binary.directory=user.dir
＃将使用此文件filesuffix创建文件：
proxy.binary.filesuffix=.binary
&lt;/pre&gt;&lt;/div&gt;


&lt;h4 id="_79"&gt;添加定时器&lt;/h4&gt;
&lt;p&gt;也可以让代理向记录的脚本添加定时器。为此，请直接在HTTP(S)测试脚本记录器组件中创建定时器。代理会将此定时器的副本放入其记录的每个样本中，如果您正在使用分组，则将其放入每个组的第一个样本中。然后将扫描该副本以查找其属性中变量&lt;code&gt;${T}&lt;/code&gt;的出现，并且任何此类出现将被前一个样本记录的的时间间隔（以毫秒为单位）替换。&lt;/p&gt;
&lt;p&gt;当您准备开始时，点击“&lt;code&gt;启动&lt;/code&gt;”。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;您需要编辑浏览器的代理设置以指向相应的服务器和端口，其中服务器是运行JMeter的机器，端口＃来自上面显示的代理控制面板。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id="_80"&gt;样本在何处被记录？&lt;/h4&gt;
&lt;p&gt;JMeter将记录的样本放入您选择的目标控制器中。如果选择默认选项“&lt;code&gt;使用录制控制器&lt;/code&gt;”，它们将存储在测试对象树中找到的第一个录制控制器中（因此请务必在开始录制之前添加录制控制器）。&lt;/p&gt;
&lt;p&gt;如果代理似乎没有记录任何样本，这可能是因为浏览器实际上没有使用代理。要检查是否是这种情况，请尝试停止代理。如果浏览器仍然可以下载页面，则它没有通过代理发送请求。请再次检查浏览器选项。如果您尝试从运行在同一主机上的服务器进行录制，请检查浏览器是否没有设置为“&lt;code&gt;对于本地地址不使用代理服务器&lt;/code&gt;”（此示例来自IE7，但其他浏览器也有类似的选项）。如果JMeter不记录浏览器URL，例如&lt;code&gt;http://localhost/&lt;/code&gt;或&lt;code&gt;http://127.0.0.1/&lt;/code&gt;，请尝试使用非环回主机名或IP地址，例如&lt;code&gt;http://myhost/&lt;/code&gt;或&lt;code&gt;http://192.168.0.2/&lt;/code&gt;。&lt;/p&gt;
&lt;h4 id="http_4"&gt;处理HTTP请求默认值&lt;/h4&gt;
&lt;p&gt;如果HTTP(S)测试脚本记录器直接在存储样本的控制器内或任何其父控制器内找到启用的&lt;a href="http://jmeter.apache.org/usermanual/component_reference.html#HTTP_Request_Defaults"&gt;HTTP请求默认值&lt;/a&gt;，则记录的样本将对于您指定的默认值使用空字段。您可以通过在HTTP(S)测试脚本记录器中直接放置HTTP请求默认值元件来进一步控制此行为，其非空值将覆盖其他HTTP请求默认值中的值。有关详细信息，请参阅&lt;a href="http://jmeter.apache.org/usermanual/best-practices.html#proxy_server"&gt;HTTP(S)测试脚本记录器的最佳实践&lt;/a&gt;。&lt;/p&gt;
&lt;h4 id="_81"&gt;用户定义的变量替换&lt;/h4&gt;
&lt;p&gt;类似地，如果HTTP(S)测试脚本记录器直接在存储样本的控制器内或任何其父控制器内找到&lt;a href="http://jmeter.apache.org/usermanual/component_reference.html#User_Defined_Variables"&gt;用户定义的变量&lt;/a&gt;（UDV），则记录的样本将把任何这些变量值的出现由相应的变量替换。同样，您可以将用户定义变量直接放在HTTP(S)测试脚本记录器中，以覆盖要替换的值。有关详细信息，请参阅 &lt;a href="http://jmeter.apache.org/usermanual/best-practices.html#proxy_server"&gt;测试脚本记录器的最佳实践&lt;/a&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;请注意，匹配区分大小写。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;按变量替换：默认情况下，代理服务器会查找所有出现的用户定义的变量值。例如，如果您使用值&lt;code&gt;www&lt;/code&gt;定义变量&lt;code&gt;WEB&lt;/code&gt;，则无论在何处找到，字符串&lt;code&gt;www&lt;/code&gt;都将被&lt;code&gt;${WEB}&lt;/code&gt;替换。为避免在任何地方发生这种情况，请选中“&lt;code&gt;Regex Matching&lt;/code&gt;”复选框。这告诉代理服务器将值视为正则表达式（使用ORO提供的perl5兼容的正则表达式匹配器）。&lt;/p&gt;
&lt;p&gt;如果选中“&lt;code&gt;Regex Matching&lt;/code&gt;”，则每个变量将被编译为包含在&lt;code&gt;\b(&lt;/code&gt;和&lt;code&gt;)\b&lt;/code&gt;中的perl兼容正则表达式 。这样每个匹配将以字边界开始和结束。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;需要注意的是边界字符不是匹配组的一部分，例如&lt;code&gt;n.*&lt;/code&gt;匹配&lt;code&gt;You can call me 'name'&lt;/code&gt;中的&lt;code&gt;name&lt;/code&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果你不希望你的正则表达式被限制在那些边界匹配器中，你必须将你的正则表达式包含在括号中，例如&lt;code&gt;('.*?')&lt;/code&gt;匹配&lt;code&gt;You can call me 'name'&lt;/code&gt;中的&lt;code&gt;'name'&lt;/code&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;将以随机顺序检查变量。因此，请确保潜在匹配不重叠。重叠匹配器可以是&lt;code&gt;.*&lt;/code&gt;（匹配任何东西）和&lt;code&gt;www&lt;/code&gt;（仅匹配&lt;code&gt;www&lt;/code&gt;）。非重叠-匹配器可以是&lt;code&gt;a+&lt;/code&gt;（匹配&lt;code&gt;a&lt;/code&gt;开头的一个序列）和&lt;code&gt;b+&lt;/code&gt;（匹配&lt;code&gt;b&lt;/code&gt;开头的一个序列）。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果您只想匹配整个字符串，请将其括在&lt;code&gt;(^&lt;/code&gt;和&lt;code&gt;$)&lt;/code&gt;中，例如&lt;code&gt;(^thus$)&lt;/code&gt;。括号是必要的，因为通常添加的边界字符将阻止&lt;code&gt;^&lt;/code&gt;和&lt;code&gt;$&lt;/code&gt;匹配。&lt;/p&gt;
&lt;p&gt;如果只想在字符串的开头匹配&lt;code&gt;/images&lt;/code&gt;，请使用值&lt;code&gt;(^/images)&lt;/code&gt;。Jakarta ORO也支持零宽度正预测，因此可以使用&lt;code&gt;(^/images(?=/))&lt;/code&gt;匹配&lt;code&gt;/images/…&lt;/code&gt;但是不包含尾部的&lt;code&gt;/&lt;/code&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注意当前版本的Jakarta ORO不支持正回顾 - 即&lt;code&gt;(?&amp;lt;=…)&lt;/code&gt;或&lt;code&gt;(?&amp;lt;!…)&lt;/code&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;留意重叠的匹配器。例如，作为变量名为&lt;code&gt;regex&lt;/code&gt;的正则表达式的值&lt;code&gt;.*&lt;/code&gt;将部分匹配先前替换的变量，这将导致类似&lt;code&gt;${{regex}&lt;/code&gt;的内容，这很可能不是所需的结果。&lt;/p&gt;
&lt;p&gt;如果将任何变量解释为模式存在任何问题，则会在&lt;code&gt;jmeter.log&lt;/code&gt;中报告这些问题，因此如果用户定义的变量未按预期工作，请务必检查此问题。&lt;/p&gt;
&lt;p&gt;完成录制测试样本后，停止代理服务器（点击“&lt;code&gt;停止&lt;/code&gt;”按钮）。请记住重置浏览器的代理设置。现在，您可能希望对测试脚本进行排序和重新排序，添加定时器，监听器，cookie管理器等。&lt;/p&gt;
&lt;h4 id="_82"&gt;我怎样才能同时记录服务器的响应？&lt;/h4&gt;
&lt;p&gt;只需将&lt;a href="http://jmeter.apache.org/usermanual/component_reference.html#View_Results_Tree"&gt;查看结果树&lt;/a&gt;监听器作为HTTP(S)测试脚本记录器的子项放置，就会显示响应。您还可以添加&lt;a href="http://jmeter.apache.org/usermanual/component_reference.html#Save_Responses_to_a_file"&gt;保存响应到文件&lt;/a&gt;后置处理器来将响应保存到文件。&lt;/p&gt;
&lt;h4 id="_83"&gt;将请求与响应相关联&lt;/h4&gt;
&lt;p&gt;如果定义属性&lt;code&gt;proxy.number.requests=true&lt;/code&gt;， JMeter将为每个取样器和每个响应添加一个数字。注意如果使用了排除或包含，可能会有比取样器更多的响应。已被排除的响应将被包含在&lt;code&gt;[&lt;/code&gt;和&lt;code&gt;]&lt;/code&gt;标签中，例如&lt;code&gt;[23 /favicon.ico]&lt;/code&gt;。&lt;/p&gt;
&lt;h4 id="cookie"&gt;Cookie管理器&lt;/h4&gt;
&lt;p&gt;如果您要测试的服务器使用cookie，请记住在完成记录后将&lt;a href="http://jmeter.apache.org/usermanual/component_reference.html#HTTP_Cookie_Manager"&gt;HTTP Cookie管理器&lt;/a&gt;添加到测试计划中。在录制期间，浏览器会处理任何cookie，但JMeter需要Cookie管理器在测试运行期间处理cookie。JMeter代理服务器在记录期间传递浏览器发送的所有cookie，但不会将它们保存到测试计划中，因为它们每次运行时通常会变化。&lt;/p&gt;
&lt;h4 id="_84"&gt;授权管理器&lt;/h4&gt;
&lt;p&gt;HTTP(S)测试脚本记录器抓取“&lt;code&gt;Authentication&lt;/code&gt;”信息头，尝试计算身份验证策略。如果授权管理器手动添加到目标控制器，HTTP(S)测试脚本记录器将找到它并添加授权（匹配的将被删除）。否则，授权管理器将添加到具有授权对象的目标控制器。您可能必须在录制后修改自动计算的值。&lt;/p&gt;
&lt;h4 id="_85"&gt;上传文件&lt;/h4&gt;
&lt;p&gt;某些浏览器（例如Firefox和Opera）在上传文件时不包含文件的全名。这可能导致JMeter代理服务器失败。一种解决方案是确保要上传的任何文件都在JMeter工作目录中，可以将文件复制到工作目录或在包含文件的目录中启动JMeter。&lt;/p&gt;
&lt;h4 id="jmeterhttp"&gt;记录JMeter中原生不支持的基于HTTP的非文本协议&lt;/h4&gt;
&lt;p&gt;您可能要记录JMeter默认不处理的HTTP协议（自定义二进制协议，Adobe Flex，Microsoft Silverlight，...）。虽然JMeter不提供记录这些协议的原生代理实现，但您可以通过实现自定义&lt;code&gt;SamplerCreator&lt;/code&gt;来记录这些协议。此取样器生成器可以将二进制格式转换为可添加到JMeter测试用例的&lt;code&gt;HTTPSamplerBase&lt;/code&gt;子类。有关更多详细信息，请参阅“扩展JMeter”。&lt;/p&gt;
&lt;p&gt;&lt;a href="#toc"&gt;【返回目录】&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="http_5"&gt;HTTP镜像服务器&lt;/h3&gt;
&lt;p&gt;HTTP镜像服务器是一个非常简单的HTTP服务器 - 它只是镜像发送给它的数据。这对于检查HTTP请求的内容很有用。&lt;/p&gt;
&lt;p&gt;它使用默认端口为&lt;code&gt;8081&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img alt="Screenshot for Control-Panel of HTTP Mirror Server" src="http://jmeter.apache.org/images/screenshots/mirrorserver.png"&gt;&lt;br&gt;
&lt;em&gt;HTTP镜像服务器控制面板的截图&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参数&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th align="left"&gt;是否必须&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;名称&lt;/td&gt;
&lt;td&gt;树中显示的此元件的描述性名称。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;端口&lt;/td&gt;
&lt;td&gt;镜像服务器监听的端口，默认为&lt;code&gt;8081&lt;/code&gt;。&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;最大线程数&lt;/td&gt;
&lt;td&gt;如果设置为值&amp;gt;&lt;code&gt;0&lt;/code&gt;，服务请求的线程的数目将被限制在配置数的范围内，如果设置为值≤&lt;code&gt;0&lt;/code&gt;一个新的线程将被创建以服务于每个传入请求。默认值为&lt;code&gt;0&lt;/code&gt;&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;最大队列长度&lt;/td&gt;
&lt;td&gt;用于在线程池执行任务之前保留任务的队列大小，当超出线程池时，传入的请求将保留在此队列中，并在此队列满时被丢弃。仅当最大线程数大于&lt;code&gt;0&lt;/code&gt;时才使用此参数。默认为&lt;code&gt;25&lt;/code&gt;&lt;/blockquote&gt;&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;blockquote&gt;
&lt;p&gt;注意通过添加具有以下名称/值对的HTTP信息头管理器，您可以更好地控制响应：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;参数&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th align="left"&gt;是否必须&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;X-Sleep&lt;/td&gt;
&lt;td&gt;在发送响应之前以ms为单位休眠的时间&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;X-SetCookie&lt;/td&gt;
&lt;td&gt;响应时设置Cookie&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;X-ResponseStatus&lt;/td&gt;
&lt;td&gt;响应状态，请参阅&lt;a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html"&gt;HTTP响应状态&lt;/a&gt;，例如200 OK，500内部服务器错误，....&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;X-ResponseLength&lt;/td&gt;
&lt;td&gt;响应大小，如果小于总大小，则会将响应调整为所请求的大小&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;X-SetHeaders&lt;/td&gt;
&lt;td&gt;&lt;code&gt;|&lt;/code&gt;分隔的信息头列表，例如：&lt;code&gt;headerA=valueA|headerB=valueB&lt;/code&gt;将&lt;code&gt;headerA&lt;/code&gt;设置为&lt;code&gt;valueA&lt;/code&gt;，&lt;code&gt;headerB&lt;/code&gt;设置为&lt;code&gt;valueB&lt;/code&gt;。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;您还可以使用以下查询参数：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参数&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th align="left"&gt;是否必须&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;redirect&lt;/td&gt;
&lt;td&gt;使用提供的位置生成302（临时重定向）。例如&lt;code&gt;?redirect=/path&lt;/code&gt;&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;status&lt;/td&gt;
&lt;td&gt;覆盖默认返回状态。例如&lt;code&gt;?status=404 Not Found&lt;/code&gt;&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;v&lt;/td&gt;
&lt;td&gt;详细标志，将一些细节写入标准输出。例如，指定第一行和重定向位置&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;a href="#toc"&gt;【返回目录】&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="_86"&gt;属性显示&lt;/h3&gt;
&lt;p&gt;属性显示显示系统或JMeter属性的值。可以通过在“值”列中输入新文本来更改值。&lt;/p&gt;
&lt;p&gt;&lt;img alt="Screenshot for Control-Panel of Property Display" src="http://jmeter.apache.org/images/screenshots/property_display.png"&gt;&lt;br&gt;
&lt;em&gt;属性显示控制面板的截图&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参数&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th align="left"&gt;是否必须&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;名称&lt;/td&gt;
&lt;td&gt;树中显示的此元件的描述性名称。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;a href="#toc"&gt;【返回目录】&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="_87"&gt;调试取样器&lt;/h3&gt;
&lt;p&gt;调试取样器生成一个包含所有JMeter变量和/或属性值的样本。&lt;/p&gt;
&lt;p&gt;可以在&lt;a href="http://jmeter.apache.org/usermanual/component_reference.html#View_Results_Tree"&gt;查看结果树&lt;/a&gt;监听器响应数据窗格中查看这些值。&lt;/p&gt;
&lt;p&gt;&lt;img alt="Screenshot for Control-Panel of Debug Sampler" src="http://jmeter.apache.org/images/screenshots/debug_sampler.png"&gt;&lt;br&gt;
&lt;em&gt;调试取样器控制面板的截图&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参数&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th align="left"&gt;是否必须&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;名称&lt;/td&gt;
&lt;td&gt;树中显示的此元件的描述性名称。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;JMeter属性&lt;/td&gt;
&lt;td&gt;包括JMeter属性？&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;JMeter变量&lt;/td&gt;
&lt;td&gt;包括JMeter变量？&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;系统属性&lt;/td&gt;
&lt;td&gt;包括系统属性？&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;a href="#toc"&gt;【返回目录】&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="_88"&gt;调试后置处理程序&lt;/h3&gt;
&lt;p&gt;调试后置处理程序创建一个子样本，其中包含之前取样器属性，JMeter变量，属性和/或系统属性的详细信息。&lt;/p&gt;
&lt;p&gt;可以在&lt;a href="http://jmeter.apache.org/usermanual/component_reference.html#View_Results_Tree"&gt;查看结果树&lt;/a&gt;监听器响应数据窗格中查看这些值。&lt;/p&gt;
&lt;p&gt;&lt;img alt="Screenshot for Control-Panel of Debug PostProcessor" src="http://jmeter.apache.org/images/screenshots/debug_postprocessor.png"&gt;&lt;br&gt;
&lt;em&gt;调试后置处理程序控制面板的截图&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参数&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th align="left"&gt;是否必须&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;名称&lt;/td&gt;
&lt;td&gt;树中显示的此元件的描述性名称。&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;JMeter属性&lt;/td&gt;
&lt;td&gt;是否显示JMeter属性（默认为&lt;code&gt;false&lt;/code&gt;）。&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;JMeter变量&lt;/td&gt;
&lt;td&gt;是否显示JMeter变量（默认为&lt;code&gt;false&lt;/code&gt;）。&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;取样器属性&lt;/td&gt;
&lt;td&gt;是否显示Sampler属性（默认为&lt;code&gt;true&lt;/code&gt;）。&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;系统属性&lt;/td&gt;
&lt;td&gt;是否显示系统属性（默认为&lt;code&gt;false&lt;/code&gt;）。&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;a href="#toc"&gt;【返回目录】&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="_89"&gt;测试片段&lt;/h3&gt;
&lt;p&gt;测试片段与&lt;a href="http://jmeter.apache.org/usermanual/component_reference.html#Include_Controller"&gt;Include控制器&lt;/a&gt;和&lt;a href="http://jmeter.apache.org/usermanual/component_reference.html#Module_Controller"&gt;模块控制器&lt;/a&gt;一起使用。&lt;/p&gt;
&lt;p&gt;&lt;img alt="Screenshot for Control-Panel of Test Fragment" src="http://jmeter.apache.org/images/screenshots/test_fragment.png"&gt;&lt;br&gt;
&lt;em&gt;测试片段控制面板的截图&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参数&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th align="left"&gt;是否必须&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;名称&lt;/td&gt;
&lt;td&gt;树中显示的此元件的描述性名称。&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;blockquote&gt;
&lt;p&gt;将测试片段与&lt;a href="http://jmeter.apache.org/usermanual/component_reference.html#Module_Controller"&gt;模块控制器&lt;/a&gt;一起使用时，请确保禁用测试片段以防止执行测试片段本身。JMeter 2.13之后默认禁用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href="#toc"&gt;【返回目录】&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="setup"&gt;setUp线程组&lt;/h3&gt;
&lt;p&gt;一种特殊类型的线程组，可用于执行测试预操作。这些线程的行为与普通的&lt;a href="http://jmeter.apache.org/usermanual/component_reference.html#Thread_Group"&gt;线程组&lt;/a&gt;元件完全相同。不同之处在于这些类型的线程在测试过程中在常规线程组执行之前执行。&lt;/p&gt;
&lt;p&gt;&lt;img alt="Screenshot for Control-Panel of setUp Thread Group" src="http://jmeter.apache.org/images/screenshots/setup_thread_group.png"&gt;&lt;br&gt;
&lt;em&gt;setUp线程组控制面板的截图&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="#toc"&gt;【返回目录】&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="teardown"&gt;tearDown线程组&lt;/h3&gt;
&lt;p&gt;一种特殊类型的线程组，可用于执行测试后操作。这些线程的行为与普通的&lt;a href="http://jmeter.apache.org/usermanual/component_reference.html#Thread_Group"&gt;线程组&lt;/a&gt;元件完全相同。不同之处在于这些类型的线程在测试过程中在常规线程组执行后执行。&lt;/p&gt;
&lt;p&gt;&lt;img alt="Screenshot for Control-Panel of tearDown Thread Group" src="http://jmeter.apache.org/images/screenshots/teardown_thread_group.png"&gt;&lt;br&gt;
&lt;em&gt;tearDown线程组控制面板的截图&lt;/em&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注意默认情况下，测试正常结束时它是不会运行，如果要在此情况下运行它，请确保在测试计划元件上选中“&lt;code&gt;主线程结束后运行tearDown线程组&lt;/code&gt;”选项。如果测试计划被停止，即使选中选项，tearDown也不会运行。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img alt="Figure 1 - Run tearDown Thread Groups after shutdown of main threads" src="http://jmeter.apache.org/images/screenshots/tear_down_on_shutdown.png"&gt;&lt;br&gt;
&lt;em&gt;图1 - 主线程结束后运行tearDown线程组&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="#toc"&gt;【返回目录】&lt;/a&gt;&lt;/p&gt;</content><category term="JMeter"></category><category term="Documentation"></category><category term="Translation"></category></entry><entry><title>JMeter文档翻译之20-函数和变量</title><link href="https://jlhxxxx.github.io/jmeter-doc-cn-20.html" rel="alternate"></link><published>2019-05-07T00:00:00+08:00</published><updated>2019-05-07T00:00:00+08:00</updated><author><name>Aman</name></author><id>tag:jlhxxxx.github.io,2019-05-07:/jmeter-doc-cn-20.html</id><summary type="html">&lt;p&gt;英文文档地址：&lt;a href="http://jmeter.apache.org/usermanual/functions.html"&gt;http://jmeter.apache.org/usermanual/functions.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;JMeter 的函数是一些特殊值，它们可以填充在测试树的任何采样器或其他元件中。函数调用的语法如下：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;${__functionName(var1,var2,var3)}&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;其中“__functionName”匹配函数的名称。
圆括号内为函数参数，不同函数的参数也不同，例如 &lt;code&gt;${__time(YMD)}&lt;/code&gt;。没有参数的函数可以不需要圆括号，例如 &lt;code&gt;${__threadNum}&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;如果函数的参数包含逗号，需要加上“&lt;code&gt;\&lt;/code&gt;”来转义，否则 JMeter 会把逗号当做参数的分隔符。例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;__time&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;EEE&lt;/span&gt;\&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;d&lt;/span&gt; &lt;span class="n"&gt;MMM&lt;/span&gt; &lt;span class="n"&gt;yyyy&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;如果逗号没有被转义——例如 &lt;code&gt;${__javaScript(Math.max(2,5))}&lt;/code&gt; ——你会得到像这样的错误信息：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;ERROR - jmeter.functions …&lt;/pre&gt;&lt;/div&gt;</summary><content type="html">&lt;p&gt;英文文档地址：&lt;a href="http://jmeter.apache.org/usermanual/functions.html"&gt;http://jmeter.apache.org/usermanual/functions.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;JMeter 的函数是一些特殊值，它们可以填充在测试树的任何采样器或其他元件中。函数调用的语法如下：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;${__functionName(var1,var2,var3)}&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;其中“__functionName”匹配函数的名称。
圆括号内为函数参数，不同函数的参数也不同，例如 &lt;code&gt;${__time(YMD)}&lt;/code&gt;。没有参数的函数可以不需要圆括号，例如 &lt;code&gt;${__threadNum}&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;如果函数的参数包含逗号，需要加上“&lt;code&gt;\&lt;/code&gt;”来转义，否则 JMeter 会把逗号当做参数的分隔符。例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;__time&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;EEE&lt;/span&gt;\&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;d&lt;/span&gt; &lt;span class="n"&gt;MMM&lt;/span&gt; &lt;span class="n"&gt;yyyy&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;如果逗号没有被转义——例如 &lt;code&gt;${__javaScript(Math.max(2,5))}&lt;/code&gt; ——你会得到像这样的错误信息：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;ERROR - jmeter.functions.JavaScript: Error processing Javascript: [Math.max(2] org.mozilla.javascript.EvaluatorException: missing ) after argument list (&amp;lt;cmd&amp;gt;#1)
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这是因为字符串“&lt;code&gt;Math.max(2,5)&lt;/code&gt;”被当做&lt;code&gt;__javascript&lt;/code&gt; 函数的两个参数： 
&lt;code&gt;Math.max(2&lt;/code&gt; 和 &lt;code&gt;5)&lt;/code&gt; 
其他错误信息也是有可能的。&lt;/p&gt;
&lt;p&gt;变量的引用如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;VARIABLE&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;如果引用了未定义的变量或函数，那么 JMeter 并不会报告或者记录错误信息——引用返回值就是引用自身。例如，如果 &lt;code&gt;UNDEF&lt;/code&gt; 没有被定义为变量，&lt;code&gt;${UNDEF}&lt;/code&gt; 的返回值就是 &lt;code&gt;${UNDEF}&lt;/code&gt;。&lt;/strong&gt; 变量和函数（包括属性）都是区分大小写的。&lt;strong&gt;JMeter 会剔除变量名称中的空格，例如 &lt;code&gt;${__Random(1,63, LOTTERY )}&lt;/code&gt; 中的变量‘ &lt;code&gt;LOTTERY&lt;/code&gt; ’会被‘&lt;code&gt;LOTTERY&lt;/code&gt;’取代。&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;属性与变量不一样。变量对线程而言是局部的；属性是针对所有线程的，属性需要使用 &lt;code&gt;__P&lt;/code&gt; 或 &lt;code&gt;__property&lt;/code&gt; 函数来引用。&lt;/p&gt;
&lt;p&gt;在 Windows 路径变量（例如 &lt;code&gt;C:\test\${test}&lt;/code&gt;）前使用 &lt;code&gt;\&lt;/code&gt; 时，要确保加上 &lt;code&gt;\&lt;/code&gt; 来转义，否则 JMeter 将不能解释变量，所以要这样写：&lt;code&gt;C:\\test\\${test}&lt;/code&gt;。&lt;br&gt;
还有一种方法，就是使用 &lt;code&gt;/&lt;/code&gt; 作为路径分隔符，例如 &lt;code&gt;C:/test/${test}&lt;/code&gt;——Windows 的 JVMs 在必要时会将它转换成路径分隔符。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p id="functions_list"&gt;函数列表，不严格的按类型划分：&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;函数类型&lt;/th&gt;
&lt;th&gt;名称&lt;/th&gt;
&lt;th&gt;注释&lt;/th&gt;
&lt;th align="left"&gt;开始使用版本&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;信息&lt;/td&gt;
&lt;td&gt;&lt;a href="#threadNum"&gt;threadNum&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;获得线程编号&lt;/td&gt;
&lt;td align="left"&gt;1.X&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;信息&lt;/td&gt;
&lt;td&gt;&lt;a href="#threadGroupName"&gt;threadGroupName&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;获得线程组名称&lt;/td&gt;
&lt;td align="left"&gt;4.1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;信息&lt;/td&gt;
&lt;td&gt;&lt;a href="#samplerName"&gt;samplerName&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;获得采样器名称（标签）&lt;/td&gt;
&lt;td align="left"&gt;2.5&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;信息&lt;/td&gt;
&lt;td&gt;&lt;a href="#machineIP"&gt;machineIP&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;获得本地 IP 地址&lt;/td&gt;
&lt;td align="left"&gt;2.6&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;信息&lt;/td&gt;
&lt;td&gt;&lt;a href="#machineName"&gt;machineName&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;获得本地主机名称&lt;/td&gt;
&lt;td align="left"&gt;1.X&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;信息&lt;/td&gt;
&lt;td&gt;&lt;a href="#time"&gt;time&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;以各种格式返回当前时间&lt;/td&gt;
&lt;td align="left"&gt;2.2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;信息&lt;/td&gt;
&lt;td&gt;&lt;a href="#timeShift"&gt;timeShift&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;返回各种格式的日期加上指定的秒数/分钟数/小时数/天数或月数&lt;/td&gt;
&lt;td align="left"&gt;3.3&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;信息&lt;/td&gt;
&lt;td&gt;&lt;a href="#log"&gt;log&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;记录（或显示）一条日志（并返回其值）&lt;/td&gt;
&lt;td align="left"&gt;2.2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;信息&lt;/td&gt;
&lt;td&gt;&lt;a href="#logn"&gt;logn&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;记录（或显示）一条日志（并返回空值）&lt;/td&gt;
&lt;td align="left"&gt;2.2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;输入&lt;/td&gt;
&lt;td&gt;&lt;a href="#StringFromFile"&gt;StringFromFile&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;从文件中读取一行&lt;/td&gt;
&lt;td align="left"&gt;1.9&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;输入&lt;/td&gt;
&lt;td&gt;&lt;a href="#FileToString"&gt;FileToString&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;读取整个文件&lt;/td&gt;
&lt;td align="left"&gt;2.4&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;输入&lt;/td&gt;
&lt;td&gt;&lt;a href="#CSVRead"&gt;CSVRead&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;从 CSV 分隔文件中读取&lt;/td&gt;
&lt;td align="left"&gt;1.9&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;输入&lt;/td&gt;
&lt;td&gt;&lt;a href="#XPath"&gt;XPath&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;使用 XPath 表达式从文件中读取&lt;/td&gt;
&lt;td align="left"&gt;2.0.3&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;计算&lt;/td&gt;
&lt;td&gt;&lt;a href="#counter"&gt;counter&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;生成递增的数字&lt;/td&gt;
&lt;td align="left"&gt;1.X&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;格式化&lt;/td&gt;
&lt;td&gt;&lt;a href="#dateTimeConvert"&gt;dateTimeConvert&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;将日期或时间从源格式转换为目标格式&lt;/td&gt;
&lt;td align="left"&gt;4.0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;计算&lt;/td&gt;
&lt;td&gt;&lt;a href="#digest"&gt;digest&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;生成摘要（SHA-1, SHA-256, MD5...）&lt;/td&gt;
&lt;td align="left"&gt;4.0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;计算&lt;/td&gt;
&lt;td&gt;&lt;a href="#intSum"&gt;intSum&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;计算整形数（int）的和&lt;/td&gt;
&lt;td align="left"&gt;1.8.1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;计算&lt;/td&gt;
&lt;td&gt;&lt;a href="#longSum"&gt;longSum&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;计算长整形数（long）的和&lt;/td&gt;
&lt;td align="left"&gt;2.3.2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;计算&lt;/td&gt;
&lt;td&gt;&lt;a href="#Random"&gt;Random&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;生成随机数&lt;/td&gt;
&lt;td align="left"&gt;1.9&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;计算&lt;/td&gt;
&lt;td&gt;&lt;a href="#RandomDate"&gt;RandomDate&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;在指定日期范围内生成随机日期&lt;/td&gt;
&lt;td align="left"&gt;3.3&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;计算&lt;/td&gt;
&lt;td&gt;&lt;a href="#RandomFromMultipleVars"&gt;RandomFromMultipleVars&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;从由 &lt;code&gt;|&lt;/code&gt; 分隔的一组变量值中随机提取一个元素&lt;/td&gt;
&lt;td align="left"&gt;3.1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;计算&lt;/td&gt;
&lt;td&gt;&lt;a href="#RandomString"&gt;RandomString&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;生成随机字符串&lt;/td&gt;
&lt;td align="left"&gt;2.6&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;计算&lt;/td&gt;
&lt;td&gt;&lt;a href="#UUID"&gt;UUID&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;生成随机的类型为 4 的通用唯一标识符（UUID）&lt;/td&gt;
&lt;td align="left"&gt;2.9&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;脚本&lt;/td&gt;
&lt;td&gt;&lt;a href="#groovy"&gt;groovy&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;执行 Groovy 脚本&lt;/td&gt;
&lt;td align="left"&gt;3.1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;脚本&lt;/td&gt;
&lt;td&gt;&lt;a href="#BeanShell"&gt;BeanShell&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;执行 BeanShell 脚本&lt;/td&gt;
&lt;td align="left"&gt;1.X&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;脚本&lt;/td&gt;
&lt;td&gt;&lt;a href="#javaScript"&gt;javaScript&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;处理 JavaScript (Nashorn)&lt;/td&gt;
&lt;td align="left"&gt;1.9&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;脚本&lt;/td&gt;
&lt;td&gt;&lt;a href="#jexl2"&gt;jexl2&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;执行通用 Jexl2 表达式&lt;/td&gt;
&lt;td align="left"&gt;jexl2(2.1.1)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;脚本&lt;/td&gt;
&lt;td&gt;&lt;a href="#jexl3"&gt;jexl3&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;执行通用 Jexl3 表达式&lt;/td&gt;
&lt;td align="left"&gt;jexl3 (3.0)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;属性&lt;/td&gt;
&lt;td&gt;&lt;a href="#isPropDefined"&gt;isPropDefined&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;测试属性是否存在&lt;/td&gt;
&lt;td align="left"&gt;4.0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;属性&lt;/td&gt;
&lt;td&gt;&lt;a href="#property"&gt;property&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;读取属性&lt;/td&gt;
&lt;td align="left"&gt;2.0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;属性&lt;/td&gt;
&lt;td&gt;&lt;a href="#P"&gt;P&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;读取属性（速记方式）&lt;/td&gt;
&lt;td align="left"&gt;2.0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;属性&lt;/td&gt;
&lt;td&gt;&lt;a href="#setProperty"&gt;setProperty&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;设置 JMeter 属性&lt;/td&gt;
&lt;td align="left"&gt;2.1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;变量&lt;/td&gt;
&lt;td&gt;&lt;a href="#split"&gt;split&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;将字符串拆分为变量&lt;/td&gt;
&lt;td align="left"&gt;2.0.2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;变量&lt;/td&gt;
&lt;td&gt;&lt;a href="#eval"&gt;eval&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;执行变量表达式&lt;/td&gt;
&lt;td align="left"&gt;2.3.1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;变量&lt;/td&gt;
&lt;td&gt;&lt;a href="#evalVar"&gt;evalVar&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;存储在变量中的表达式&lt;/td&gt;
&lt;td align="left"&gt;2.3.1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;属性&lt;/td&gt;
&lt;td&gt;&lt;a href="#isVarDefined"&gt;isVarDefined&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;测试变量是否存在&lt;/td&gt;
&lt;td align="left"&gt;4.0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;变量&lt;/td&gt;
&lt;td&gt;&lt;a href="#V"&gt;V&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;执行变量名称&lt;/td&gt;
&lt;td align="left"&gt;2.3RC3&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;字符串&lt;/td&gt;
&lt;td&gt;&lt;a href="#char"&gt;char&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;将相应的编码转换成 Unicode 字符值&lt;/td&gt;
&lt;td align="left"&gt;2.3.3&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;字符串&lt;/td&gt;
&lt;td&gt;&lt;a href="#changeCase"&gt;changeCase&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;改变大小写模式&lt;/td&gt;
&lt;td align="left"&gt;4.0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;字符串&lt;/td&gt;
&lt;td&gt;&lt;a href="#escapeHtml"&gt;escapeHtml&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;使用 HTML 编码对字符串进行编码&lt;/td&gt;
&lt;td align="left"&gt;2.3.3&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;字符串&lt;/td&gt;
&lt;td&gt;&lt;a href="#escapeOroRegexpChars"&gt;escapeOroRegexpChars&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;引用 ORO 正则表达式使用的元字符&lt;/td&gt;
&lt;td align="left"&gt;2.9&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;字符串&lt;/td&gt;
&lt;td&gt;&lt;a href="#escapeXml"&gt;escapeXml&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;使用 XMl 编码对字符串进行编码&lt;/td&gt;
&lt;td align="left"&gt;3.2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;字符串&lt;/td&gt;
&lt;td&gt;&lt;a href="#regexFunction"&gt;regexFunction&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;使用正则表达式解析之前的响应&lt;/td&gt;
&lt;td align="left"&gt;1.X&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;字符串&lt;/td&gt;
&lt;td&gt;&lt;a href="#unescape"&gt;unescape&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;将 Java 转义过的字符串（例如 \n &amp;amp; \t）反转义&lt;/td&gt;
&lt;td align="left"&gt;2.3.3&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;字符串&lt;/td&gt;
&lt;td&gt;&lt;a href="#unescapeHtml"&gt;unescapeHtml&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;将 HTML 编码的字符串解码&lt;/td&gt;
&lt;td align="left"&gt;2.3.3&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;字符串&lt;/td&gt;
&lt;td&gt;&lt;a href="#urldecode"&gt;urldecode&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;对 application/x-www-form-urlencoded 字符串解码&lt;/td&gt;
&lt;td align="left"&gt;2.10&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;字符串&lt;/td&gt;
&lt;td&gt;&lt;a href="#urlencode"&gt;urlencode&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;将字符串编码成 application/x-www-form-urlencoded 字符串&lt;/td&gt;
&lt;td align="left"&gt;2.10&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;字符串&lt;/td&gt;
&lt;td&gt;&lt;a href="#TestPlanName"&gt;TestPlanName&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;返回当前测试计划的名称&lt;/td&gt;
&lt;td align="left"&gt;2.6&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id="201"&gt;20.1 函数可以做什么&lt;/h2&gt;
&lt;p&gt;JMeter 有两种函数：用户定义的静态值（或变量）和内建函数。&lt;br&gt;
用户定义的静态值允许用户在编译或者运行测试树时，使用自定义变量来替换静态值。这种替换只在测试运行的开始阶段执行一次。例如，可以用自定义变量来替换所有 HTTP 请求的 DOMAIN 域，这样就使得在不同服务器下执行相同测试的测试变更成为一件简单的事情。&lt;/p&gt;
&lt;p&gt;注意，目前变量不支持嵌套，例如 &lt;code&gt;${Var${N}}&lt;/code&gt; 是无效的，但是可以使用函数 &lt;code&gt;__V(variable)&lt;/code&gt; 来实现嵌套变量的目的：&lt;code&gt;${__V(Var${N})}&lt;/code&gt;。同样可以用 &lt;code&gt;${__BeanShell(vars.get("Var${N}")}&lt;/code&gt; 来实现。&lt;/p&gt;
&lt;p&gt;这种类型的替换可以不用函数来实现，但是这样就没有那么方便和直观了。用户可以创建默认配置元件来填充采样器中的空值。变量可以替换任何给定值的一部分，而不只是填充空值。&lt;/p&gt;
&lt;p&gt;用户可以通过使用内建函数在运行时根据之前的响应数据、函数所在线程、当前时间和其他资源计算出新的变量值。这些变量值在测试过程中会根据每个请求动态刷新。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;函数被线程共享。在测试计划中每次函数的调用，都由一个单独的函数实例来处理。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id="202"&gt;20.2 函数和变量可以用在哪？&lt;/h2&gt;
&lt;p&gt;函数和变量可以用在任何测试元件的任何输入域中（除了测试计划——见下文）。有些输入域只接受数字而不支持字符串，因此它们也不支持函数。然而，大多数输入域还是支持函数的。&lt;/p&gt;
&lt;p&gt;在测试计划中使用函数是有限制的。当函数被调用时，JMeter 线程变量并没有完全初始化，因此变量名称作为参数传递时也没有初始化，变量会引用失败，所以 &lt;code&gt;split()&lt;/code&gt; 和 &lt;code&gt;regex()&lt;/code&gt; 和变量赋值函数都不能正常工作。&lt;code&gt;threadNum()&lt;/code&gt; 函数也不会工作（它在测试计划层也没有意义）。下面是可以在测试计划中使用的的函数：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;intSum&lt;/li&gt;
&lt;li&gt;longSum&lt;/li&gt;
&lt;li&gt;machineName&lt;/li&gt;
&lt;li&gt;BeanShell&lt;/li&gt;
&lt;li&gt;groovy&lt;/li&gt;
&lt;li&gt;javaScript&lt;/li&gt;
&lt;li&gt;jexl2/jexl3&lt;/li&gt;
&lt;li&gt;random&lt;/li&gt;
&lt;li&gt;time&lt;/li&gt;
&lt;li&gt;property functions&lt;/li&gt;
&lt;li&gt;log functions&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;配置元件是由独立线程处理的。因此像 &lt;code&gt;__threadNum&lt;/code&gt; 这样的函数在一些测试元件（例如用户定义的变量）中不能正常地工作。同样要注意在用户定义的变量（UDV）中定义的变量，在（UDV）元件被处理前是不能使用的。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;当在 SQL 代码（或其他）中引用变量/函数时，要记得给文本字符串添加必要的引号，即使用：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;  SELECT item from table where name=&amp;#39;&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;VAR&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;&amp;#39;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;而不是：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;  SELECT item from table where name=&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;VAR&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;（除非 &lt;code&gt;VAR&lt;/code&gt; 本身包含引号）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id="203"&gt;20.3 如何引用变量和函数&lt;/h2&gt;
&lt;p&gt;在测试元件中引用一个变量可以通过使用 &lt;code&gt;${&lt;/code&gt; 和 &lt;code&gt;}&lt;/code&gt; 将变量名称括起来实现。&lt;/p&gt;
&lt;p&gt;函数引用的方法相同，但是按照惯例，函数名称以“&lt;code&gt;__&lt;/code&gt;”开头来和变量名称区分开。一些函数带参数，参数放在圆括号中，用逗号分隔。如果函数不带参数，可以省略圆括号。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如果参数本身带逗号，必须将其转义。可以使用‘&lt;code&gt;\,&lt;/code&gt;’来转义。&lt;/strong&gt; 这适用于例如脚本函数 - Javascript，Beanshell，Jexl，groovy - 有必要对所有脚本函数调用中的逗号加以转义，例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;__BeanShell&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;vars&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;put&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;name&amp;quot;&lt;/span&gt;\&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;value&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;换一种方法，你也可以将你的脚本定义为一个变量，例如在测试计划中定义：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;SCRIPT          vars.put(&amp;quot;name&amp;quot;,&amp;quot;value&amp;quot;)
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;定义过的脚本可以像下面这样被引用：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;__BeanShell&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="err"&gt;$&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;SCRIPT&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;)}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;在 &lt;code&gt;SCRIPT&lt;/code&gt; 变量中就没有必要对逗号进行转义了，因为函数的调用在变量用其值替换之前被解析。该方法适用于 JSR223 或者 BeanShell 采样器，这两种采样器可用来测试 Javascript，Jexl 和 BeanShell 脚本。&lt;/p&gt;
&lt;p&gt;函数可以引用参数和其他函数，例如 &lt;code&gt;${__XPath(${__P(xpath.file),${XPATH})}&lt;/code&gt; 使用“&lt;code&gt;xpath.file&lt;/code&gt;”的值作为文件名，使用变量 &lt;code&gt;XPATH&lt;/code&gt; 的内容作为搜索表达式。&lt;/p&gt;
&lt;p&gt;JMeter 提供一个工具来帮助建立各种内置函数的函数调用，只需使用复制-粘贴就可以实现。它不会自动为你转义，因为函数可以作为其他函数的参数，应该只对文本内容进行转义。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如果一个字符串既包含反斜杠（‘&lt;code&gt;\&lt;/code&gt;’）又包含函数或者变量引用，出现在‘&lt;code&gt;$&lt;/code&gt;’或‘&lt;code&gt;,&lt;/code&gt;’或‘&lt;code&gt;\&lt;/code&gt;’之前的反斜杠会被移除。这种操作对于包含逗号或者 &lt;code&gt;${&lt;/code&gt; 的嵌套函数是有必要的。如果一个字符串不包含函数或者变量引用，那么在‘&lt;code&gt;$&lt;/code&gt;’或‘&lt;code&gt;,&lt;/code&gt;’或‘&lt;code&gt;\&lt;/code&gt;’之前的反斜杠不会被移除。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;变量或函数的值可以用 &lt;a href="#logn"&gt;&lt;code&gt;__logn()&lt;/code&gt;&lt;/a&gt; 函数来报告&lt;/strong&gt;，&lt;code&gt;__logn()&lt;/code&gt; 函数在要报告的变量被定义之后可以在测试计划的任何地方被引用。除此之外，Java 请求采样器可以用来生成一个包含变量引用的采样；其输出能在合适的监听器中显示。注意也可以通过在查看结果树中使用 &lt;a href="http://jmeter.apache.org/usermanual/component_reference.html#Debug_Sampler"&gt;Debug Sampler&lt;/a&gt; 来显示变量的值。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如果用和内建函数同样的名称定义一个用户静态变量，那么定义的静态变量将覆盖同名内建函数。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id="204"&gt;20.4 函数助手对话框&lt;/h2&gt;
&lt;p&gt;函数助手对话框可以在 JMeter 的工具菜单中找到。&lt;/p&gt;
&lt;p&gt;&lt;img alt="Function Helper Dialog" src="http://jmeter.apache.org/images/screenshots/function_helper_dialog.png"&gt;  &lt;/p&gt;
&lt;p&gt;&lt;em&gt;函数助手对话框&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;使用函数助手，可以从下拉列表中选择一个函数，并给它的参数赋值。表格左列是参数的简要说明，表格的右列填入相应参数的值。不同的函数有不同的参数。&lt;/p&gt;
&lt;p&gt;上述操作完成之后，点击“生成（Generate）”按钮，相应调用函数的字符串就生成了，你可以复制-粘贴到测试计划中的任何地方。&lt;/p&gt;
&lt;h2 id="205"&gt;20.5 函数&lt;/h2&gt;
&lt;h3 id="regexFunction"&gt;__regexFunction&lt;/h3&gt;

&lt;p&gt;regexFunction 函数可以使用任意正则表达式（用户提供的）来解析之前的服务器响应（或变量值）。函数返回填充了变量值的模版字符串。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;__regexFunction&lt;/code&gt; 也可以存储值供以后使用。你可以在它的第六个参数中设定一个引用名称。在函数执行之后，可以使用用户定义的值的语法在稍后时间检索相同的值。例如，如果输入 “&lt;code&gt;refName&lt;/code&gt;” 作为第六个参数，那么可以使用：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;${refName}&lt;/code&gt; 来引用该函数解析的第二个参数（“替换字符串的模版”）的计算结果&lt;/li&gt;
&lt;li&gt;&lt;code&gt;${refName_g0}&lt;/code&gt; 来引用该函数解析的整个匹配&lt;/li&gt;
&lt;li&gt;&lt;code&gt;${refName_g1}&lt;/code&gt; 来引用该函数解析的第一个匹配组合&lt;/li&gt;
&lt;li&gt;&lt;code&gt;${refName_g#}&lt;/code&gt; 来引用该函数解析的第 N 个匹配组合&lt;/li&gt;
&lt;li&gt;&lt;code&gt;${refName_matchNr}&lt;/code&gt; 来引用该函数解析的匹配组合数量&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;如果是分布式测试，要切换模式（见 &lt;code&gt;jmeter.properties&lt;/code&gt;）确保它不在剥离模式下，参见 &lt;a href="https://bz.apache.org/bugzilla/show_bug.cgi?id=56376"&gt;&lt;code&gt;Bug 56376&lt;/code&gt;&lt;/a&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;参数（Parameters）&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性（Attribute）&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th&gt;是否必须&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;第一个参数&lt;/td&gt;
&lt;td&gt;第一个参数是解析响应数据的正则表达式。它会抓取所有匹配。请在模版字符串中给该表达式中想要使用的部分加上括号。例如：&lt;code&gt;&amp;lt;a href="(.*)"&amp;gt;&lt;/code&gt;。它将抓取链接值并储存在第一个匹配组合中（这里只有一个匹配组合）。另一个例子：&lt;code&gt;&amp;lt;input type="hidden" name="(.*)" value="(.*)"&amp;gt;&lt;/code&gt;。它将抓取 name 的值作为第一个匹配组合，value 的值作为第二个匹配组合。这些匹配的值可以用在模版字符串中。&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;第二个参数&lt;/td&gt;
&lt;td&gt;这是一个运行时会替换函数的模版字符串。要引用正则表达式中捕获的匹配组合，使用下面的句法：&lt;code&gt;$[group_number]$&lt;/code&gt;。例如 &lt;code&gt;$1$&lt;/code&gt; 或者 &lt;code&gt;$2$&lt;/code&gt;。你的模版可以是任意字符串。&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;第三个参数&lt;/td&gt;
&lt;td&gt;第三个参数告诉 JMeter 使用第几个匹配。你的正则表达式可能找到多个匹配。对此有四个选项：&lt;br/&gt;&lt;ul&gt;&lt;li&gt; 整数——直接告诉 JMeter 使用第几个匹配。‘&lt;code&gt;1&lt;/code&gt;’对应第一个，‘&lt;code&gt;2&lt;/code&gt;’对应第二个，以此类推。 &lt;/li&gt;&lt;li&gt; &lt;code&gt;RAND&lt;/code&gt;——告诉 JMeter 使用随机匹配。&lt;/li&gt;&lt;li&gt; &lt;code&gt;ALL&lt;/code&gt;——告诉 JMeter 使用所有匹配，对应每个匹配生成一个模版字符串并将它们组合到一起。这个选项很少用到。&lt;/li&gt;&lt;li&gt; 0 到 1 之间的浮点数——告诉 JMeter 根据公式（总的匹配个数*浮点值）计算使用第几个匹配项，计算值向最近的整数取整&lt;/li&gt;&lt;/ul&gt;&lt;/td&gt;
&lt;td&gt;否，默认值 = 1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;第四个参数&lt;/td&gt;
&lt;td&gt;如果上一个参数选择 &lt;code&gt;ALL&lt;/code&gt;，这个参数会被插入到每个附加的模版值副本之间&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;第五个参数&lt;/td&gt;
&lt;td&gt;如果没有匹配项返回的默认值&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;第六个参数&lt;/td&gt;
&lt;td&gt;重用此函数解析的值的引用名称,储存的值包括 &lt;code&gt;${refName}&lt;/code&gt;（替换的模版字符串）和 &lt;code&gt;${refName_g#}&lt;/code&gt; ,其中“&lt;code&gt;#&lt;/code&gt;”代表正则表达式匹配分组的序号（“&lt;code&gt;0&lt;/code&gt;”可以用来引用整个匹配）&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;第七个参数&lt;/td&gt;
&lt;td&gt;输入变量名称。如果指定了这个参数，那么将使用变量的值作为输入，而不是使用之前的采样结果。&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;a href="#functions_list"&gt;【返回函数列表】&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="counter"&gt;__counter&lt;/h3&gt;

&lt;p&gt;计数器每次调用会生成一个新值，从 1 开始，每次加 1。计数器可以配置成对每个虚拟用户独立的，也可以配置成对所有用户公用的。如果每个用户的值分开计数，通常用于计算测试计划的执行次数。全局计数器通常用于计算请求的次数。&lt;/p&gt;
&lt;p&gt;计数器使用一个整型变量来保存计数，允许的最大值为 2,147,483,647。&lt;/p&gt;
&lt;p&gt;计数器函数实例是完全独立的。全局计数器 - “&lt;code&gt;FALSE&lt;/code&gt;” - 的每个实例都是独立维护的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;__counter&lt;/code&gt; 函数在同一个迭代中的多次调用不会进一步增加值。&lt;/strong&gt;&lt;br&gt;
如果您想对每个采样器计数，请使用前置处理器（例如&lt;a href="http://jmeter.apache.org/usermanual/component_reference.html#User_Parameters"&gt;用户参数&lt;/a&gt;）中的功能。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参数（Parameters）&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性（Attribute）&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th&gt;是否必须&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;第一个参数&lt;/td&gt;
&lt;td&gt;&lt;code&gt;TRUE&lt;/code&gt; 如果您希望每个虚拟用户的计数器保持独立并与其他用户分开。 &lt;code&gt;FLASE&lt;/code&gt; 全局计数器。&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;第二个参数&lt;/td&gt;
&lt;td&gt;重用此函数创建的值的引用名称。&lt;br/&gt;存储的值的格式为 &lt;code&gt;${refName}&lt;/code&gt;。这允许你保留一个计数器，并在多个地方引用它的值。&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;a href="#functions_list"&gt;【返回函数列表】&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="threadNum"&gt;__threadNum&lt;/h3&gt;

&lt;p&gt;threadNum 函数只是返回当前正在执行的线程编号。线程编号独立于线程组，这意味着从该函数的角度来看，一个线程组中的线程 #1 与另一个线程组中的线程 #1 是没有区别的。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;该函数返回一个介于1和最大运行线程数之间的数字。注意，如果您将JSR223代码与&lt;a href="http://jmeter.apache.org/api/org/apache/jmeter/threads/JMeterContext.html"&gt;JMeterContext&lt;/a&gt;对象（&lt;code&gt;ctx&lt;/code&gt;变量）一起使用，则下面的代码返回一个介于0和（最大运行线程数减1）之间的数字&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;   ctx.getThreadNum（）
&lt;/pre&gt;&lt;/div&gt;


&lt;/blockquote&gt;
&lt;p&gt;这个函数没有参数。&lt;/p&gt;
&lt;p&gt;用法示例：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;__threadNum&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;返回 1 到线程组中配置的运行线程的最大值之间的数字。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;这个函数在任何配置元件（例如用户定义的变量）中都不起作用，因为它们是在一个单独的线程中运行的。在测试计划中也不能使用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href="#functions_list"&gt;【返回函数列表】&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="threadGroupName"&gt;__threadGroupName&lt;/h3&gt;

&lt;p&gt;threadGroupName 函数只返回正在执行的线程组的名称。 &lt;/p&gt;
&lt;p&gt;这个函数没有参数。&lt;/p&gt;
&lt;p&gt;用法示例：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;__threadGroupName&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;blockquote&gt;
&lt;p&gt;这个函数在任何配置元件（例如用户定义的变量）中都不起作用，因为它们是在一个单独的线程中运行的。在测试计划中也不能使用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href="#functions_list"&gt;【返回函数列表】&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="intSum"&gt;__intSum&lt;/h3&gt;

&lt;p&gt;intSum 函数可用于计算两个或更多个整数值之和。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;引用名称是可选的，但不能是有效的整数。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;参数（Parameters）&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性（Attribute）&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th&gt;是否必须&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;第一个参数&lt;/td&gt;
&lt;td&gt;第一个整数值&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;第二个参数&lt;/td&gt;
&lt;td&gt;第二个整数值&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;第 n 个参数&lt;/td&gt;
&lt;td&gt;第 n 个整数值&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;最后一个参数&lt;/td&gt;
&lt;td&gt;重用此函数计算值的引用名称。如果该参数被指定，引用名称必须包含至少一个非数字字符，否则将被视为另一个要添加的整数值&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;例子：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;__intSum&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;MYVAR&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;将返回 7（2 + 5）并将结果存储在 MYVAR 变量中。所以 &lt;code&gt;${MYVAR}&lt;/code&gt; 将等于 7。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;__intSum&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;将返回 14（2 + 5 + 7）并将结果存储在 MYVAR 变量中。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;__intSum&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="err"&gt;$&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;MYVAR&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;)}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;如果 MYVAR 值等于 8，1 + 2 + 5 + ${MYVAR}，返回 16。&lt;/p&gt;
&lt;p&gt;&lt;a href="#functions_list"&gt;【返回函数列表】&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="longSum"&gt;__longSum&lt;/h3&gt;

&lt;p&gt;longSum 函数可用于计算两个或更多个长整型值之和，当计算值不在 -2147483648 到 2147483647 之间，使用此函数而不是 __intSum。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参数（Parameters）&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性（Attribute）&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th&gt;是否必须&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;第一个参数&lt;/td&gt;
&lt;td&gt;第一个长整型值&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;第二个参数&lt;/td&gt;
&lt;td&gt;第二个长整型值&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;第 n 个参数&lt;/td&gt;
&lt;td&gt;第 n 个长整型值&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;最后一个参数&lt;/td&gt;
&lt;td&gt;重用此函数计算值的引用名称。如果该参数被指定，引用名称必须包含至少一个非数字字符，否则将被视为另一个要添加的长整型值&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;例子：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;__longSum&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;MYVAR&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;将返回 7（2 + 5）并将结果存储在 MYVAR 变量中。所以 &lt;code&gt;${MYVAR}&lt;/code&gt; 将等于 7。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;__longSum&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;将返回 14（2 + 5 + 7）并将结果存储在 MYVAR 变量中。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;__longSum&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="err"&gt;$&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;MYVAR&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;)}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;如果 MYVAR 值等于 8，1 + 2 + 5 + ${MYVAR}，返回 16。 &lt;/p&gt;
&lt;p&gt;&lt;a href="#functions_list"&gt;【返回函数列表】&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="StringFromFile"&gt;__StringFromFile&lt;/h3&gt;

&lt;p&gt;StringFromFile 函数可以用来从文本文件中读取字符串。这对于运行需要大量可变数据的测试非常有用。例如，在测试银行应用程序时，可能需要 100 或 1000 个不同的帐号。&lt;/p&gt;
&lt;p&gt;另请参阅可能更易于使用的 &lt;a href="http://jmeter.apache.org/usermanual/component_reference.html#CSV_Data_Set_Config"&gt;CSV Data Set Config 测试元件&lt;/a&gt;。但是，目前不支持多个输入文件。&lt;/p&gt;
&lt;p&gt;每次调用该函数都会从文件中读取下一行。所有的线程共享相同的实例，所以不同的线程会读取不同的行。到达文件末尾时，除非达到最大循环次数，否则将从头开始重新读取。如果在一个测试脚本中引用该函数多次，每此引用都将独立打开文件，即使文件名相同。（如果要在其他地方再次使用该值，请为每个函数调用使用不同的变量名称。）&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;函数实例在线程之间共享，并且无论线程​​是否需要下一行输入，该文件都会（重新）打开，因此使用 &lt;code&gt;threadNumber&lt;/code&gt; 作为文件名的一部分将导致不可预知的行为。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果打开或读取文件时发生错误，函数会返回字符串“&lt;code&gt;**ERR**&lt;/code&gt;”。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参数（Parameters）&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性（Attribute）&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th&gt;是否必须&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;文件名称&lt;/td&gt;
&lt;td&gt;文件名称的路径。（可以使用相对于 JMeter 启动目录的相对路径）如果要使用可选的序列号，路径名称应该适合转换成十进制格式。看下面的例子。&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;变量名称&lt;/td&gt;
&lt;td&gt;引用名称 - &lt;code&gt;refName&lt;/code&gt; - 用于重用由此函数创建的值。存储该值的格式为 &lt;code&gt;${refName}&lt;/code&gt;。默认值是“&lt;code&gt;StringFromFile_&lt;/code&gt;”。&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;开始序列号&lt;/td&gt;
&lt;td&gt;初始序列号（如果省略，结束序列号将被视为循环计数）&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;结束序列号&lt;/td&gt;
&lt;td&gt;终止序列号（如果省略，序列号可以不受限制地增加下去）&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;文件名称参数在文件打开或重新打开时被解析。&lt;/p&gt;
&lt;p&gt;引用名称参数（如果支持）在每次执行函数时被解析。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;使用序列号：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用可选的序列号时，路径名称将使用 &lt;code&gt;java.text.DecimalFormat&lt;/code&gt; 的格式字符串。当前的序列号将作为唯一的参数传入。如果没有指定可选的开始序列号，就使用路径名称作为起始值。有用的格式序列如下：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;#&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;插入不带前导零或空格的数字&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;000&lt;/code&gt; &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;插入带有前导零的三位数字，如果需要的话&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;h4&gt;格式字符串的使用&lt;/h4&gt;&lt;/p&gt;
&lt;p&gt;以下是几个格式字符串以及它们将生成的对应序列。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;pin#'.'dat&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;生成不带前导零的序列，&lt;code&gt;.&lt;/code&gt; 还是 &lt;code&gt;.&lt;/code&gt;：&lt;code&gt;pin1.dat&lt;/code&gt;，...，&lt;code&gt;pin9.dat&lt;/code&gt;，&lt;code&gt;pin10.dat&lt;/code&gt;，...，&lt;code&gt;pin9999.dat&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;pin000'.'dat&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;生成带前导零的序列，同时保持 &lt;code&gt;.&lt;/code&gt;。当数字位数超过三位时，序列将使用更多位数的数字：&lt;code&gt;pin001.dat&lt;/code&gt;，... &lt;code&gt;pin099.dat&lt;/code&gt;，...，&lt;code&gt;pin999.dat&lt;/code&gt;，...，&lt;code&gt;pin9999.dat&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;pin'.'dat#&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;生成不带前导零的附加数字，同时保持 &lt;code&gt;.&lt;/code&gt;：&lt;code&gt;pin.dat1&lt;/code&gt;，...，&lt;code&gt;pin.dat9&lt;/code&gt;，...，&lt;code&gt;pin.dat999&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果需要的位数多于格式字符数，数字将根据需要进行扩展。&lt;br&gt;
&lt;strong&gt;要防止格式字符被解释，请将其包含在单引号中。请注意，“&lt;code&gt;.&lt;/code&gt;”是一个格式字符，必须用单引号引起来&lt;/strong&gt; （尽管 &lt;code&gt;#.&lt;/code&gt; 和 &lt;code&gt;000.&lt;/code&gt; 在工作区能按预期的方式工作，因为它被视为小数点，而小数点也是“&lt;code&gt;.&lt;/code&gt;”）。&lt;br&gt;
在其他语言环境（例如 &lt;code&gt;fr&lt;/code&gt;）中，小数点是“&lt;code&gt;,&lt;/code&gt;” - 这意味着“&lt;code&gt;#.&lt;/code&gt;”会变成“&lt;code&gt;nnn,&lt;/code&gt;”。&lt;br&gt;
有关完整的细节，请参阅 DecimalFormat （十进制格式）的文档。&lt;br&gt;
如果路径名称不包含任何特殊的格式字符，则将当前的序号直接附加到名称上，否则将根据格式化指令插入数字。&lt;br&gt;
如果起始序列号被忽略，并且指定了结束序列号，则结束序列号将被解释为循环计数，并且该文件将被使用循环计数的最大次数。在这种情况下，文件名不是格式化的。&lt;br&gt;
&lt;code&gt;${__StringFromFile(PIN#'.'DAT,,1,2)}&lt;/code&gt; 读取 &lt;code&gt;PIN1.DAT&lt;/code&gt;, &lt;code&gt;PIN2.DAT&lt;/code&gt; &lt;br&gt;
&lt;code&gt;${__StringFromFile(PIN.DAT,,,2)}&lt;/code&gt; 读取 &lt;code&gt;PIN.DAT&lt;/code&gt; 两次 &lt;br&gt;
注意上面 &lt;code&gt;PIN.DAT&lt;/code&gt; 中的“&lt;code&gt;.&lt;/code&gt;”不应被引号包含。在这种起始序列号被省略的情况下，文件名完全按原样使用。&lt;/p&gt;
&lt;p&gt;&lt;a href="#functions_list"&gt;【返回函数列表】&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="machineName"&gt;__machineName&lt;/h3&gt;

&lt;p&gt;machineName 函数返回本地主机名称。它使用 Java 方法 &lt;code&gt;InetAddress.getLocalHost()&lt;/code&gt; 并将值传递给 &lt;code&gt;getHostName()&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参数（Parameters）&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性（Attribute）&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th&gt;是否必须&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;变量名称&lt;/td&gt;
&lt;td&gt;重用此函数计算值的引用名称&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;例子：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;__machineName&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;返回机器的主机名称&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;__machineName&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;返回机器的主机名称&lt;/p&gt;
&lt;p&gt;&lt;a href="#functions_list"&gt;【返回函数列表】&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="machineIP"&gt;__machineIP&lt;/h3&gt;

&lt;p&gt;machineIP 函数返回本地 IP 地址。它使用 Java 方法&lt;code&gt;InetAddress.getLocalHost()&lt;/code&gt; 并将其值传递给 &lt;code&gt;getHostAddress()&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参数（Parameters）&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性（Attribute）&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th&gt;是否必须&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;变量名称&lt;/td&gt;
&lt;td&gt;重用此函数计算值的引用名称&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;例子：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;__machineIP&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;返回机器的 IP 地址&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;__machineIP&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;返回机器的 IP 地址&lt;/p&gt;
&lt;p&gt;&lt;a href="#functions_list"&gt;【返回函数列表】&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="javaScript"&gt;__javaScript&lt;/h3&gt;

&lt;p&gt;javaScript 函数执行一段 JavaScript（不是 Java！）代码并返回它的值。&lt;/p&gt;
&lt;p&gt;JMeter Javascrip t函数调用独立的 JavaScript 解释器。Javascript 被当作脚本语言使用，所以可以做相应的计算等。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在 JMeter 中，javaScript 并不是最好的脚本语言。如果你的测试计划需要大量的线程，建议使用&lt;code&gt;__jexl3&lt;/code&gt; 或&lt;code&gt;__groovy&lt;/code&gt; 函数。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;对于 Nashorn 引擎，请参阅&lt;a href="https://docs.oracle.com/javase/8/docs/technotes/guides/scripting/nashorn/"&gt; Java 平台标准版 Nashorn 用户指南&lt;/a&gt;。&lt;br&gt;
对于 Rhino 引擎，请参阅&lt;a href="http://www.mozilla.org/rhino/overview.html"&gt;Mozilla Rhino 概述&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;以下变量可用于脚本：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;log&lt;/code&gt; - 函数的&lt;a href="https://www.slf4j.org/api/org/slf4j/Logger.html"&gt;记录&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ctx&lt;/code&gt; - &lt;a href="http://jmeter.apache.org/api/org/apache/jmeter/threads/JMeterContext.html"&gt;JMeterContext&lt;/a&gt; 对象&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vars&lt;/code&gt; - &lt;a href="http://jmeter.apache.org/api/org/apache/jmeter/threads/JMeterVariables.html"&gt;JMeterVariables&lt;/a&gt; 对象&lt;/li&gt;
&lt;li&gt;&lt;code&gt;threadName&lt;/code&gt; - 包含当前线程名称的字符串&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sampler&lt;/code&gt; - 当前&lt;a href="http://jmeter.apache.org/api/org/apache/jmeter/samplers/Sampler.html"&gt;采样器&lt;/a&gt;对象（如果有的话）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;samplerResult&lt;/code&gt; - 之前的 &lt;a href="http://jmeter.apache.org/api/org/apache/jmeter/samplers/SampleResult.html"&gt;SampleResult&lt;/a&gt; 对象（如果有的话）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;props&lt;/code&gt; - JMeterProperties（类 &lt;a href="https://docs.oracle.com/javase/8/docs/api/java/util/Properties.html"&gt;java.util.Properties&lt;/a&gt;）对象&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Rhinoscript 允许通过其 Packages 对象访问静态方法。请参阅 &lt;a href="https://wiki.openjdk.java.net/display/Nashorn/Rhino+Migration+Guide"&gt;Java 脚本&lt;/a&gt; 文档。例如，可以像这样访问 JMeterContextService 静态方法：&lt;br&gt;
&lt;code&gt;Java.type("org.apache.jmeter.threads.JMeterContextService").getTotalThreads()&lt;/code&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;JMeter 不是浏览器，不能解释下载页面中的 JavaScript。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;参数（Parameters）&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性（Attribute）&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th&gt;是否必须&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;表达式&lt;/td&gt;
&lt;td&gt;要执行的JavaScript表达式。例如：&lt;br/&gt;&lt;ul&gt;&lt;li&gt;&lt;code&gt;new Date()&lt;/code&gt; - 返回当前日期和时间&lt;/li&gt;&lt;li&gt;&lt;code&gt;Math.floor(Math.random()*(${maxRandom}+1))&lt;/code&gt; - 一个介于 &lt;code&gt;0&lt;/code&gt; 和变量 &lt;code&gt;maxRandom&lt;/code&gt; 之间的随机数&lt;/li&gt;&lt;li&gt;&lt;code&gt;${minRandom}+Math.floor(Math.random()*(${maxRandom}-${minRandom}+1))&lt;/code&gt; - 介于变量 &lt;code&gt;minRandom&lt;/code&gt; 和 &lt;code&gt;maxRandom&lt;/code&gt; 之间的随机数&lt;/li&gt;&lt;li&gt;&lt;code&gt;"${VAR}"=="abcd"&lt;/code&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;变量名称&lt;/td&gt;
&lt;td&gt;重用此函数计算值的引用名称&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;blockquote&gt;
&lt;p&gt;请记住为文本字符串和 JMeter 变量添加必要的引号。另外，如果表达式有逗号，请确保将其转义。例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;__javaScript&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;${sp&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;&amp;#39;.slice(7\,99999))}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;7&lt;/code&gt; 之后的逗号被转义了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;例子：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;__javaScript&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Date&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;返回 &lt;code&gt;Sat Jan 09 2016 16:22:15 GMT+0100 (CET)&lt;/code&gt; &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;__javaScript&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Date&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt;&lt;span class="n"&gt;MYDATE&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;返回 &lt;code&gt;Sat Jan 09 2016 16:22:15 GMT+0100 (CET)&lt;/code&gt; 并将其存储在变量 &lt;code&gt;MYDATE&lt;/code&gt; 下 &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;__javaScript&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Math&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;floor&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Math&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;random&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="err"&gt;$&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;maxRandom&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;+1)),MYRESULT)}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;使用 &lt;code&gt;maxRandom&lt;/code&gt; 变量，返回 &lt;code&gt;0&lt;/code&gt; 和 &lt;code&gt;maxRandom&lt;/code&gt; 之间的随机值并将其存储在  &lt;code&gt;MYRESULT&lt;/code&gt; 中&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;__javaScript&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="err"&gt;$&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;minRandom&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;+Math.floor(Math.random()*(&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;maxRandom&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;-&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;minRandom&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;+1)),MYRESULT)}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;使用 &lt;code&gt;maxRandom&lt;/code&gt; 和 &lt;code&gt;minRandom&lt;/code&gt; 变量，返回 &lt;code&gt;maxRandom&lt;/code&gt; 和 &lt;code&gt;minRandom&lt;/code&gt; 之间的随机值并将其存储在 &lt;code&gt;MYRESULT&lt;/code&gt; 中&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;__javaScript&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;${VAR&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;&amp;quot;==&amp;quot;abcd&amp;quot;,MYRESULT)}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;将 &lt;code&gt;VAR&lt;/code&gt; 变量的值与 &lt;code&gt;abcd&lt;/code&gt; 进行比较，返回 &lt;code&gt;true&lt;/code&gt; 或 &lt;code&gt;false&lt;/code&gt; 并将结果存储在 &lt;code&gt;MYRESULT&lt;/code&gt; 中&lt;/p&gt;
&lt;p&gt;&lt;a href="#functions_list"&gt;【返回函数列表】&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="Random"&gt;__Random&lt;/h3&gt;

&lt;p&gt;random 函数返回一个介于给定最小值和最大值之间的随机数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参数（Parameters）&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性（Attribute）&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th&gt;是否必须&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;最小值&lt;/td&gt;
&lt;td&gt;一个数字&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;最大值&lt;/td&gt;
&lt;td&gt;一个更大的数字&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;变量名称&lt;/td&gt;
&lt;td&gt;重用此函数计算值的引用名称&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;例子：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;__Random&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;返回一个 0 到 10 之间的随机数&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;__Random&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;MYVAR&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;返回一个 0 到 10 之间的随机数，并将其存储在 &lt;code&gt;MYVAR&lt;/code&gt;中。&lt;code&gt;${MYVAR}&lt;/code&gt;将包含此随机数。&lt;/p&gt;
&lt;p&gt;&lt;a href="#functions_list"&gt;【返回函数列表】&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="RandomDate"&gt;__RandomDate&lt;/h3&gt;

&lt;p&gt;RandomDate 函数返回一个位于给定开始日期和结束日期值之间的随机日期。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参数（Parameters）&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性（Attribute）&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th&gt;是否必须&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;时间格式&lt;/td&gt;
&lt;td&gt;DateTimeFormatter 的格式字符串（默认为 &lt;code&gt;yyyy-MM-dd&lt;/code&gt;）&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;开始日期&lt;/td&gt;
&lt;td&gt;开始日期，默认值是现在&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;结束日期&lt;/td&gt;
&lt;td&gt;结束日期&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;用于格式的区域设置&lt;/td&gt;
&lt;td&gt;语言环境的字符串格式。语言代码必须是小写。国家代码必须大写。分隔符必须是下划线，例如 &lt;code&gt;en_EN&lt;/code&gt;。请参阅 &lt;a href="http://www.oracle.com/technetwork/java/javase/javase7locales-334809.html"&gt;http://www.oracle.com/technetwork/java/javase/javase7locales-334809.html&lt;/a&gt;。如果省略，则默认情况下该函数使用 Apache JMeter 当前语言环境。&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;变量名称&lt;/td&gt;
&lt;td&gt;要设置的变量名称&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;例子：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;__RandomDate&lt;/span&gt;&lt;span class="p"&gt;(,,&lt;/span&gt;&lt;span class="mi"&gt;2050&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mo"&gt;07&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;08&lt;/span&gt;&lt;span class="p"&gt;,,)&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;返回从现在到 &lt;code&gt;2050-07-08&lt;/code&gt; 之间一个随机的日期。例如 &lt;code&gt;2039-06-21&lt;/code&gt; &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;__RandomDate&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;dd&lt;/span&gt; &lt;span class="n"&gt;MM&lt;/span&gt; &lt;span class="n"&gt;yyyy&lt;/span&gt;&lt;span class="p"&gt;,,&lt;/span&gt;&lt;span class="mi"&gt;08&lt;/span&gt; &lt;span class="mo"&gt;07&lt;/span&gt; &lt;span class="mi"&gt;2050&lt;/span&gt;&lt;span class="p"&gt;,,)&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;将返回一个自定义格式的随机日期，例如 &lt;code&gt;04 03 2034&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="#functions_list"&gt;【返回函数列表】&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="RandomString"&gt;__RandomString&lt;/h3&gt;

&lt;p&gt;RandomString 函数返回一个 chars 长度内的随机字符串。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参数（Parameters）&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性（Attribute）&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th&gt;是否必须&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;长度&lt;/td&gt;
&lt;td&gt;生成字符串的长度&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;使用的字符&lt;/td&gt;
&lt;td&gt;用于生成字符串的字符&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;变量名称&lt;/td&gt;
&lt;td&gt;重用此函数计算值的引用名称&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;例子：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;__RandomString&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;返回随机的可读或不可读的 5 个字符&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;__RandomString&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;abcdefg&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;将返回从 &lt;code&gt;abcdefg&lt;/code&gt; 集合中挑选的 10 个字符的随机字符串，如 &lt;code&gt;cdbgdbeebd&lt;/code&gt; 或 &lt;code&gt;adbfeggfad&lt;/code&gt;，...&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;__RandomString&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;a12zeczclk&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;MYVAR&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;从 &lt;code&gt;a12zeczclk&lt;/code&gt; 集合中返回一个由 6 个字符组成的随机字符串，并将结果存储在 &lt;code&gt;MYVAR&lt;/code&gt; 中，&lt;code&gt;MYVAR&lt;/code&gt; 将包含像 &lt;code&gt;2z22ak&lt;/code&gt; 或 &lt;code&gt;z11kce&lt;/code&gt; 这样的字符串，...&lt;/p&gt;
&lt;p&gt;&lt;a href="#functions_list"&gt;【返回函数列表】&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="RandomFromMultipleVars"&gt;__RandomFromMultipleVars&lt;/h3&gt;

&lt;p&gt;RandomFromMultipleVars 函数根据&lt;code&gt;源变量&lt;/code&gt;提供的变量值返回一个随机值。&lt;/p&gt;
&lt;p&gt;变量可以是单值或多值的，它们可以由以下提取器生成：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://jmeter.apache.org/usermanual/component_reference.html#Boundary_Extractor"&gt;边界提取器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://jmeter.apache.org/usermanual/component_reference.html#Regular_Expression_Extractor"&gt;正则表达式提取器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://jmeter.apache.org/usermanual/component_reference.html#CSS_Selector_Extractor"&gt;CSS 提取器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://jmeter.apache.org/usermanual/component_reference.html#JSON_Extractor"&gt;JSON 提取器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://jmeter.apache.org/usermanual/component_reference.html#XPath_Extractor"&gt;XPath 提取器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://jmeter.apache.org/usermanual/component_reference.html#XPath2_Extractor"&gt;XPath2 提取器&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;多值变量就是，当你设置 &lt;code&gt;-1&lt;/code&gt; 作为&lt;code&gt;匹配数字&lt;/code&gt;所提取的值。当n = 1，2，3...时会创建相应匹配号变量 &lt;code&gt;varName_matchNr&lt;/code&gt;，并为每个值创建变量 &lt;code&gt;varName_n&lt;/code&gt;，其中n = 1，2，3 等 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参数（Parameters）&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性（Attribute）&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th&gt;是否必须&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;源变量&lt;/td&gt;
&lt;td&gt;变量名称包含的值将用作随机计算的输入，用 &lt;code&gt;|&lt;/code&gt; 分隔&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;变量名称&lt;/td&gt;
&lt;td&gt;重用此函数计算值的引用名称&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;例子：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;__RandomFromMultipleVars&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;val&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;根据变量 val 的内容返回一个随机的字符串，不管它们是否是多值的&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;__RandomFromMultipleVars&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;val1&lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="n"&gt;val2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;根据变量 val1 和 val2 的内容返回一个随机字符串，不管它们是否为多值&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;__RandomFromMultipleVars&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;val1&lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="n"&gt;val2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;MYVAR&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;根据变量 val1 和 val2 的内容返回一个随机字符串，不管它们是否为多值，并将结果存储在 &lt;code&gt;MYVAR&lt;/code&gt; 中 &lt;/p&gt;
&lt;p&gt;&lt;a href="#functions_list"&gt;【返回函数列表】&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="UUID"&gt;__UUID&lt;/h3&gt;

&lt;p&gt;UUID 函数返回伪随机类型为 4 的通用唯一标识符（UUID）。&lt;/p&gt;
&lt;p&gt;没有参数。&lt;/p&gt;
&lt;p&gt;例子：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;UUID&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;将返回具有以下格式的 UUID：&lt;code&gt;c69e0dd1-ac6b-4f2b-8d59-5d4e8743eecd&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="#functions_list"&gt;【返回函数列表】&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="CSVRead"&gt;__CSVRead&lt;/h3&gt;

&lt;p&gt;CSVRead 函数从 CSV 文件返回一个字符串（注意与 &lt;a href="#StringFromFile"&gt;StringFromFile&lt;/a&gt; 的区别）。&lt;/p&gt;
&lt;p&gt;注：JMeter 支持多个文件名。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;大多数情况下，较新的 &lt;a href="http://jmeter.apache.org/usermanual/component_reference.html#CSV_Data_Set_Config"&gt;CSV Data Set Config 元件&lt;/a&gt;更容易使用。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;第一次读取某个文件名时，文件被打开并读取到内部数组。空行将被视为文件结尾——这允许使用尾部注释。&lt;/p&gt;
&lt;p&gt;后续对同一文件名的所有引用使用相同的内部数组。注意，文件名是区分大小写的，即使操作系统不区分大小写，所以 &lt;code&gt;CSVRead(abc.txt,0)&lt;/code&gt; 和 &lt;code&gt;CSVRead(aBc.txt,0)&lt;/code&gt; 会引用不同的内部数组。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;*ALIAS&lt;/code&gt; 功能允许同一个文件被打开多次，并且允许较短的文件名。&lt;/p&gt;
&lt;p&gt;每个线程都有自己的内部指针，指向文件数组中的当前行。当一个线程第一次引用文件时，它将被分配到数组中的下一个空闲行，所以每个线程将访问与其他所有线程不同的行（除非线程数多于数组中的行）。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;该函数默认情况下以逗号分割行。如果要输入包含逗号的列，需要通过设置 &lt;code&gt;csvread.delimiter&lt;/code&gt; 属性将分隔符更改为不出现在任何列数据中的字符。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;参数（Parameters）&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性（Attribute）&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th&gt;是否必须&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;文件名称&lt;/td&gt;
&lt;td&gt;要读取的文件（或 &lt;code&gt;*ALIAS&lt;/code&gt;）&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;列号&lt;/td&gt;
&lt;td&gt;文件中的列号。 &lt;code&gt;0&lt;/code&gt; 为第一列，&lt;code&gt;1&lt;/code&gt;为第二列，以此类推。"&lt;code&gt;next&lt;/code&gt;" - 转到文件的下一行。 &lt;code&gt;*ALIAS&lt;/code&gt; - 打开一个文件并指派一个别名&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;例如，你可以设置一些变量如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;COL1a &lt;code&gt;${__CSVRead(random.txt,0)}&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;COL2a &lt;code&gt;${__CSVRead(random.txt,1)}${__CSVRead(random.txt,next)}&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;COL1b &lt;code&gt;${__CSVRead(random.txt,0)}&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;COL2b &lt;code&gt;${__CSVRead(random.txt,1)}${__CSVRead(random.txt,next)}&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这将从一行中读取两列，从下一行中读取两列。如果所有变量都在相同的前置处理器的用户参数上定义，那么这些行将是连续的。否则的话，另外一个线程可能会读取下一行。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;该函数不适用于大文件，因为它会将整个文件存储在内存中。对于较大的文件，请使用 &lt;a href="http://jmeter.apache.org/usermanual/component_reference.html#CSV_Data_Set_Config"&gt;CSV Data Set Config 元件&lt;/a&gt; 或 &lt;a href="#StringFromFile"&gt;StringFromFile&lt;/a&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href="#functions_list"&gt;【返回函数列表】&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="property"&gt;__property&lt;/h3&gt;

&lt;p&gt;property 函数返回 JMeter 属性的值。如果找不到属性值，并且没有提供默认值，则返回属性名称。当提供默认值时，可以不需要函数名称——参数可以设置为 null，并且将被忽略。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;${__property(user.dir)}&lt;/code&gt; - 返回 &lt;code&gt;user.dir&lt;/code&gt; 的值&lt;/li&gt;
&lt;li&gt;&lt;code&gt;${__property(user.dir,UDIR)}&lt;/code&gt; - 返回 &lt;code&gt;user.dir&lt;/code&gt; 的值并保存在 &lt;code&gt;UDIR&lt;/code&gt; 中&lt;/li&gt;
&lt;li&gt;&lt;code&gt;${__property(abcd,ABCD,atod)}&lt;/code&gt; - 返回属性 &lt;code&gt;abcd&lt;/code&gt; 的值（如果没有定义，则返回“&lt;code&gt;atod&lt;/code&gt;”）并保存在 &lt;code&gt;ABCD&lt;/code&gt; 中&lt;/li&gt;
&lt;li&gt;&lt;code&gt;${__property(abcd,,atod)}&lt;/code&gt; - 返回属性 &lt;code&gt;abcd&lt;/code&gt;的值（如果未定义，则返回“&lt;code&gt;atod&lt;/code&gt;”）但不保存&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;参数（Parameters）&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性（Attribute）&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th&gt;是否必须&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;属性名称&lt;/td&gt;
&lt;td&gt;要检索的属性名称&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;变量名称&lt;/td&gt;
&lt;td&gt;重用此函数计算值的引用名称&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;默认值&lt;/td&gt;
&lt;td&gt;属性的默认值&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;a href="#functions_list"&gt;【返回函数列表】&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="P"&gt;__P&lt;/h3&gt;

&lt;p&gt;这是一个简化的属性函数，用于在命令行中定义的属性。与&lt;code&gt;__property&lt;/code&gt; 函数不同，没有选项可将值保存在变量中，如果未提供默认值，则假定为 1。选择 1 作为假定默认值是因为它对于常见测试变量如循环次数，线程数，加速等都有效。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;p&gt;定义属性值：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;jmeter -Jgroup1.threads=7  -Jhostname1=www.realhost.edu
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;获取值：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;${__P(group1.threads)}&lt;/code&gt; - 返回 &lt;code&gt;group1.threads&lt;/code&gt; 的值&lt;/li&gt;
&lt;li&gt;&lt;code&gt;${__P(group1.loops)}&lt;/code&gt; - 返回 &lt;code&gt;group1.loops&lt;/code&gt; 的值&lt;/li&gt;
&lt;li&gt;&lt;code&gt;${__P(hostname,www.dummy.org)}&lt;/code&gt; - 返回属性的值的 &lt;code&gt;hostname&lt;/code&gt;（主机名）或 &lt;code&gt;www.dummy.org&lt;/code&gt; 。如果在上面的例子中没有定义，第一个函数调用将返回&lt;code&gt;7&lt;/code&gt;，第二个返回 &lt;code&gt;1&lt;/code&gt;，最后一个将返回 &lt;code&gt;www.dummy.org&lt;/code&gt; （除非这些属性在别处有定义！）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;参数（Parameters）&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性（Attribute）&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th&gt;是否必须&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;属性名称&lt;/td&gt;
&lt;td&gt;要检索的属性名称&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;默认值&lt;/td&gt;
&lt;td&gt;属性的默认值。如果省略，则默认为“&lt;code&gt;1&lt;/code&gt;”。&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;a href="#functions_list"&gt;【返回函数列表】&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="log"&gt;__log&lt;/h3&gt;

&lt;p&gt;log 函数记录一条日志，并返回它的输入字符串。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参数（Parameters）&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性（Attribute）&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th&gt;是否必须&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;要记录的字符串&lt;/td&gt;
&lt;td&gt;一个字符串&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;日志级别&lt;/td&gt;
&lt;td&gt;&lt;code&gt;OUT&lt;/code&gt;，&lt;code&gt;ERR&lt;/code&gt;，&lt;code&gt;DEBUG&lt;/code&gt;，&lt;code&gt;INFO&lt;/code&gt;（默认），&lt;code&gt;WARN&lt;/code&gt;或&lt;code&gt;ERROR&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;可丢弃的文本&lt;/td&gt;
&lt;td&gt;如果非空，则创建一个可丢弃的文本传递给记录器&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;注释&lt;/td&gt;
&lt;td&gt;如果存在，则显示在字符串中。用于标识正在记录的内容。&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;code&gt;OUT&lt;/code&gt; 和 &lt;code&gt;ERR&lt;/code&gt; 日志级别会直接输出记录到 &lt;code&gt;System.out&lt;/code&gt; 和 &lt;code&gt;System.err&lt;/code&gt;。这种情况下，输出始终会被打印——它不依赖于当前的日志设置。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;${__log(Message)}&lt;/code&gt; 写入日志文件,形如“&lt;code&gt;… thread Name : Message&lt;/code&gt;”&lt;/li&gt;
&lt;li&gt;&lt;code&gt;${__log(Message,OUT)}&lt;/code&gt; 写到控制台窗口&lt;/li&gt;
&lt;li&gt;&lt;code&gt;${__log(${VAR},,,VAR=)}&lt;/code&gt; 写入日志文件，形如“&lt;code&gt;… thread Name VAR=value&lt;/code&gt;”&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href="#functions_list"&gt;【返回函数列表】&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="logn"&gt;__logn&lt;/h3&gt;

&lt;p&gt;logn 函数记录一条日志，并返回空字符串。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参数（Parameters）&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性（Attribute）&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th&gt;是否必须&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;要记录的字符串&lt;/td&gt;
&lt;td&gt;一个字符串&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;日志级别&lt;/td&gt;
&lt;td&gt;&lt;code&gt;OUT&lt;/code&gt;，&lt;code&gt;ERR&lt;/code&gt;，&lt;code&gt;DEBUG&lt;/code&gt;，&lt;code&gt;INFO&lt;/code&gt;（默认），&lt;code&gt;WARN&lt;/code&gt;或&lt;code&gt;ERROR&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;可丢弃的文本&lt;/td&gt;
&lt;td&gt;如果非空，则创建一个可丢弃的文本传递给记录器&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;code&gt;OUT&lt;/code&gt; 和 &lt;code&gt;ERR&lt;/code&gt; 日志级别会直接输出记录到 &lt;code&gt;System.out&lt;/code&gt; 和 &lt;code&gt;System.err&lt;/code&gt;。这种情况下，输出始终会被打印——它不依赖于当前的日志设置。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;${__logn(VAR1=${VAR1},OUT)}&lt;/code&gt; 将变量的值写到控制台窗口&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href="#functions_list"&gt;【返回函数列表】&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="BeanShell"&gt;__BeanShell&lt;/h3&gt;

&lt;p&gt;BeanShell 函数执行传递给它的脚本，并返回结果。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;为了更好的性能，请使用&lt;a href="#groovy"&gt;&lt;code&gt;__groovy&lt;/code&gt;&lt;/a&gt;函数 &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;有关使用 BeanShell 的完整详细信息，请参考 BeanShell 网站：&lt;/strong&gt;&lt;a href="http://www.beanshell.org/"&gt;http://www.beanshell.org/&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注意，测试脚本中每个独立的函数调用都使用不同的解释器，但是后续的调用使用相同的解释器。这意味着变量在不同的函数的调用中会持续存在。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;单个函数实例可以从多个线程中调用。但是函数 &lt;code&gt;execute()&lt;/code&gt; 的方法是同步的。&lt;/p&gt;
&lt;p&gt;如果属性“&lt;code&gt;beanshell.function.init&lt;/code&gt;”已被定义，则将其作为源文件传递给解释器。这可以用来定义通用的方法和变量。在 bin 目录中有一个 init 示例文件：&lt;code&gt;BeanShellFunction.bshrc&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;以下变量在脚本执行之前已经被设置：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;log&lt;/code&gt; - BeanShell 函数（*）的&lt;a href="https://www.slf4j.org/api/org/slf4j/Logger.html"&gt;记录器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ctx&lt;/code&gt; - &lt;a href="http://jmeter.apache.org/api/org/apache/jmeter/threads/JMeterContext.html"&gt;JMeterContext&lt;/a&gt; 对象&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vars&lt;/code&gt; - &lt;a href="http://jmeter.apache.org/api/org/apache/jmeter/threads/JMeterVariables.html"&gt;JMeterVariables&lt;/a&gt; 对象&lt;/li&gt;
&lt;li&gt;&lt;code&gt;props&lt;/code&gt; - JMeterProperties（类 &lt;a href="https://docs.oracle.com/javase/8/docs/api/java/util/Properties.html"&gt;java.util.Properties&lt;/a&gt;）对象&lt;/li&gt;
&lt;li&gt;&lt;code&gt;threadName&lt;/code&gt; - 线程名称 （字符串）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Sampler&lt;/code&gt; - 当前的&lt;a href="http://jmeter.apache.org/api/org/apache/jmeter/samplers/Sampler.html"&gt;采样器&lt;/a&gt;，如果有的话&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SampleResult&lt;/code&gt; - 当前的 &lt;a href="http://jmeter.apache.org/api/org/apache/jmeter/samplers/SampleResult.html"&gt;SampleResult&lt;/a&gt;，如果有的话&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;（*）表示这是在 init 文件（如果有的话）被处理之前设置的。其他变量因调用而异。
&lt;strong&gt;参数（Parameters）&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性（Attribute）&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th&gt;是否必须&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;BeanShell 脚本&lt;/td&gt;
&lt;td&gt;BeanShell 脚本（不是文件名）&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;变量名称&lt;/td&gt;
&lt;td&gt;重用此函数计算值的引用名称&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;例子：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;__BeanShell&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;123&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="mi"&gt;456&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;返回 &lt;code&gt;56088&lt;/code&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;__BeanShell&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;source&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;function.bsh&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;在 &lt;code&gt;function.bsh&lt;/code&gt; 中处理脚本&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;请记住为文本字符串和表示文本字符串的 JMeter 变量添加必要的引号。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href="#functions_list"&gt;【返回函数列表】&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="groovy"&gt;__groovy&lt;/h3&gt;

&lt;p&gt;groovy 函数执行 &lt;a href="http://groovy-lang.org/"&gt;Apache Groovy&lt;/a&gt; 传递给它的脚本，并返回结果。&lt;/p&gt;
&lt;p&gt;如果属性“&lt;code&gt;groovy.utilities&lt;/code&gt;”已被定义，它会被 ScriptEngine（脚本引擎）加载。这可以用来定义通用的方法和变量。在 bin 目录中有一个 init 示例文件：&lt;code&gt;utility.groovy&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;以下变量在脚本执行之前已经被设置：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;log&lt;/code&gt; - groovy 函数（*）的&lt;a href="https://www.slf4j.org/api/org/slf4j/Logger.html"&gt;记录器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ctx&lt;/code&gt; - &lt;a href="http://jmeter.apache.org/api/org/apache/jmeter/threads/JMeterContext.html"&gt;JMeterContext&lt;/a&gt; 对象&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vars&lt;/code&gt; - &lt;a href="http://jmeter.apache.org/api/org/apache/jmeter/threads/JMeterVariables.html"&gt;JMeterVariables&lt;/a&gt; 对象&lt;/li&gt;
&lt;li&gt;&lt;code&gt;props&lt;/code&gt; - JMeterProperties（类 &lt;a href="https://docs.oracle.com/javase/8/docs/api/java/util/Properties.html"&gt;java.util.Properties&lt;/a&gt;）对象&lt;/li&gt;
&lt;li&gt;&lt;code&gt;threadName&lt;/code&gt; - 线程名称 （字符串）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Sampler&lt;/code&gt; - 当前的&lt;a href="http://jmeter.apache.org/api/org/apache/jmeter/samplers/Sampler.html"&gt;采样器&lt;/a&gt;，如果有的话&lt;/li&gt;
&lt;li&gt;&lt;code&gt;prev&lt;/code&gt; - 之前的 &lt;a href="http://jmeter.apache.org/api/org/apache/jmeter/samplers/SampleResult.html"&gt;SampleResult&lt;/a&gt;，如果有的话&lt;/li&gt;
&lt;li&gt;&lt;code&gt;OUT&lt;/code&gt; - System.out&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;（*）表示这是在 init 文件（如果有的话）被处理之前设置的。其他变量因调用而异。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;使用此函数时，请使用之前定义的变量而不是使用字符串替换来访问脚本中的变量。遵循此模式以确保缓存Groovy，从而确保您的测试具有高效性。 &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;例如&lt;strong&gt;，不要&lt;/strong&gt;执行以下操作： &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;__groovy&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;${myVar&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;&amp;quot;.substring(0\,2))}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;想象一下，变量myVar随每个事务而变化，上面的Groovy无法缓存，因为脚本每次都会更改。&lt;/p&gt;
&lt;p&gt;但是执行下面的操作，就可以缓存：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;__groovy&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;vars&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;get&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;myVar&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;substring&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;\&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;参数（Parameters）&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性（Attribute）&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th&gt;是否必须&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;要计算的表达式&lt;/td&gt;
&lt;td&gt;一个 groovy 脚本（不是文件名）&lt;br/&gt;&lt;blockquote&gt;本身包含逗号的参数值应根据需要进行转义。如果需要在参数值中包含逗号，请像这样转义： ‘&lt;code&gt;\,&lt;/code&gt;’&lt;/blockquote&gt;&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;变量名称&lt;/td&gt;
&lt;td&gt;重用此函数计算值的引用名称&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;例子：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;__groovy&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;123&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="mi"&gt;456&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;返回 &lt;code&gt;56088&lt;/code&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;__groovy&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;${var&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;&amp;quot;.substring(0\,2))}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;如果 var 的值是 &lt;code&gt;JMeter&lt;/code&gt;，它会在调用 &lt;code&gt;String.substring(0,2)&lt;/code&gt; 后返回 &lt;code&gt;JM&lt;/code&gt;。注意 &lt;code&gt;,&lt;/code&gt; 已经被 &lt;code&gt;\,&lt;/code&gt; 转义。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;请记住为文本字符串和表示文本字符串的 JMeter 变量添加必要的引号。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href="#functions_list"&gt;【返回函数列表】&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="split"&gt;__split&lt;/h3&gt;

&lt;p&gt;split 函数根据分隔符拆分传递给它的字符串，并返回原始字符串。如果分隔符与分隔符是相邻的，则返回“&lt;code&gt;？&lt;/code&gt;”作为值。拆分出来的字符串将返回到 &lt;code&gt;${VAR_1}&lt;/code&gt;，&lt;code&gt;${VAR_2}&lt;/code&gt;……这些变量中。变量的计数将返回到 &lt;code&gt;${VAR_n}&lt;/code&gt; 中。拖尾分隔符被视为缺失变量，并返回“&lt;code&gt;？&lt;/code&gt;”。此外，为了使它在 ForEach 控制器上更好地工作， &lt;code&gt;__split&lt;/code&gt; 现在会删除第一个不使用的变量，以防它是上一次拆分所设置的。&lt;/p&gt;
&lt;p&gt;例子：&lt;br&gt;
在测试计划中定义 &lt;code&gt;VAR&lt;/code&gt;="&lt;code&gt;a||c|&lt;/code&gt;"。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;__split&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="err"&gt;$&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;VAR&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;,VAR,|)}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这将返回 &lt;code&gt;VAR&lt;/code&gt; 的内容，即“&lt;code&gt;a||c|&lt;/code&gt;”并设置以下变量：&lt;br&gt;
&lt;code&gt;VAR_n&lt;/code&gt;=&lt;code&gt;4&lt;/code&gt;&lt;br&gt;
&lt;code&gt;VAR_1&lt;/code&gt;=&lt;code&gt;a&lt;/code&gt;&lt;br&gt;
&lt;code&gt;VAR_2&lt;/code&gt;=&lt;code&gt;?&lt;/code&gt;&lt;br&gt;
&lt;code&gt;VAR_3&lt;/code&gt;=&lt;code&gt;c&lt;/code&gt;&lt;br&gt;
&lt;code&gt;VAR_4&lt;/code&gt;=&lt;code&gt;?&lt;/code&gt;&lt;br&gt;
&lt;code&gt;VAR_5&lt;/code&gt;=&lt;code&gt;null&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参数（Parameters）&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性（Attribute）&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th&gt;是否必须&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;要拆分的字符串&lt;/td&gt;
&lt;td&gt;一个要拆分的字符串，例如“&lt;code&gt;a|b|c&lt;/code&gt;”&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;变量名称&lt;/td&gt;
&lt;td&gt;重用此函数计算值的引用名称&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;分隔符&lt;/td&gt;
&lt;td&gt;分隔符，例如&lt;code&gt;|&lt;/code&gt;。如果省略，则使用&lt;code&gt;,&lt;/code&gt;。注意 &lt;code&gt;,&lt;/code&gt; 需要 &lt;code&gt;\,&lt;/code&gt; 来转义。&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;a href="#functions_list"&gt;【返回函数列表】&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="XPath"&gt;__XPath&lt;/h3&gt;

&lt;p&gt;XPath 函数读取一个 XML 文件并匹配 XPath。每次调用该函数时，都会返回下一个匹配项。到达文件末尾后，会返回到开始。如果没有匹配的节点，该函数将返回空字符串，同时将一条警告消息写入 JMeter 日志文件。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注意，整个 NodeList 会被保存在内存中。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;例子：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;__XPath&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;path&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;to&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;build&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;xml&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;//&lt;/span&gt;&lt;span class="n"&gt;target&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="nd"&gt;@name&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这将匹配 &lt;code&gt;build.xml&lt;/code&gt; 中的所有 &lt;code&gt;target&lt;/code&gt; 节点，并返回下一个 &lt;code&gt;name&lt;/code&gt; 属性的内容&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参数（Parameters）&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性（Attribute）&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th&gt;是否必须&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;待解析的 XML 文件&lt;/td&gt;
&lt;td&gt;一个待解析的 XML 文件&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;XPath&lt;/td&gt;
&lt;td&gt;一个 XPath 表达式用来匹配 XML 文件中的节点&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;a href="#functions_list"&gt;【返回函数列表】&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="setProperty"&gt;__setProperty&lt;/h3&gt;

&lt;p&gt;setProperty 函数用来设置 JMeter 属性的值。函数的默认返回值是空字符串，因此在函数有效处都可以调用此函数。&lt;/p&gt;
&lt;p&gt;可以通过设置第 3 个可选参数为“&lt;code&gt;true&lt;/code&gt;”返回原始值。&lt;/p&gt;
&lt;p&gt;属性对 JMeter 来说是全局的，所以可以用在线程和线程组之间的通信上。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参数（Parameters）&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性（Attribute）&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th&gt;是否必须&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;属性名称&lt;/td&gt;
&lt;td&gt;要设置的属性名称&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;属性值&lt;/td&gt;
&lt;td&gt;该属性的值&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;True/False&lt;/td&gt;
&lt;td&gt;是否返回原始值？&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;a href="#functions_list"&gt;【返回函数列表】&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="time"&gt;__time&lt;/h3&gt;

&lt;p&gt;time 函数以各种格式返回当前时间。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参数（Parameters）&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性（Attribute）&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th&gt;是否必须&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;格式&lt;/td&gt;
&lt;td&gt;要传递给 &lt;a href="https://docs.oracle.com/javase/8/docs/api/java/text/SimpleDateFormat.html"&gt;SimpleDateFormat&lt;/a&gt; 的格式。该函数支持各种速记别名，见下文。如果省略，该函数将返回自纪元开始至今的时间（以毫秒为单位）。&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;变量名称&lt;/td&gt;
&lt;td&gt;要设置的变量名称&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;如果省略了格式字符串，则该函数返回自纪元开始至今的时间（以毫秒为单位）。如果格式匹配“&lt;code&gt;/ddd&lt;/code&gt;”（其中 &lt;code&gt;ddd&lt;/code&gt; 是十进制数字），则该函数返回以毫秒为单位的至今的时间除以 &lt;code&gt;ddd&lt;/code&gt; 的值。例如，“&lt;code&gt;/1000&lt;/code&gt;”将返回自纪元开始至今的时间（以秒为单位）。否则，当前时间传递给 SimpleDateFormat。支持以下简写别名：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;YMD&lt;/code&gt; = &lt;code&gt;yyyyMMdd&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;HMS&lt;/code&gt; = &lt;code&gt;HHmmss&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;YMDHMS&lt;/code&gt; = &lt;code&gt;yyyyMMdd-HHmmss&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;USER1&lt;/code&gt; = JMeter 属性 &lt;code&gt;time.USER1&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;USER2&lt;/code&gt; = JMeter 属性 &lt;code&gt;time.USER2&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;默认值可以通过设置适当的 JMeter 属性来改变，例如 &lt;code&gt;time.YMD=yyMMdd&lt;/code&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;__time&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;dd&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;MM&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;yyyy&lt;/span&gt;&lt;span class="p"&gt;,)&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;如果在2018年1月21日运行，将返回&lt;code&gt;21/01/2018&lt;/code&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;__time&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;YMD&lt;/span&gt;&lt;span class="p"&gt;,)&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;如果在2018年1月21日运行，将返回&lt;code&gt;20180121&lt;/code&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;__time&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;将返回以毫秒表示的时间&lt;code&gt;1516540541624&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="#functions_list"&gt;【返回函数列表】&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="jexl2"&gt;__jexl2&lt;/h3&gt;

&lt;p&gt;jexl 函数返回执行 &lt;a href="http://commons.apache.org/proper/commons-jexl/"&gt;通用 JEXL 表达式&lt;/a&gt;的结果 。有关 JEXL 表达式的更多信息，请参阅下面的链接。&lt;/p&gt;
&lt;p&gt;jexl2 函数使用通用 JEXL 2&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://commons.apache.org/proper/commons-jexl/reference/syntax.html"&gt;JEXL 语法描述&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://commons.apache.org/proper/commons-jexl/reference/examples.html#Example_Expressions"&gt;JEXL 的例子&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;参数（Parameters）&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性（Attribute）&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th&gt;是否必须&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;表达式&lt;/td&gt;
&lt;td&gt;待执行的表达式，例如：&lt;code&gt;6*(5+2)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;变量名称&lt;/td&gt;
&lt;td&gt;要设置的变量名称&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;以下变量可用于脚本：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;log&lt;/code&gt; - 函数的&lt;a href="https://www.slf4j.org/api/org/slf4j/Logger.html"&gt;记录器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ctx&lt;/code&gt; - &lt;a href="http://jmeter.apache.org/api/org/apache/jmeter/threads/JMeterContext.html"&gt;JMeterContext&lt;/a&gt; 对象&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vars&lt;/code&gt; - &lt;a href="http://jmeter.apache.org/api/org/apache/jmeter/threads/JMeterVariables.html"&gt;JMeterVariables&lt;/a&gt; 对象&lt;/li&gt;
&lt;li&gt;&lt;code&gt;props&lt;/code&gt; - JMeterProperties（类 &lt;a href="https://docs.oracle.com/javase/8/docs/api/java/util/Properties.html"&gt;java.util.Properties&lt;/a&gt;）对象&lt;/li&gt;
&lt;li&gt;&lt;code&gt;threadName&lt;/code&gt; - 包含当前线程名称的字符串&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Sampler&lt;/code&gt; - 当前的&lt;a href="http://jmeter.apache.org/api/org/apache/jmeter/samplers/Sampler.html"&gt;采样器&lt;/a&gt;对象，如果有的话&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sampleResult&lt;/code&gt; - 之前的 &lt;a href="http://jmeter.apache.org/api/org/apache/jmeter/samplers/SampleResult.html"&gt;SampleResult&lt;/a&gt;对象，如果有的话&lt;/li&gt;
&lt;li&gt;&lt;code&gt;OUT&lt;/code&gt; - System.out 例如：&lt;code&gt;OUT.println("message")&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Jexl 也可以创建类和调用其方法，例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Systemclass=log.class.forName(&amp;quot;java.lang.System&amp;quot;);
now=Systemclass.currentTimeMillis();
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;注意，网站上的 Jexl 文档错误地建议使用“&lt;code&gt;div&lt;/code&gt;”做整数除法。实际上“&lt;code&gt;div&lt;/code&gt;”和“&lt;code&gt;/&lt;/code&gt;”都执行普通除法。下面的操作可以得到整数除法的效果：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;i= 5 / 2;
i.intValue(); // 或使用 i.longValue()
&lt;/pre&gt;&lt;/div&gt;


&lt;blockquote&gt;
&lt;p&gt;JMeter 允许表达式包含多个语句。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href="#functions_list"&gt;【返回函数列表】&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="jexl3"&gt;__jexl3&lt;/h3&gt;

&lt;p&gt;jexl 函数返回执行 &lt;a href="http://commons.apache.org/proper/commons-jexl/"&gt;通用 JEXL 表达式&lt;/a&gt;的结果 。有关 JEXL 表达式的更多信息，请参阅下面的链接。&lt;/p&gt;
&lt;p&gt;jexl3 函数使用通用 JEXL 3&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://commons.apache.org/proper/commons-jexl/reference/syntax.html"&gt;JEXL 语法描述&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://commons.apache.org/proper/commons-jexl/reference/examples.html#Example_Expressions"&gt;JEXL 的例子&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;参数（Parameters）&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性（Attribute）&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th&gt;是否必须&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;表达式&lt;/td&gt;
&lt;td&gt;待执行的表达式，例如：&lt;code&gt;6*(5+2)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;变量名称&lt;/td&gt;
&lt;td&gt;要设置的变量名称&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;以下变量可用于脚本：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;log&lt;/code&gt; - 函数的&lt;a href="https://www.slf4j.org/api/org/slf4j/Logger.html"&gt;记录器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ctx&lt;/code&gt; - &lt;a href="http://jmeter.apache.org/api/org/apache/jmeter/threads/JMeterContext.html"&gt;JMeterContext&lt;/a&gt; 对象&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vars&lt;/code&gt; - &lt;a href="http://jmeter.apache.org/api/org/apache/jmeter/threads/JMeterVariables.html"&gt;JMeterVariables&lt;/a&gt; 对象&lt;/li&gt;
&lt;li&gt;&lt;code&gt;props&lt;/code&gt; - JMeterProperties（类 &lt;a href="https://docs.oracle.com/javase/8/docs/api/java/util/Properties.html"&gt;java.util.Properties&lt;/a&gt;）对象&lt;/li&gt;
&lt;li&gt;&lt;code&gt;threadName&lt;/code&gt; - 包含当前线程名称的字符串&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Sampler&lt;/code&gt; - 当前的&lt;a href="http://jmeter.apache.org/api/org/apache/jmeter/samplers/Sampler.html"&gt;采样器&lt;/a&gt;对象，如果有的话&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sampleResult&lt;/code&gt; - 之前的 &lt;a href="http://jmeter.apache.org/api/org/apache/jmeter/samplers/SampleResult.html"&gt;SampleResult&lt;/a&gt; 对象，如果有的话&lt;/li&gt;
&lt;li&gt;&lt;code&gt;OUT&lt;/code&gt; - System.out 例如：&lt;code&gt;OUT.println("message")&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Jexl 也可以创建类和调用其方法，例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Systemclass=log.class.forName(&amp;quot;java.lang.System&amp;quot;);
now=Systemclass.currentTimeMillis();
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;注意，网站上的 Jexl 文档错误地建议使用“&lt;code&gt;div&lt;/code&gt;”做整数除法。实际上“&lt;code&gt;div&lt;/code&gt;”和“&lt;code&gt;/&lt;/code&gt;”都执行普通除法。下面的操作可以得到整数除法的效果：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;i= 5 / 2;
i.intValue(); // 或使用 i.longValue()
&lt;/pre&gt;&lt;/div&gt;


&lt;blockquote&gt;
&lt;p&gt;JMeter 允许表达式包含多个语句。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href="#functions_list"&gt;【返回函数列表】&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="V"&gt;__V&lt;/h3&gt;

&lt;p&gt;V（变量）函数返回执行变量名称表达式的结果。这可以用来执行嵌套变量引用（目前不支持）。&lt;/p&gt;
&lt;p&gt;例如，如果有变量 &lt;code&gt;A1&lt;/code&gt;，&lt;code&gt;A2&lt;/code&gt; 和 &lt;code&gt;N&lt;/code&gt;=&lt;code&gt;1&lt;/code&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;${A1}&lt;/code&gt; - 可以使用&lt;/li&gt;
&lt;li&gt;&lt;code&gt;${A${N}}&lt;/code&gt; - 不起作用（嵌套变量引用）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;${__V(A${N})}&lt;/code&gt; - 可以使用。&lt;code&gt;${N}&lt;/code&gt; 变成 &lt;code&gt;A1&lt;/code&gt;，&lt;code&gt;__V&lt;/code&gt; 函数返回 &lt;code&gt;A1&lt;/code&gt; 的值&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;参数（Parameters）&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性（Attribute）&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th&gt;是否必须&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;变量名称&lt;/td&gt;
&lt;td&gt;待执行的变量&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;默认值&lt;/td&gt;
&lt;td&gt;未找到变量时的默认值，如果它为空且没有找到变量函数，则返回变量名称&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;a href="#functions_list"&gt;【返回函数列表】&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="evalVar"&gt;__evalVar&lt;/h3&gt;

&lt;p&gt;evalVar 函数返回执行存储在变量中的表达式的结果。&lt;/p&gt;
&lt;p&gt;这允许从文件读取字符串，并处理其中的任何变量引用。例如，如果变量“&lt;code&gt;query&lt;/code&gt;”包含“&lt;code&gt;select ${column} from ${table}&lt;/code&gt;”，并且“&lt;code&gt;column&lt;/code&gt;”和“&lt;code&gt;table&lt;/code&gt;”分别包含“&lt;code&gt;name&lt;/code&gt;”和“&lt;code&gt;customers&lt;/code&gt;”，那么 &lt;code&gt;${__evalVar(query)}&lt;/code&gt; 将会执行“&lt;code&gt;select name from customers&lt;/code&gt;”。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参数（Parameters）&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性（Attribute）&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th&gt;是否必须&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;变量名称&lt;/td&gt;
&lt;td&gt;待执行的变量&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;a href="#functions_list"&gt;【返回函数列表】&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="eval"&gt;__eval&lt;/h3&gt;

&lt;p&gt;eval 函数返回执行字符串表达式的结果。&lt;/p&gt;
&lt;p&gt;这允许往变量中存储的字符串中插入变量和函数引用。例如，给定以下变量：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;name&lt;/code&gt;=&lt;code&gt;Smith&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;column&lt;/code&gt;=&lt;code&gt;age&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;table&lt;/code&gt;=&lt;code&gt;birthdays&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SQL&lt;/code&gt;=&lt;code&gt;select ${column} from ${table} where name='${name}'&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;${__eval(${SQL})}&lt;/code&gt; 将执行 “&lt;code&gt;select age from birthdays where name='Smith'&lt;/code&gt;”&lt;/p&gt;
&lt;p&gt;这可以与 CSV 数据集结合使用，例如在数据文件中定义 SQL 语句和值。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参数（Parameters）&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性（Attribute）&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th&gt;是否必须&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;变量名称&lt;/td&gt;
&lt;td&gt;要执行的变量&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;a href="#functions_list"&gt;【返回函数列表】&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="char"&gt;__char&lt;/h3&gt;

&lt;p&gt;char 函数将一个数字转换成 Unicode 字符。另外请参阅下面的&lt;code&gt;__unescape()&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;这允许将任意字符值添加到字段中。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参数（Parameters）&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性（Attribute）&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th&gt;是否必须&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Unicode字符编码（十进制或十六进制数）&lt;/td&gt;
&lt;td&gt;十进制数（或十六进制数前缀为 &lt;code&gt;0x&lt;/code&gt;，或八进制前缀为 &lt;code&gt;0&lt;/code&gt;）将被转换为 Unicode 字符。&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;例子：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;${__char(13,10)}&lt;/code&gt; = &lt;code&gt;${__char(0xD,0xA)}&lt;/code&gt; = &lt;code&gt;${__char(015,012)}&lt;/code&gt; = &lt;code&gt;CRLF&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;${__char(165)}&lt;/code&gt; = &lt;code&gt;¥&lt;/code&gt; (元)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href="#functions_list"&gt;【返回函数列表】&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="unescape"&gt;__unescape&lt;/h3&gt;

&lt;p&gt;unescape 函数将返回将 Java 转义过的字符串反转义的结果。另外请参阅上面的&lt;code&gt;__char()&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;这允许添加字符到字段，否则通过 GUI 定义是非常困难的（或不可能的）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参数（Parameters）&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性（Attribute）&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th&gt;是否必须&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;反转义的字符串&lt;/td&gt;
&lt;td&gt;待反转义的字符串&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;例子：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;${__unescape(\r\n)}&lt;/code&gt; = &lt;code&gt;CRLF&lt;/code&gt; &lt;/li&gt;
&lt;li&gt;&lt;code&gt;${__unescape(1\t2)}&lt;/code&gt; = &lt;code&gt;1&lt;/code&gt;[tab]&lt;code&gt;2&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href="#functions_list"&gt;【返回函数列表】&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="unescapeHtml"&gt;__unescapeHtml&lt;/h3&gt;

&lt;p&gt;函数将包含 HTML 实体的字符串反转义为包含对应于转义符的实际 Unicode 字符的字符串。支持 HTML 4.0 实体。&lt;/p&gt;
&lt;p&gt;例如，字符串&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;__unescapeHtml&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Fran&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;ccedil&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="n"&gt;ais&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;将返回&lt;code&gt;&amp;lt;Français&amp;gt;&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;如果某个实体无法识别，则将其保留，并逐字地插入结果字符串中。例如 &lt;code&gt;${__unescapeHtml(&amp;amp;gt;&amp;amp;zzzz;x)}&lt;/code&gt; 将返回 &lt;code&gt;"&amp;gt;&amp;amp;zzzz;x"&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;使用 Commons Lang 的 &lt;code&gt;StringEscapeUtils#unescapeHtml(String)&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参数（Parameters）&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性（Attribute）&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th&gt;是否必须&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;反转义的字符串&lt;/td&gt;
&lt;td&gt;待反转义的字符串&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;a href="#functions_list"&gt;【返回函数列表】&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="escapeHtml"&gt;__escapeHtml&lt;/h3&gt;

&lt;p&gt;函数用于转义使用 HTML 实体的字符串。支持HTML 4.0 实体。&lt;/p&gt;
&lt;p&gt;例如，&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;__escapeHtml&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;bread&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;butter&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;将返回 &lt;code&gt;&amp;amp;quot;bread&amp;amp;quot; &amp;amp;amp; &amp;amp;quot;butter&amp;amp;quot;&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;使用 Commons Lang 的 &lt;code&gt;StringEscapeUtils#escapeHtml(String)&lt;/code&gt;。
&lt;strong&gt;参数（Parameters）&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性（Attribute）&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th&gt;是否必须&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;转义的字符串&lt;/td&gt;
&lt;td&gt;待转义的字符串&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;a href="#functions_list"&gt;【返回函数列表】&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="urldecode"&gt;__urldecode&lt;/h3&gt;

&lt;p&gt;函数用来解码 &lt;code&gt;application/x-www-form-urlencoded&lt;/code&gt; 字符串，注意：使用 UTF-8 作为编码方案。&lt;/p&gt;
&lt;p&gt;例如，字符串&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;__urldecode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Word&lt;/span&gt;&lt;span class="o"&gt;+%&lt;/span&gt;&lt;span class="mi"&gt;22&lt;/span&gt;&lt;span class="n"&gt;school&lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="mi"&gt;22&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="ow"&gt;is&lt;/span&gt;&lt;span class="o"&gt;+%&lt;/span&gt;&lt;span class="mi"&gt;22&lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="n"&gt;C3&lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="n"&gt;A9cole&lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="mi"&gt;22&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="ow"&gt;in&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;french&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;将返回 &lt;code&gt;Word "school" is "école" in french&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;使用 Java 类 &lt;a href="https://docs.oracle.com/javase/7/docs/api/java/net/URLDecoder.html"&gt;URLDecoder&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参数（Parameters）&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性（Attribute）&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th&gt;是否必须&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;要解码的字符串&lt;/td&gt;
&lt;td&gt;待解码的带有 URL 编码字符的字符串&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;a href="#functions_list"&gt;【返回函数列表】&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="urlencode"&gt;__urlencode&lt;/h3&gt;

&lt;p&gt;函数用来将字符串转码成 &lt;code&gt;application/x-www-form-urlencoded&lt;/code&gt; 字符串。&lt;/p&gt;
&lt;p&gt;例如，字符串&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;__urlencode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Word&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;school&amp;quot;&lt;/span&gt; &lt;span class="ow"&gt;is&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;école&amp;quot;&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;french&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;将返回 &lt;code&gt;Word+%22school%22+is+%22%C3%A9cole%22+in+french&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;使用 Java 类 &lt;a href="https://docs.oracle.com/javase/7/docs/api/java/net/URLDecoder.html"&gt;URLDecoder&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参数（Parameters）&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性（Attribute）&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th&gt;是否必须&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;要转码的字符串&lt;/td&gt;
&lt;td&gt;待转码的使用 URL 编码字符的字符串&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;a href="#functions_list"&gt;【返回函数列表】&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="FileToString"&gt;__FileToString&lt;/h3&gt;

&lt;p&gt;FileToString 函数可以用来读取整个文件。每次调用时读取整个文件。&lt;/p&gt;
&lt;p&gt;如果打开或读取文件时发生错误，函数会返回字符串“&lt;code&gt;**ERR**&lt;/code&gt;”&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参数（Parameters）&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性（Attribute）&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th&gt;是否必须&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;文件名称&lt;/td&gt;
&lt;td&gt;文件名称的路径（路径可以是相对于 JMeter 启动目录的相对路径）&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;文件编码，如果不是平台默认的&lt;/td&gt;
&lt;td&gt;用于读取文件的编码。如果未指定，则使用平台默认编码方式&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;引用名称&lt;/td&gt;
&lt;td&gt;引用名称 - &lt;code&gt;refName&lt;/code&gt; - 用于重用由此函数创建的值。存储的值的格式为 &lt;code&gt;${refName}&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;每次执行函数时都会解析文件名，编码和引用名称参数。&lt;/p&gt;
&lt;p&gt;&lt;a href="#functions_list"&gt;【返回函数列表】&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="samplerName"&gt;__samplerName&lt;/h3&gt;

&lt;p&gt;samplerName 函数返回当前采样器的名称（即标签）。&lt;/p&gt;
&lt;p&gt;该函数在没有关联采样器的测试元件中不起作用。例如测试计划。配置元件也没有关联的采样器。但是一些配置元件会被采样器直接引用，例如 HTTP 信息头管理器和 Http Cookie 管理器，这种情况下，函数在 Http 采样器的上下文中被解析。前置处理器，后置处理器和断言总是有一个关联的采样器。&lt;/p&gt;
&lt;p&gt;例子：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;__samplerName&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;参数（Parameters）&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性（Attribute）&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th&gt;是否必须&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;变量名称&lt;/td&gt;
&lt;td&gt;引用名称 - &lt;code&gt;refName&lt;/code&gt; - 用于重用由此函数创建的值。存储的值的格式为 &lt;code&gt;${refName}&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;a href="#functions_list"&gt;【返回函数列表】&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="TestPlanName"&gt;__TestPlanName&lt;/h3&gt;

&lt;p&gt;TestPlanName 函数返回当前测试计划的名称（可用于内部计划以掌握调用的测试计划的名称）。&lt;/p&gt;
&lt;p&gt;例子：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;__TestPlanName&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;将返回测试计划的文件名称，例如，如果计划在一个名为 Demo.jmx 的文件中，它将返回“&lt;code&gt;Demo.jmx&lt;/code&gt;”。&lt;/p&gt;
&lt;p&gt;&lt;a href="#functions_list"&gt;【返回函数列表】&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="escapeOroRegexpChars"&gt;__escapeOroRegexpChars&lt;/h3&gt;

&lt;p&gt;函数用于转义 ORO 正则表达式元字符，相当于 Java 正则表达式引擎中的 &lt;code&gt;\Q&lt;/code&gt; &lt;code&gt;\E&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;__escapeOroRegexpChars&lt;/span&gt;&lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="o"&gt;^&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;].+?,)&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;将返回 &lt;code&gt;\[\^\"\]\.\+\?&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;使用 ORO 的 &lt;code&gt;Perl5Compiler#quotemeta(String)&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参数（Parameters）&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性（Attribute）&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th&gt;是否必须&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;要转义的字符串&lt;/td&gt;
&lt;td&gt;待转义的字符串&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;变量名称&lt;/td&gt;
&lt;td&gt;引用名称 - &lt;code&gt;refName&lt;/code&gt; - 用于重用由此函数创建的值。存储的值的格式为 &lt;code&gt;${refName}&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;a href="#functions_list"&gt;【返回函数列表】&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="escapeXml"&gt;__escapeXml&lt;/h3&gt;

&lt;p&gt;函数用来转义使用 XML 1.0 实体的字符串中的字符。&lt;/p&gt;
&lt;p&gt;例如，&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;__escapeXml&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;bread&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;butter&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;将返回 &lt;code&gt;&amp;amp;quot;bread&amp;amp;quot; &amp;amp;amp; &amp;amp;apos;butter&amp;amp;apos;&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;使用 Commons Lang 的 &lt;code&gt;StringEscapeUtils#escapeXml10(String)&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参数（Parameters）&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性（Attribute）&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th&gt;是否必须&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;要转义的字符串&lt;/td&gt;
&lt;td&gt;待转义的字符串&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;a href="#functions_list"&gt;【返回函数列表】&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="timeShift"&gt;__timeShift&lt;/h3&gt;

&lt;p&gt;timeShift 函数返回指定格式的日期，并加上指定的秒数，分钟数，小时数，天数或月数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参数（Parameters）&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性（Attribute）&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th&gt;是否必须&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;格式&lt;/td&gt;
&lt;td&gt;要传递给 DateTimeFormatter 的格式。请参阅 &lt;a href="https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html"&gt;DateTimeFormatter&lt;/a&gt; 如果省略，则函数使用纪元时间格式&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;日期转换&lt;/td&gt;
&lt;td&gt;以第一个参数“格式”设置的格式转换指定日期，如果省略，则日期默认为现在&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;值转换&lt;/td&gt;
&lt;td&gt;根据文本表示的持续时间（如PnDTnHnMn.nS）转换成指定的秒数，分钟数，小时数或天数。请参阅&lt;a href="https://docs.oracle.com/javase/8/docs/api/java/time/Duration.html#parse-java.lang.CharSequence"&gt;https://docs.oracle.com/javase/8/docs/api/java/time/Duration.html#parse-java.lang.CharSequence&lt;/a&gt;&lt;br/&gt;&lt;ul&gt;&lt;li&gt;&lt;code&gt;PT20.345S&lt;/code&gt; 解析为 20.345 秒&lt;/li&gt;&lt;li&gt;&lt;code&gt;PT15M&lt;/code&gt; 解析为 15 分钟&lt;/li&gt;&lt;li&gt;&lt;code&gt;PT10H&lt;/code&gt; 解析为 10 个小时&lt;/li&gt;&lt;li&gt;&lt;code&gt;P2D&lt;/code&gt; 解析为 2 天&lt;/li&gt;&lt;li&gt;&lt;code&gt;P6H3M&lt;/code&gt; 解析为 6小时3分钟&lt;/li&gt;&lt;/ul&gt;&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;用于格式的区域设置&lt;/td&gt;
&lt;td&gt;语言环境的字符串格式。语言代码必须是小写。国家代码必须大写。分隔符必须是下划线，例如 &lt;code&gt;en_EN&lt;/code&gt;。请参阅 &lt;a href="http://www.oracle.com/technetwork/java/javase/javase7locales-334809.html"&gt;http://www.oracle.com/technetwork/java/javase/javase7locales-334809.html&lt;/a&gt;。如果省略，则默认情况下该函数使用 Apache JMeter 当前语言环境。&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;变量名称&lt;/td&gt;
&lt;td&gt;要设置的变量名称&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;例子：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;__timeShift&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;dd&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;MM&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;yyyy&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;21&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="mo"&gt;01&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="mi"&gt;2018&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;P2D&lt;/span&gt;&lt;span class="p"&gt;,,)&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;返回&lt;code&gt;23/01/2018&lt;/code&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;__timeShift&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;dd&lt;/span&gt; &lt;span class="n"&gt;MMMM&lt;/span&gt; &lt;span class="n"&gt;yyyy&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;21&lt;/span&gt; &lt;span class="n"&gt;février&lt;/span&gt; &lt;span class="mi"&gt;2018&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;P2D&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;fr_FR&lt;/span&gt;&lt;span class="p"&gt;,)&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;返回&lt;code&gt;23 février 2018&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="#functions_list"&gt;【返回函数列表】&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="digest "&gt;__digest &lt;/h3&gt;

&lt;p&gt;digest 函数返回特定的哈希算法的加密后的值，哈希算法有多种，名称为大写，可带 salt。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参数（Parameters）&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性（Attribute）&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th&gt;是否必须&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;算法&lt;/td&gt;
&lt;td&gt;用来加密的算法。可用的算法请参阅 &lt;a href="https://docs.oracle.com/javase/8/docs/technotes/guides/security/StandardNames.html"&gt;StandardNames&lt;/a&gt; 的 MessageDigest  &lt;ul&gt;&lt;li&gt;MD2&lt;/li&gt;&lt;li&gt;MD5&lt;/li&gt;&lt;li&gt;SHA-1&lt;/li&gt;&lt;li&gt;SHA-224&lt;/li&gt;&lt;li&gt;SHA-256&lt;/li&gt;&lt;li&gt;SHA-384&lt;/li&gt;&lt;li&gt;SHA-512&lt;/li&gt;&lt;/ul&gt;&lt;blockquote&gt;&lt;code&gt;要添加的 salt&lt;/code&gt;和&lt;code&gt;要编码的字符串&lt;/code&gt;中是要考虑空格的&lt;/blockquote&gt;&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;要编码的字符串&lt;/td&gt;
&lt;td&gt;将被加密的字符串&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;要添加的 salt&lt;/td&gt;
&lt;td&gt;添加到字符串的 salt（加在字符串之后）&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;大写值&lt;/td&gt;
&lt;td&gt;默认返回值为小写。当为true时返回值大写。&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;变量名称&lt;/td&gt;
&lt;td&gt;要设置的变量名称&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;例子：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;__digest&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;MD5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;Errare&lt;/span&gt; &lt;span class="n"&gt;humanum&lt;/span&gt; &lt;span class="n"&gt;est&lt;/span&gt;&lt;span class="p"&gt;,,,)&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;返回&lt;code&gt;c49f00b92667a35c63708933384dad52&lt;/code&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;__digest&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;SHA&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;256&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;Felix&lt;/span&gt; &lt;span class="n"&gt;qui&lt;/span&gt; &lt;span class="n"&gt;potuit&lt;/span&gt; &lt;span class="n"&gt;rerum&lt;/span&gt; &lt;span class="n"&gt;cognoscere&lt;/span&gt; &lt;span class="n"&gt;causas&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;mysalt&lt;/span&gt;&lt;span class="p"&gt;,,)&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;返回&lt;code&gt;a3bc6900fe2b2fc5fa8a601a4a84e27a079bf2c581d485009bc5c00516729ac7&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="#functions_list"&gt;【返回函数列表】&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="dateTimeConvert"&gt;__dateTimeConvert&lt;/h3&gt;

&lt;p&gt;dateTimeConvert 函数将日期从源格式转换成目标格式并将结果储存到变量名中。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参数（Parameters）&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性（Attribute）&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th&gt;是否必须&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;日期字符串&lt;/td&gt;
&lt;td&gt;要从源格式转换到目标格式的日期字符串。如果源日期格式为空，将使用纪元时间格式的日期。&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;源日期格式&lt;/td&gt;
&lt;td&gt;原始日期格式。如果为空，则日期字符串字段必须是纪元时间格式。&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;目标日期格式&lt;/td&gt;
&lt;td&gt;新的日期格式&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;变量名称&lt;/td&gt;
&lt;td&gt;要设置的变量名称&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;例子：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;__dateTimeConvert&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mo"&gt;0121201&lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;MMddyyyy&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;dd&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;MM&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;yyyy&lt;/span&gt;&lt;span class="p"&gt;,)&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;返回&lt;code&gt;21/01/2018&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;使用纪元时间：1526574881000，&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;__digest&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;SHA&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;256&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;Felix&lt;/span&gt; &lt;span class="n"&gt;qui&lt;/span&gt; &lt;span class="n"&gt;potuit&lt;/span&gt; &lt;span class="n"&gt;rerum&lt;/span&gt; &lt;span class="n"&gt;cognoscere&lt;/span&gt; &lt;span class="n"&gt;causas&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;mysalt&lt;/span&gt;&lt;span class="p"&gt;,,)&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;以UTC时间（Duser.timezone=GMT）返回&lt;code&gt;17/05/2018 16:34&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="#functions_list"&gt;【返回函数列表】&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="isPropDefined"&gt;__isPropDefined&lt;/h3&gt;

&lt;p&gt;isPropDefined 函数当属性存在时返回 true，不存在时返回 false。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参数（Parameters）&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性（Attribute）&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th&gt;是否必须&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;属性名称&lt;/td&gt;
&lt;td&gt;要检查是否定义的属性名称&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;例子：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;__isPropDefined&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;START&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;HMS&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;将返回&lt;code&gt;true&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="#functions_list"&gt;【返回函数列表】&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="isVarDefined"&gt;__isVarDefined&lt;/h3&gt;

&lt;p&gt;isVarDefined 函数当变量存在时返回 true，不存在时返回 false。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参数（Parameters）&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性（Attribute）&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th&gt;是否必须&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;变量名称&lt;/td&gt;
&lt;td&gt;要检查是否定义的变量名称&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;例子：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;__isVarDefined&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;JMeterThread&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;last_sample_ok&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;将返回&lt;code&gt;true&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="#functions_list"&gt;【返回函数列表】&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="changeCase"&gt;__changeCase&lt;/h3&gt;

&lt;p&gt;changeCase 函数返回大小写经过特定模式变更后的字符串值。结果储存在 JMeter 变量中。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参数（Parameters）&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性（Attribute）&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th&gt;是否必须&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;待变更大小写的字符串&lt;/td&gt;
&lt;td&gt;将变更大小写模式的字符串&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;大小写变更模式&lt;/td&gt;
&lt;td&gt;改变大小写的模式，例如对&lt;code&gt;ab-CD eF&lt;/code&gt;：&lt;br/&gt;&lt;ul&gt;&lt;li&gt;&lt;code&gt;UPPER&lt;/code&gt;模式返回 AB-CD EF &lt;/li&gt;&lt;li&gt;&lt;code&gt;LOWER&lt;/code&gt;模式返回 ab-cd ed &lt;/li&gt;&lt;li&gt;&lt;code&gt;CAPITALIZE&lt;/code&gt;模式返回 Ab-CD eF &lt;/li&gt;&lt;/ul&gt;&lt;blockquote&gt;变更模式名称不区分大小写&lt;/blockquote&gt;&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;变量名称&lt;/td&gt;
&lt;td&gt;要检查是否定义的变量名称&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;例子：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;__changeCase&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Avaro&lt;/span&gt; &lt;span class="n"&gt;omnia&lt;/span&gt; &lt;span class="n"&gt;desunt&lt;/span&gt;\&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;inopi&lt;/span&gt; &lt;span class="n"&gt;pauca&lt;/span&gt;\&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;sapienti&lt;/span&gt; &lt;span class="n"&gt;nihil&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;UPPER&lt;/span&gt;&lt;span class="p"&gt;,)&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;将返回&lt;code&gt;AVARO OMNIA DESUNT, INOPI PAUCA, SAPIENTI NIHIL&lt;/code&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;__changeCase&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;LABOR&lt;/span&gt; &lt;span class="n"&gt;OMNIA&lt;/span&gt; &lt;span class="n"&gt;VINCIT&lt;/span&gt; &lt;span class="n"&gt;IMPROBUS&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;LOWER&lt;/span&gt;&lt;span class="p"&gt;,)&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;将返回&lt;code&gt;labor omnia vincit improbus&lt;/code&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;__changeCase&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;omnibus&lt;/span&gt; &lt;span class="n"&gt;viis&lt;/span&gt; &lt;span class="n"&gt;romam&lt;/span&gt; &lt;span class="n"&gt;pervenitur&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;CAPITALIZE&lt;/span&gt;&lt;span class="p"&gt;,)&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;将返回&lt;code&gt;Omnibus viis romam pervenitur&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="#functions_list"&gt;【返回函数列表】&lt;/a&gt;&lt;/p&gt;
&lt;h2 id="206"&gt;20.6 预定义变量&lt;/h2&gt;
&lt;p&gt;大多数变量都是通过调用函数或者用户定义的变量等测试元件来设置的；在这种情况下，用户对所使用的变量名称有完整的控制权。但是有些变量是 JMeter 内部定义的。这些在下面列出：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;COOKIE_cookiename&lt;/code&gt; - 包含 cookie 的值（请参阅 &lt;a href="http://jmeter.apache.org/usermanual/component_reference.html#HTTP_Cookie_Manager"&gt;HTTP Cookie 管理器&lt;/a&gt;）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;JMeterThread.last_sample_ok&lt;/code&gt; - 不管最后一个采样是否可用 - &lt;code&gt;true/false&lt;/code&gt;。注意：它会在后置处理器和断言运行后更新。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;START&lt;/code&gt; 变量（参见下一节）&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="207"&gt;20.7 预定义属性&lt;/h2&gt;
&lt;p&gt;JMeter 属性集是在 JMeter 启动时通过系统属性定义来初始化的；附加的 JMeter 属性在 &lt;code&gt;jmeter.properties&lt;/code&gt;，&lt;code&gt;user.properties&lt;/code&gt; 或命令行中定义。&lt;/p&gt;
&lt;p&gt;一些内置属性由 JMeter 定义。这些在下面列出。为方便起见，&lt;code&gt;START&lt;/code&gt; 属性也被复制到具有相同名称的变量中。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;START.MS&lt;/code&gt; - 以毫秒为单位的 JMeter 启动时间&lt;/li&gt;
&lt;li&gt;&lt;code&gt;START.YMD&lt;/code&gt; - 格式为 &lt;code&gt;yyyyMMdd&lt;/code&gt; 的 JMeter 启动日期&lt;/li&gt;
&lt;li&gt;&lt;code&gt;START.HMS&lt;/code&gt; - 格式为 &lt;code&gt;HHmmss&lt;/code&gt; 的 JMeter 启动时间&lt;/li&gt;
&lt;li&gt;&lt;code&gt;TESTSTART.MS&lt;/code&gt; - 以毫秒为单位的测试启动时间&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;请注意，&lt;code&gt;START&lt;/code&gt; 变量/属性表示的是 JMeter 启动时间，而不是测试启动时间。它们主要用于文件名等地方。 &lt;/p&gt;</content><category term="JMeter"></category><category term="Documentation"></category><category term="Translation"></category></entry><entry><title>JMeter文档翻译之21-正则表达式</title><link href="https://jlhxxxx.github.io/jmeter-doc-cn-21.html" rel="alternate"></link><published>2019-05-06T00:00:00+08:00</published><updated>2019-05-06T00:00:00+08:00</updated><author><name>Aman</name></author><id>tag:jlhxxxx.github.io,2019-05-06:/jmeter-doc-cn-21.html</id><summary type="html">&lt;p&gt;英文文档地址：&lt;a href="http://jmeter.apache.org/usermanual/functions.html"&gt;http://jmeter.apache.org/usermanual/functions.html&lt;/a&gt;&lt;/p&gt;
&lt;h2 id="211"&gt;21.1 概述&lt;/h2&gt;
&lt;p&gt;JMeter 包含模式匹配软件 &lt;a href="http://attic.apache.org/projects/jakarta-oro.html"&gt;Apache Jakarta ORO&lt;/a&gt; 。 
在 Jakarta 网站上有一些相关文档，例如：&lt;a href="http://archimedes.fas.harvard.edu/scrapbook/jakarta-oro-2.0.6/docs/api/org/apache/oro/text/regex/package-summary.html"&gt;模式匹配字符摘要&lt;/a&gt;。  &lt;/p&gt;
&lt;p&gt;在 &lt;a href="http://www.savarese.org/oro/docs/OROMatcher/index.html"&gt;OROMatcher 用户指南&lt;/a&gt;上还有关于该产品旧版本的文档 ，也许会有些用处。  &lt;/p&gt;
&lt;p&gt;模式匹配与 Perl 中的模式匹配非常类似。Perl 的完整安装会包含大量关于正则表达式的文档——查找 &lt;code&gt;perlrequick&lt;/code&gt;， &lt;code&gt;perlretut&lt;/code&gt;， &lt;code&gt;perlre&lt;/code&gt; 和 &lt;code&gt;perlreref&lt;/code&gt;。  &lt;/p&gt;
&lt;p&gt;有必要强调“包含（contains）”和“匹配（matches）”之间的区别，它们被用在响应断言（Response Assertion）测试元件上： &lt;/p&gt;
&lt;p&gt;"&lt;em&gt;包含（contains …&lt;/em&gt;&lt;/p&gt;</summary><content type="html">&lt;p&gt;英文文档地址：&lt;a href="http://jmeter.apache.org/usermanual/functions.html"&gt;http://jmeter.apache.org/usermanual/functions.html&lt;/a&gt;&lt;/p&gt;
&lt;h2 id="211"&gt;21.1 概述&lt;/h2&gt;
&lt;p&gt;JMeter 包含模式匹配软件 &lt;a href="http://attic.apache.org/projects/jakarta-oro.html"&gt;Apache Jakarta ORO&lt;/a&gt; 。 
在 Jakarta 网站上有一些相关文档，例如：&lt;a href="http://archimedes.fas.harvard.edu/scrapbook/jakarta-oro-2.0.6/docs/api/org/apache/oro/text/regex/package-summary.html"&gt;模式匹配字符摘要&lt;/a&gt;。  &lt;/p&gt;
&lt;p&gt;在 &lt;a href="http://www.savarese.org/oro/docs/OROMatcher/index.html"&gt;OROMatcher 用户指南&lt;/a&gt;上还有关于该产品旧版本的文档 ，也许会有些用处。  &lt;/p&gt;
&lt;p&gt;模式匹配与 Perl 中的模式匹配非常类似。Perl 的完整安装会包含大量关于正则表达式的文档——查找 &lt;code&gt;perlrequick&lt;/code&gt;， &lt;code&gt;perlretut&lt;/code&gt;， &lt;code&gt;perlre&lt;/code&gt; 和 &lt;code&gt;perlreref&lt;/code&gt;。  &lt;/p&gt;
&lt;p&gt;有必要强调“包含（contains）”和“匹配（matches）”之间的区别，它们被用在响应断言（Response Assertion）测试元件上： &lt;/p&gt;
&lt;p&gt;"&lt;em&gt;包含（contains）&lt;/em&gt;" &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;意味着正则表达式至少与目标的某个部分相匹配，所以 '&lt;code&gt;alphabet&lt;/code&gt;' “包含” '&lt;code&gt;ph.b.&lt;/code&gt;'，因为正则表达式匹配子字符串 '&lt;code&gt;phabe&lt;/code&gt;'。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;"&lt;em&gt;匹配（matches）&lt;/em&gt;" &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;意味着正则表达式匹配整个目标。所以 '&lt;code&gt;alphabet&lt;/code&gt;' 和 '&lt;code&gt;al.*t&lt;/code&gt;' 是“匹配”的 。 &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这种情况下，它相当于将正则表达式封装在 &lt;code&gt;^&lt;/code&gt; 和 &lt;code&gt;$&lt;/code&gt; 中，即 '&lt;code&gt;^al.*t$&lt;/code&gt;'。  &lt;/p&gt;
&lt;p&gt;然而，情况并非总是如此。例如，正则表达式 '&lt;code&gt;alp|.lp.*&lt;/code&gt;' “包含”于 '&lt;code&gt;alphabet&lt;/code&gt;'，但并不“匹配” '&lt;code&gt;alphabet&lt;/code&gt;'。  &lt;/p&gt;
&lt;p&gt;这是为什么？原因是当模式匹配器在 '&lt;code&gt;alphabet&lt;/code&gt;' 中找到序列 '&lt;code&gt;alp&lt;/code&gt;' 时，它将停止尝试其他组合——而 '&lt;code&gt;alp&lt;/code&gt;' 与 '&lt;code&gt;alphabet&lt;/code&gt;' 不同，它不包含 '&lt;code&gt;habet&lt;/code&gt;'。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;不同于 Perl，没有必要将正则表达式用 // 封装。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;那么如果没有尾部的 &lt;code&gt;/&lt;/code&gt;，该如何使用 &lt;code&gt;ismx&lt;/code&gt; 等修饰符呢？解决方法是使用扩展的正则表达式，即 &lt;code&gt;/abc/i&lt;/code&gt; 变成 &lt;code&gt;(?i)abc&lt;/code&gt;。请参阅下面的&lt;a href="#215-修饰符的放置"&gt;修饰符的放置&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id="212"&gt;21.2 举例&lt;/h2&gt;
&lt;h3 id="_1"&gt;提取单个字符串&lt;/h3&gt;
&lt;p&gt;假设您想要匹配网页的以下部分： 
&lt;code&gt;name="file" value="readme.txt"&amp;gt;&lt;/code&gt; 
并且要提取 &lt;code&gt;readme.txt&lt;/code&gt;。 
一个符合的正则表达式： 
&lt;code&gt;name="file "value ="(.+?)"&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;上面的特殊字符是： &lt;/p&gt;
&lt;p&gt;&lt;code&gt;(&lt;/code&gt; 和 &lt;code&gt;)&lt;/code&gt; &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;这些包围匹配字符串的部分将被返回  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;.&lt;/code&gt; &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;匹配任何字符&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;+&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一次或多次&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;？&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不要贪婪，即在第一次匹配成功时停止 &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;注意：如果没有 &lt;code&gt;？&lt;/code&gt;，&lt;code&gt;.+&lt;/code&gt; 在第一个 &lt;code&gt;"&amp;gt;&lt;/code&gt; 后会继续寻找，直到最后一个 &lt;code&gt;"&amp;gt;&lt;/code&gt; ——这可能不是我们所期望的。 &lt;/p&gt;
&lt;p&gt;注意：虽然上面的正则表达式可用，但使用下面的表达式会更有效率：&lt;br&gt;
&lt;code&gt;name ="file" value ="([^"]+)"&amp;gt;&lt;/code&gt; &lt;br&gt;
其中 &lt;code&gt;[^"]&lt;/code&gt; ——表示匹配任意（除了 &lt;code&gt;"&lt;/code&gt; ），在这种情况下，匹配引擎只要找到第一个 &lt;code&gt;"&lt;/code&gt; 就可以停止查找，而在之前的情况下，引擎必须检查它是否已经找到 &lt;code&gt;"&amp;gt;&lt;/code&gt; 而不是 &lt;code&gt;" &amp;gt;&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id="_2"&gt;提取多个字符串&lt;/h3&gt;
&lt;p&gt;假设你想匹配一个网页的以下部分：&lt;br&gt;
&lt;code&gt;name ="file.name" value ="readme.txt"&lt;/code&gt;，你想提取 &lt;code&gt;file.name&lt;/code&gt; 和 &lt;code&gt;readme.txt&lt;/code&gt;。&lt;br&gt;
符合的正则表达式：&lt;br&gt;
&lt;code&gt;name="([^"]+)" value="([^"]+)"&lt;/code&gt;&lt;br&gt;
这将创建 2 个匹配组，可以在 JMeter 正则表达式提取器（Regular Expression Extractor）模板（Template）中用 &lt;code&gt;$1$&lt;/code&gt; 和 &lt;code&gt;$2$&lt;/code&gt; 来引用。&lt;/p&gt;
&lt;p&gt;JMeter 正则表达式提取器将组的值保存在指定变量中。&lt;/p&gt;
&lt;p&gt;例如，假设：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;引用名称：&lt;code&gt;MYREF&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;正则表达式：&lt;code&gt;name="(.+?)" value="(.+?)"&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;模板：&lt;code&gt;$1$$2$&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;不要将正则表达式放在 / / 中&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;以下变量将被设置：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;MYREF&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;file.namereadme.txt&lt;/code&gt;  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;MYREF_g0&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;name="file.name" value="readme.txt"&lt;/code&gt;  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;MYREF_g1&lt;/code&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;file.name&lt;/code&gt;  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;MYREF_g2&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;readme.txt&lt;/code&gt;  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这些变量可以在 JMeter 后续的测试计划中引用，形如 &lt;code&gt;${MYREF}&lt;/code&gt;，&lt;code&gt;${MYREF_g1}&lt;/code&gt; 等。&lt;/p&gt;
&lt;h2 id="213"&gt;21.3 行模式&lt;/h2&gt;
&lt;p&gt;模式匹配可以有不同的表现方式，这取决于多行和单行修饰符的设置。注意单行和多行操作符之间没有任何关系，它们可以单独指定。&lt;/p&gt;
&lt;h3 id="_3"&gt;单行模式&lt;/h3&gt;
&lt;p&gt;单行模式只影响元字符 '&lt;code&gt;.&lt;/code&gt;' 的解释。&lt;/p&gt;
&lt;p&gt;默认情况下， '&lt;code&gt;.&lt;/code&gt;' 匹配除换行符之外的任何字符。在单行模式下, '&lt;code&gt;.&lt;/code&gt;' 也匹配换行符。&lt;/p&gt;
&lt;h3 id="_4"&gt;多行模式&lt;/h3&gt;
&lt;p&gt;多行模式只影响元字符 '&lt;code&gt;^&lt;/code&gt;' 和 '&lt;code&gt;$&lt;/code&gt;' 的解释。&lt;/p&gt;
&lt;p&gt;默认情况下 '&lt;code&gt;^&lt;/code&gt;' 和 '&lt;code&gt;$&lt;/code&gt;' 只匹配字符串的开头和结尾。在多行模式下， '&lt;code&gt;^&lt;/code&gt;' 匹配每一行的开头， '&lt;code&gt;$&lt;/code&gt;' 匹配每一行的结尾。&lt;/p&gt;
&lt;h2 id="214"&gt;21.4 元字符&lt;/h2&gt;
&lt;p&gt;正则表达式使用特定字符作为元字符——这些字符对匹配（RE）引擎有特殊的意义。这些字符必须用 &lt;code&gt;\&lt;/code&gt;（反斜杠）前缀来转义，转义之后才能将它们视为普通字符。以下是元字符及其含义的列表（如有疑问，请查阅 ORO 文档）。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;(&lt;/code&gt; 和 &lt;code&gt;）&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;分组&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;[&lt;/code&gt; 和 &lt;code&gt;]&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;字符集合&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;{&lt;/code&gt; 和 &lt;code&gt;}&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;重复&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;*&lt;/code&gt;，&lt;code&gt;+&lt;/code&gt; 和 &lt;code&gt;？&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;重复&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;.&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通配符&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;\&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;转义字符&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;|&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;选择符&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;^&lt;/code&gt; 和 &lt;code&gt;$&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;字符串或行的开始和结束&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;请注意，ORO 不支持关键字 \Q 和 \E。[在其他的 RE 引擎中，这些可以用来引用 RE 的一部分，使元字符代表它们自己。]可以使用函数来执行相同的操作，请参阅 &lt;a href="http://jmeter.apache.org/usermanual/functions.html#__escapeOroRegexpChars"&gt;&lt;code&gt;${__escapeOroRegexpChars(valueToEscape)}&lt;/code&gt;&lt;/a&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;ORO 支持以下 Perl5 扩展正则表达式。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;(?#text)&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;内嵌注释，可以使 &lt;code&gt;text&lt;/code&gt; 内容被忽略。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;(?:regexp)&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;像"&lt;code&gt;()&lt;/code&gt;"一样获取匹配，但并不保存匹配结果。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;(?=regexp)&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;零长度正向肯定断言。例如，&lt;code&gt;\w+(?=\s)&lt;/code&gt; 匹配一个后跟空格的单词，匹配结果不包含空格。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;(?!regexp)&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;零长度正向否定断言。例如，&lt;code&gt;foo(?!bar)&lt;/code&gt; 匹配任何 '&lt;code&gt;foo&lt;/code&gt;' 后面不跟 '&lt;code&gt;bar&lt;/code&gt;' 的结果。请注意，这是一个零长度断言，这意味着 &lt;code&gt;a(?!b)d&lt;/code&gt; 匹配 &lt;code&gt;ad&lt;/code&gt;，因为 &lt;code&gt;a&lt;/code&gt; 后面是一个非 &lt;code&gt;b&lt;/code&gt; 字符（&lt;code&gt;d&lt;/code&gt;），而 &lt;code&gt;d&lt;/code&gt; 符合此断言。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;(?imsx)&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个或多个嵌入模式匹配修饰符。&lt;code&gt;i&lt;/code&gt; 启用大小写不敏感，&lt;code&gt;m&lt;/code&gt; 启用多行输入处理，&lt;code&gt;s&lt;/code&gt; 启用单行输入处理，&lt;code&gt;x&lt;/code&gt; 启用扩展的空白注释。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;请注意：不支持反向肯定断言——&lt;code&gt;(?&amp;lt;=regexp)&lt;/code&gt; 。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id="215"&gt;21.5 修饰符的放置&lt;/h2&gt;
&lt;p&gt;修饰符可以放在正则表达式的任何地方，然后从放置点开始作用。[ ORO 中有个 bug 使它们不能放在正则表达式的最后。不过，对其他没有影响。]&lt;/p&gt;
&lt;p&gt;单行 &lt;code&gt;(?s)&lt;/code&gt; 和多行 &lt;code&gt;(?m)&lt;/code&gt; 修饰符通常放置在正则表达式的开头。&lt;/p&gt;
&lt;p&gt;忽略大小写修饰符 &lt;code&gt;(?i)&lt;/code&gt; 可以适用于正则表达式的一部分，例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Match ExAct case or (?i)ArBiTrARY(?-i) case
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;将匹配 &lt;code&gt;Match ExAct case or arbitrary case&lt;/code&gt; 以及 &lt;code&gt;Match ExAct case or ARBitrary case&lt;/code&gt;，但不匹配 &lt;code&gt;Match exact case or ArBiTrARY case&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id="216"&gt;21.6 测试正则表达式&lt;/h2&gt;
&lt;p&gt;从 JMeter 2.4 开始，监听器（Listener）&lt;a href="http://jmeter.apache.org/usermanual/component_reference.html#View_Results_Tree"&gt;查看结果树&lt;/a&gt;（View Results Tree）包含一个正则表达式测试器，用于直接在采样器（Sampler）响应数据上测试正则表达式。&lt;/p&gt;
&lt;p&gt;还有一个&lt;a href="http://www.regexplanet.com/advanced/java/index.html"&gt;网站&lt;/a&gt;可以测试 Java 正则表达式。&lt;/p&gt;
&lt;p&gt;另一种方法是使用简单的测试计划来测试正则表达式。Java 请求（Java Request ）采样器可用于生成示例，或 HTTP （HTTP Request）采样器可用于加载文件。添加 Debug Sampler 和树视图监听器，可以无需访问任何外部服务器，快速测试出正则表达式的更改。&lt;/p&gt;</content><category term="JMeter"></category><category term="Documentation"></category><category term="Translation"></category></entry><entry><title>JMeter后置处理器之常用提取器介绍</title><link href="https://jlhxxxx.github.io/jmeter-extractor.html" rel="alternate"></link><published>2019-05-05T00:00:00+08:00</published><updated>2019-05-05T00:00:00+08:00</updated><author><name>Aman</name></author><id>tag:jlhxxxx.github.io,2019-05-05:/jmeter-extractor.html</id><summary type="html">&lt;h2 id="_1"&gt;正则表达式提取器&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Name of created variable&lt;/strong&gt;：用于存储结果的变量名称&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Regular Expression&lt;/strong&gt;：正则表达式&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Template&lt;/strong&gt;：模板，用于从找到的匹配项创建字符串的模板。&lt;code&gt;$1$&lt;/code&gt;表示组&lt;strong&gt;1&lt;/strong&gt;，&lt;code&gt;$2$&lt;/code&gt;表示组&lt;strong&gt;2&lt;/strong&gt;，&lt;code&gt;$0$&lt;/code&gt;表示整个表达式匹配的内容，模板创建的字符串即为上面&lt;strong&gt;变量名称&lt;/strong&gt;对应的值。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Match No.&lt;/strong&gt;：指示要使用的匹配项。&lt;code&gt;0&lt;/code&gt;为随机，正数&lt;code&gt;n&lt;/code&gt;表示第n个匹配项，&lt;code&gt;-1&lt;/code&gt;表示匹配所有。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Default Value&lt;/strong&gt;：默认值，可为空&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;练习网址：&lt;a href="http://www.bejson.com/knownjson/webInterface/"&gt;JSON API免费接口&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这里以JSON响应的查询快递信息为例，返回值如下（已美化且掐头去尾）：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;quot;message&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;ok&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;quot;nu&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;11111111111&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;quot;ischeck&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;1&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;quot;condition …&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;</summary><content type="html">&lt;h2 id="_1"&gt;正则表达式提取器&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Name of created variable&lt;/strong&gt;：用于存储结果的变量名称&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Regular Expression&lt;/strong&gt;：正则表达式&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Template&lt;/strong&gt;：模板，用于从找到的匹配项创建字符串的模板。&lt;code&gt;$1$&lt;/code&gt;表示组&lt;strong&gt;1&lt;/strong&gt;，&lt;code&gt;$2$&lt;/code&gt;表示组&lt;strong&gt;2&lt;/strong&gt;，&lt;code&gt;$0$&lt;/code&gt;表示整个表达式匹配的内容，模板创建的字符串即为上面&lt;strong&gt;变量名称&lt;/strong&gt;对应的值。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Match No.&lt;/strong&gt;：指示要使用的匹配项。&lt;code&gt;0&lt;/code&gt;为随机，正数&lt;code&gt;n&lt;/code&gt;表示第n个匹配项，&lt;code&gt;-1&lt;/code&gt;表示匹配所有。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Default Value&lt;/strong&gt;：默认值，可为空&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;练习网址：&lt;a href="http://www.bejson.com/knownjson/webInterface/"&gt;JSON API免费接口&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这里以JSON响应的查询快递信息为例，返回值如下（已美化且掐头去尾）：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;quot;message&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;ok&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;quot;nu&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;11111111111&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;quot;ischeck&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;1&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;quot;condition&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;F00&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;quot;com&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;yuantong&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;quot;status&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;200&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;quot;state&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;3&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;quot;data&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;[{&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;quot;time&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;2019-04-19 02:36:56&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;quot;ftime&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;2019-04-19 02:36:56&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;quot;context&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;[长沙市]到长沙市【长沙转运中心】&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;quot;location&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;长沙市&amp;quot;&lt;/span&gt;
    &lt;span class="p"&gt;},&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;quot;time&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;2019-04-18 19:32:26&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;quot;ftime&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;2019-04-18 19:32:26&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;quot;context&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;[武汉市]武汉市【武汉转运中心】，正发往【长沙转运中心】&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;quot;location&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;武汉市&amp;quot;&lt;/span&gt;
    &lt;span class="p"&gt;}]&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;假设我们要提取&lt;code&gt;time&lt;/code&gt;和&lt;code&gt;context&lt;/code&gt;。提取器填写如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Name of created variable: data
Regular Expression: &amp;quot;time&amp;quot;:&amp;quot;(.*?)&amp;quot;,&amp;quot;ftime&amp;quot;:&amp;quot;(.*?)&amp;quot;,&amp;quot;context&amp;quot;:&amp;quot;(.*?)&amp;quot;
Template: $0$
Match No.: -1
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;使用Debug Sampler，获得变量名称和对应值如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;data=
data_1=&amp;quot;time&amp;quot;:&amp;quot;2019-04-19 02:36:56&amp;quot;,&amp;quot;ftime&amp;quot;:&amp;quot;2019-04-19 02:36:56&amp;quot;,&amp;quot;context&amp;quot;:&amp;quot;[长沙市]到长沙市【长沙转运中心】&amp;quot;
data_1_g=3
data_1_g0=&amp;quot;time&amp;quot;:&amp;quot;2019-04-19 02:36:56&amp;quot;,&amp;quot;ftime&amp;quot;:&amp;quot;2019-04-19 02:36:56&amp;quot;,&amp;quot;context&amp;quot;:&amp;quot;[长沙市]到长沙市【长沙转运中心】&amp;quot;
data_1_g1=2019-04-19 02:36:56
data_1_g2=2019-04-19 02:36:56
data_1_g3=[长沙市]到长沙市【长沙转运中心】
data_2=&amp;quot;time&amp;quot;:&amp;quot;2019-04-18 19:32:26&amp;quot;,&amp;quot;ftime&amp;quot;:&amp;quot;2019-04-18 19:32:26&amp;quot;,&amp;quot;context&amp;quot;:&amp;quot;[武汉市]武汉市【武汉转运中心】，正发往【长沙转运中心】&amp;quot;
data_2_g=3
data_2_g0=&amp;quot;time&amp;quot;:&amp;quot;2019-04-18 19:32:26&amp;quot;,&amp;quot;ftime&amp;quot;:&amp;quot;2019-04-18 19:32:26&amp;quot;,&amp;quot;context&amp;quot;:&amp;quot;[武汉市]武汉市【武汉转运中心】，正发往【长沙转运中心】&amp;quot;
data_2_g1=2019-04-18 19:32:26
data_2_g2=2019-04-18 19:32:26
data_2_g3=[武汉市]武汉市【武汉转运中心】，正发往【长沙转运中心】
data_matchNr=2
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;说明：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Match No.值为&lt;code&gt;-1&lt;/code&gt;，提取全部的2个匹配项，变量名称规则&lt;code&gt;refName_Ñ_g&lt;/code&gt;，&lt;code&gt;refName&lt;/code&gt;取默认值；若为&lt;code&gt;0&lt;/code&gt;或&lt;code&gt;正数&lt;/code&gt;，只提取一个匹配项，变量名称规则&lt;code&gt;refName_g&lt;/code&gt;，&lt;code&gt;refName&lt;/code&gt;取模板创建值；&lt;/li&gt;
&lt;li&gt;Template填入&lt;code&gt;$0$&lt;/code&gt;，&lt;code&gt;refName_Ñ&lt;/code&gt;对应的值为匹配到的整个匹配项；若填入&lt;code&gt;$1$$3$&lt;/code&gt;，则&lt;code&gt;refName_Ñ&lt;/code&gt;对应的值为&lt;code&gt;refName_Ñ_g1&lt;/code&gt;和&lt;code&gt;refName_Ñ_g3&lt;/code&gt;的拼接。&lt;/li&gt;
&lt;li&gt;有大佬做了个图解的，看起来更直观更好理解：&lt;a href="https://jmetervn.com/2016/10/30/regular-expression-extractor-in-jmeter/"&gt;Regular Expression Extractor in JMeter&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="json"&gt;JSON提取器&lt;/h2&gt;
&lt;p&gt;可以使用&lt;a href="https://goessner.net/articles/JsonPath/"&gt;JSON-PATH语法&lt;/a&gt;从&lt;strong&gt;JSON响应&lt;/strong&gt;中提取数据。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Name of created variables&lt;/strong&gt;：变量名称。注意这里是复数形式，可以填写多个变量名称，名称与名称之间用&lt;code&gt;;&lt;/code&gt;分隔。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Json Path expressions&lt;/strong&gt;：JSON路径表达式。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Match No.&lt;/strong&gt;：指示要使用的匹配项。用法与正则表达式提取器中一致。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Default Values&lt;/strong&gt;：默认值。注意如果提取多个变量一定要填默认值，且不能为空（可以是空格）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Compute concatenation var&lt;/strong&gt;：计算连接变量。如果找到很多结果，插件将使用&lt;code&gt;,&lt;/code&gt;将它们连接起来并将其存储在名为&lt;code&gt;&amp;lt;variable name&amp;gt;_ALL&lt;/code&gt;的变量中。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;例子参考正则表达式提取器的例子，提取器填写如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;Name&lt;/span&gt; &lt;span class="nt"&gt;of&lt;/span&gt; &lt;span class="nt"&gt;created&lt;/span&gt; &lt;span class="nt"&gt;variables&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="nt"&gt;time&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;&lt;span class="nt"&gt;context&lt;/span&gt;
&lt;span class="nt"&gt;Json&lt;/span&gt; &lt;span class="nt"&gt;Path&lt;/span&gt; &lt;span class="nt"&gt;expressions&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="o"&gt;$&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nc"&gt;data&lt;/span&gt;&lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nc"&gt;time&lt;/span&gt;&lt;span class="o"&gt;;$.&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nc"&gt;context&lt;/span&gt;
&lt;span class="nt"&gt;Match&lt;/span&gt; &lt;span class="nt"&gt;No&lt;/span&gt;&lt;span class="o"&gt;.:&lt;/span&gt; &lt;span class="nt"&gt;-1&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;&lt;span class="nt"&gt;-1&lt;/span&gt;
&lt;span class="nt"&gt;Compute&lt;/span&gt; &lt;span class="nt"&gt;concatenation&lt;/span&gt; &lt;span class="nt"&gt;var&lt;/span&gt;&lt;span class="err"&gt;：✔&lt;/span&gt;
&lt;span class="nt"&gt;Default&lt;/span&gt; &lt;span class="nt"&gt;Values&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="nt"&gt;0&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;&lt;span class="nt"&gt;0&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;获得变量名称和对应值如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;context_1=[长沙市]到长沙市【长沙转运中心】
context_2=[武汉市]武汉市【武汉转运中心】，正发往【长沙转运中心】
context_ALL=[长沙市]到长沙市【长沙转运中心】,[武汉市]武汉市【武汉转运中心】，正发往【长沙转运中心】
context_matchNr=2
time_1=2019-04-19 02:36:56
time_2=2019-04-18 19:32:26
time_ALL=2019-04-19 02:36:56,2019-04-18 19:32:26
time_matchNr=2
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;说明：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;表达式、默认值一定要和变量数量匹配&lt;/li&gt;
&lt;li&gt;表达式路径中数组编号用&lt;code&gt;*&lt;/code&gt;表示模糊匹配&lt;/li&gt;
&lt;li&gt;关于JSON PATH表达式更高级的运用，可以参考：&lt;a href="https://jmetervn.com/2016/09/17/json-path-postprocessor-in-jmeter/"&gt;JSON Path PostProcessor in JMeter&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="cssjquery"&gt;CSS/JQuery提取器&lt;/h2&gt;
&lt;p&gt;可以使用CSS Selector语法从服务器HTML响应中提取值。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;CSS/JQuery expression&lt;/strong&gt;：CSS/JQuery表达式。语法参考：&lt;a href="https://jsoup.org/cookbook/extracting-data/selector-syntax"&gt;JSoup&lt;/a&gt;、&lt;a href="https://jodd.org/csselly/"&gt;Jodd-Lagarto（CSSelly）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Attribute&lt;/strong&gt;：从与选择器匹配的节点中提取的属性名称。如果为空，则返回此元素及其所有子元素的组合文本。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这里以Redmine登录页面为例，提取器填写如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Name of created variables: input
CSS/JQuery expression: #login-form &amp;gt; form &amp;gt; table &amp;gt; tbody &amp;gt; tr &amp;gt; td &amp;gt; input
Attribute: name
Match No.: -1
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;获得变量名称和对应值如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;input=
input_1=username
input_2=password
input_3=login
input_matchNr=3
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;说明：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;似乎有点bug，只能获取几个常见属性，像下面的&lt;code&gt;type&lt;/code&gt;，&lt;code&gt;name&lt;/code&gt;，&lt;code&gt;id&lt;/code&gt;，&lt;code&gt;tabindex&lt;/code&gt;，但&lt;code&gt;autocomplete&lt;/code&gt;不行，但使用应该足够了。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&amp;lt;input type=&amp;quot;text&amp;quot; name=&amp;quot;username&amp;quot; id=&amp;quot;username&amp;quot; tabindex=&amp;quot;1&amp;quot; autocomplete=&amp;quot;off&amp;quot;&amp;gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;获取CSS表达式有个简单的方法，Chrome浏览器直接能Copy Selector。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="xpath"&gt;XPATH 提取器&lt;/h2&gt;
&lt;p&gt;可以使用XPath查询语言从结构化响应（XML或（X）HTML）中提取值。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Use Tidy&lt;/strong&gt;：宽容解析器。&lt;strong&gt;解析HTML响应一定要勾选&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Use Namespaces&lt;/strong&gt;：使用命名空间。这个放到XPATH2提取器里重点介绍，这里忽略就好。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Return entire XPath fragment instead of text content?&lt;/strong&gt;：返回整个XPath片段而不只是文本内容，例如&lt;code&gt;//title&lt;/code&gt;将返回&lt;code&gt;&amp;lt;title&amp;gt;Apache JMeter&amp;lt;/title&amp;gt;&lt;/code&gt;而不是&lt;code&gt;Apache JMeter&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;XPath query&lt;/strong&gt;：XPath表达式。语法参考：&lt;a href="http://www.w3school.com.cn/xpath/xpath_syntax.asp"&gt;XPath&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;练习网址：&lt;a href="http://www.webxml.com.cn/WebServices/WeatherWebService.asmx"&gt;WeatherWebService&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这里以查询支持的城市为例，返回值如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;utf-8&amp;quot;?&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;ArrayOfString&lt;/span&gt; &lt;span class="na"&gt;xmlns:xsi=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;http://www.w3.org/2001/XMLSchema-instance&amp;quot;&lt;/span&gt; &lt;span class="na"&gt;xmlns:xsd=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;http://www.w3.org/2001/XMLSchema&amp;quot;&lt;/span&gt; &lt;span class="na"&gt;xmlns=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;http://WebXml.com.cn/&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;北京 (54511)&lt;span class="nt"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;上海 (58367)&lt;span class="nt"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;天津 (54517)&lt;span class="nt"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;重庆 (57516)&lt;span class="nt"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/ArrayOfString&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;提取器填写如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;XML Parsing Options: 不勾选
Name of created variables: city
XPath query: //string
Match No.: -1
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;获得变量名称和对应值如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;city=北京 (54511)
city_1=北京 (54511)
city_2=上海 (58367)
city_3=天津 (54517)
city_4=重庆 (57516)
city_matchNr=4
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;说明：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;勾选&lt;strong&gt;Return entire XPath fragment instead of text content?&lt;/strong&gt;后，变量值是包含命名空间内容的： &lt;code&gt;city=&amp;lt;string xmlns="http://WebXml.com.cn/" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"&amp;gt;北京 (54511)&amp;lt;/string&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Chrome浏览器同样可以直接Copy XPath。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="xpath2"&gt;XPATH2 提取器&lt;/h2&gt;
&lt;p&gt;虽然JMeter官方文档说可以使用XPath2查询语言从结构化响应（XML或（X）HTML）中提取值，但目前测试&lt;strong&gt;只支持从XML响应中提取值&lt;/strong&gt;；从HTML中提取会报错，这个可以通过查看结果树中选择XPath2 Tester来验证。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Namespaces aliases list&lt;/strong&gt;：命名空间别名列表。就是这个功能，能让使用命名空间比使用旧的XPath提取器更方便。关于命名空间含义，可以看官方文档：&lt;a href="http://www.w3school.com.cn/xml/xml_namespaces.asp"&gt;XML 命名空间&lt;/a&gt;，但是写的不够详细，详细的参考这里：&lt;a href="https://blog.csdn.net/yi412/article/details/70158876"&gt;XML 命名空间（XML Namespaces）介绍以及节点读取方法&lt;/a&gt;。由于XPath2对于表达式的要求比较严格，对于带命名空间的XML（包括默认的命名空间），使用不带命名空间前缀的表达式是查询不到结果的。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面看具体实例，提取器填写如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;Name&lt;/span&gt; &lt;span class="k"&gt;of&lt;/span&gt; &lt;span class="n"&gt;created&lt;/span&gt; &lt;span class="n"&gt;variables&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;city&lt;/span&gt;
&lt;span class="n"&gt;XPath&lt;/span&gt; &lt;span class="n"&gt;query&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="o"&gt;//&lt;/span&gt;&lt;span class="n"&gt;cityNS&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="kt"&gt;string&lt;/span&gt;
&lt;span class="n"&gt;Match&lt;/span&gt; &lt;span class="n"&gt;No&lt;/span&gt;&lt;span class="p"&gt;.:&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;
&lt;span class="n"&gt;Namespaces&lt;/span&gt; &lt;span class="n"&gt;aliases&lt;/span&gt; &lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;cityNS&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;http&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="o"&gt;//&lt;/span&gt;&lt;span class="n"&gt;WebXml&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;com&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;cn&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;获得变量名称和对应值如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;city=北京 (54511)
city_1=北京 (54511)
city_2=上海 (58367)
city_3=天津 (54517)
city_4=重庆 (57516)
city_matchNr=4
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;说明：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;虽然返回值包含了3个命名空间的信息，但是我们提取的值只在默认命名空间里，所以&lt;strong&gt;Namespaces aliases list&lt;/strong&gt;只填入默认命名空间即可；别名可以任意命名，注意调用一致。&lt;/li&gt;
&lt;li&gt;XPath2还有更高级的用法，可以支持XPath2函数，比如：&lt;code&gt;compare(/book[1]/page[2],/book[2]/page[2])&lt;/code&gt;，参考&lt;a href="http://saxon.sourceforge.net/saxon7.9.1/functions.html"&gt;XPath2函数&lt;/a&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="_2"&gt;边界值提取器&lt;/h2&gt;
&lt;p&gt;可以使用左右边界从服务器响应中提取值。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Left Boundary&lt;/strong&gt;：左边界。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Right Boundary&lt;/strong&gt;：右边界。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;用上面的例子，提取器填写如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Name of created variables: url
Left Boundary: =&amp;quot;
Right Boundary: &amp;quot;
Match No.: -1
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;获得变量名称和对应值如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;url=
url_1=1.0
url_2=utf-8
url_3=http://www.w3.org/2001/XMLSchema-instance
url_4=http://www.w3.org/2001/XMLSchema
url_5=http://WebXml.com.cn/
url_matchNr=5
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;说明：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;类似简化版的正则表达式提取器，默认非greedy模式。但是左右边界不支持正则表达式，感觉局限性挺大，比如说上面的例子中我只要提取3个url，就很麻烦。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;当然牛逼的大佬根本不用这些花哨的提取器，一个BeanShell就够了，参考文章：&lt;a href="https://www.cnblogs.com/nzg-noway/p/7490412.html"&gt;jmeter ---json几种读取方式，ArrayList循环读取&lt;/a&gt;。&lt;/p&gt;
&lt;/blockquote&gt;</content><category term="JMeter"></category><category term="Extractor"></category></entry><entry><title>Postman入门第一坑：提取返回值</title><link href="https://jlhxxxx.github.io/postman-start.html" rel="alternate"></link><published>2018-04-13T00:00:00+08:00</published><updated>2018-04-13T00:00:00+08:00</updated><author><name>Aman</name></author><id>tag:jlhxxxx.github.io,2018-04-13:/postman-start.html</id><summary type="html">&lt;p&gt;Postman是做接口测试的，但是很多接口并不是直接就能测，有的需要一些预处理。比如说身份认证，需要传递一个&lt;a href="https://zh.wikipedia.org/wiki/%E5%AE%89%E5%85%A8%E4%BB%A4%E7%89%8C"&gt;token&lt;/a&gt;。如果做网页测试，一般打开登陆界面的时候就会生成一个token，如果返回值是json格式，用Postman从中提取值是很简单的，在Tests中输入：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;jsonData&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="nx"&gt;JSON&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;parse&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;responseBody&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="c1"&gt;//获取body中返回的所有参数&lt;/span&gt;
&lt;span class="nx"&gt;pm&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;environment&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;set&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;appKey&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="nx"&gt;jsonData&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;data&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;keys&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="c1"&gt;//把返回参数中的keys设置为环境变量&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;img alt="postman-start-01.png" src="https://github.com/jlhxxxx/imgur/blob/master/blog/postman-start-01.png?raw=true"&gt;&lt;/p&gt;
&lt;p&gt;如果token在返回的header里，也很简单：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;value&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;postman&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;getResponseHeader&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;Access-Token&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="nx"&gt;pm&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;environment&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;set&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;Access-Token&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="nx"&gt;value&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;img alt="postman-start-02.png" src="https://github.com/jlhxxxx/imgur/blob/master/blog/postman-start-02.png?raw=true"&gt;&lt;/p&gt;
&lt;p&gt;如果token在返回值的body中，呵呵，网上并没有适合小白看的清晰的解决方法。我花了&lt;strong&gt;好长好长好长&lt;/strong&gt;时间才找到这么两行小字：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;//转换XML body为JSON对象&lt;/span&gt;
&lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;jsonObject&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;xml2Json&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;responseBody&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;那我的思路就有了 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;Postman是做接口测试的，但是很多接口并不是直接就能测，有的需要一些预处理。比如说身份认证，需要传递一个&lt;a href="https://zh.wikipedia.org/wiki/%E5%AE%89%E5%85%A8%E4%BB%A4%E7%89%8C"&gt;token&lt;/a&gt;。如果做网页测试，一般打开登陆界面的时候就会生成一个token，如果返回值是json格式，用Postman从中提取值是很简单的，在Tests中输入：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;jsonData&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="nx"&gt;JSON&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;parse&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;responseBody&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="c1"&gt;//获取body中返回的所有参数&lt;/span&gt;
&lt;span class="nx"&gt;pm&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;environment&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;set&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;appKey&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="nx"&gt;jsonData&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;data&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;keys&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="c1"&gt;//把返回参数中的keys设置为环境变量&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;img alt="postman-start-01.png" src="https://github.com/jlhxxxx/imgur/blob/master/blog/postman-start-01.png?raw=true"&gt;&lt;/p&gt;
&lt;p&gt;如果token在返回的header里，也很简单：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;value&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;postman&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;getResponseHeader&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;Access-Token&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="nx"&gt;pm&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;environment&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;set&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;Access-Token&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="nx"&gt;value&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;img alt="postman-start-02.png" src="https://github.com/jlhxxxx/imgur/blob/master/blog/postman-start-02.png?raw=true"&gt;&lt;/p&gt;
&lt;p&gt;如果token在返回值的body中，呵呵，网上并没有适合小白看的清晰的解决方法。我花了&lt;strong&gt;好长好长好长&lt;/strong&gt;时间才找到这么两行小字：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;//转换XML body为JSON对象&lt;/span&gt;
&lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;jsonObject&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;xml2Json&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;responseBody&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;那我的思路就有了：将html转换成json，再从json中提取token不就简单了。&lt;/p&gt;
&lt;p&gt;依然还是老办法，拿出我的终极武器——&lt;strong&gt;redmine&lt;/strong&gt;来测试。登陆页面的返回值大概是这样的，我们要提取的是&lt;code&gt;csrf-token&lt;/code&gt;：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;&amp;lt;!DOCTYPE html&amp;gt;&lt;/span&gt;
&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;html&lt;/span&gt; &lt;span class="na"&gt;lang&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;zh&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
    &lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;head&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
        &lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;meta&lt;/span&gt; &lt;span class="na"&gt;charset&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;utf-8&amp;quot;&lt;/span&gt; &lt;span class="p"&gt;/&amp;gt;&lt;/span&gt;
        &lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;title&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;Redmine&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;title&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
        &lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;meta&lt;/span&gt; &lt;span class="na"&gt;name&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;description&amp;quot;&lt;/span&gt; &lt;span class="na"&gt;content&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Redmine&amp;quot;&lt;/span&gt; &lt;span class="p"&gt;/&amp;gt;&lt;/span&gt;
        &lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;meta&lt;/span&gt; &lt;span class="na"&gt;name&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;keywords&amp;quot;&lt;/span&gt; &lt;span class="na"&gt;content&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;issue,bug,tracker&amp;quot;&lt;/span&gt; &lt;span class="p"&gt;/&amp;gt;&lt;/span&gt;
        &lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;meta&lt;/span&gt; &lt;span class="na"&gt;name&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;csrf-param&amp;quot;&lt;/span&gt; &lt;span class="na"&gt;content&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;authenticity_token&amp;quot;&lt;/span&gt; &lt;span class="p"&gt;/&amp;gt;&lt;/span&gt;
        &lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;meta&lt;/span&gt; &lt;span class="na"&gt;name&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;csrf-token&amp;quot;&lt;/span&gt; &lt;span class="na"&gt;content&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;u9XfPXNDqQ/v+/xUtQuAjESgvNXCTHxCWW4NIZ/rJBmfZjzqJBVD1fDOxHnlbza4iDreX+St9SE9XFIN4on47Q==&amp;quot;&lt;/span&gt; &lt;span class="p"&gt;/&amp;gt;&lt;/span&gt;
        ...
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;一开始我觉得可能是这样取值：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nx"&gt;pm&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;globals&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;set&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;token&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;jsonObject&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;html&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;head&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;meta&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="nx"&gt;content&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;为了调试方便，我们这里取全局（globals）变量，因为环境（environment）变量只有在测试执行过程中才存在，测试执行完就释放了。&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;send&lt;/code&gt;之后点右上角小眼睛，如果全局变量取到值的话这里会有显示的：&lt;/p&gt;
&lt;p&gt;&lt;img alt="p-start-03.png" src="https://github.com/jlhxxxx/imgur/blob/master/blog/postman-start-03.png?raw=true"&gt;&lt;/p&gt;
&lt;p&gt;然而并没有，排查原因，把最后的&lt;code&gt;content&lt;/code&gt;去掉试试（为了看的更清楚，把&lt;code&gt;[4]&lt;/code&gt;也去掉）：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;jsonObject&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;xml2Json&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;responseBody&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="nx"&gt;pm&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;globals&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;set&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;token&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;jsonObject&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;html&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;head&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;meta&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这时候取到全局变量了，不过&lt;code&gt;[object Object],[object Object]...&lt;/code&gt;需要翻译啊，很明显取到&lt;code&gt;meta&lt;/code&gt;这一层是没错的：&lt;/p&gt;
&lt;p&gt;&lt;img alt="Postman-start-04.png" src="https://github.com/jlhxxxx/imgur/blob/master/blog/postman-start-04.png?raw=true"&gt;&lt;/p&gt;
&lt;p&gt;这时候需要一个将json转换成字符串的工具，方便我分析，然后就找到了&lt;code&gt;JSON.stringify()&lt;/code&gt;：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nx"&gt;pm&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;globals&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;set&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;getstring&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;JSON&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;stringify&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;jsonObject&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;html&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;head&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;meta&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;img alt="postman-start-05.png" src="https://github.com/jlhxxxx/imgur/blob/master/blog/postman-start-05.png?raw=true"&gt;&lt;/p&gt;
&lt;p&gt;将json复制出来美化一下：&lt;/p&gt;
&lt;p&gt;&lt;img alt="postman-start-06.png" src="https://github.com/jlhxxxx/imgur/blob/master/blog/postman-start-06.png?raw=true"&gt;&lt;/p&gt;
&lt;p&gt;原来&lt;code&gt;meta&lt;/code&gt;下一层是个&lt;code&gt;$&lt;/code&gt;。事后才醒悟过来，&lt;code&gt;name&lt;/code&gt;和&lt;code&gt;content&lt;/code&gt;并不是&lt;code&gt;meta&lt;/code&gt;的下层，而是&lt;code&gt;meta&lt;/code&gt;的属性，&lt;code&gt;xml2Json()&lt;/code&gt;方法将属性转换成&lt;code&gt;$&lt;/code&gt;标记的下层。&lt;/p&gt;
&lt;p&gt;修改之后再次测试：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nx"&gt;pm&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;globals&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;set&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;token&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;jsonObject&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;html&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;head&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;meta&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="nx"&gt;$&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;content&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;img alt="postman-start-07.png" src="https://github.com/jlhxxxx/imgur/blob/master/blog/postman-start-07.png?raw=true"&gt;&lt;/p&gt;
&lt;p&gt;完美解决。&lt;/p&gt;
&lt;h3 id="_1"&gt;总结&lt;/h3&gt;
&lt;p&gt;Postman从响应中提取值的方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;从json中提取&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;jsonData&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="nx"&gt;JSON&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;parse&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;responseBody&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;从html的Header中提取&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;value&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;postman&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;getResponseHeader&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;Access-Token&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="nx"&gt;pm&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;environment&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;set&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;Access-Token&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="nx"&gt;value&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;从html的body中提取&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;jsonObject&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;xml2Json&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;responseBody&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;将json object转换成字符串的函数&lt;code&gt;JSON.stringify(jsonObject)&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id="_2"&gt;参考文章&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.cnblogs.com/JHblogs/p/6418802.html"&gt;Postman接口自动化，环境变量的用法详解（附Postman常用的方法）&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><category term="Postman"></category><category term="Interface"></category><category term="Test"></category></entry></feed>